
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Teacher
 * 
 */
export type Teacher = $Result.DefaultSelection<Prisma.$TeacherPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Class
 * 
 */
export type Class = $Result.DefaultSelection<Prisma.$ClassPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model Assignment
 * 
 */
export type Assignment = $Result.DefaultSelection<Prisma.$AssignmentPayload>
/**
 * Model AssignmentSubmission
 * 
 */
export type AssignmentSubmission = $Result.DefaultSelection<Prisma.$AssignmentSubmissionPayload>
/**
 * Model AttendanceRecord
 * 
 */
export type AttendanceRecord = $Result.DefaultSelection<Prisma.$AttendanceRecordPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model FinancialRecord
 * 
 */
export type FinancialRecord = $Result.DefaultSelection<Prisma.$FinancialRecordPayload>
/**
 * Model AdmissionApplication
 * 
 */
export type AdmissionApplication = $Result.DefaultSelection<Prisma.$AdmissionApplicationPayload>
/**
 * Model AdmissionStepProgress
 * 
 */
export type AdmissionStepProgress = $Result.DefaultSelection<Prisma.$AdmissionStepProgressPayload>
/**
 * Model LearningResource
 * 
 */
export type LearningResource = $Result.DefaultSelection<Prisma.$LearningResourcePayload>
/**
 * Model VirtualClass
 * 
 */
export type VirtualClass = $Result.DefaultSelection<Prisma.$VirtualClassPayload>
/**
 * Model VirtualClassParticipant
 * 
 */
export type VirtualClassParticipant = $Result.DefaultSelection<Prisma.$VirtualClassParticipantPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model StudentAchievement
 * 
 */
export type StudentAchievement = $Result.DefaultSelection<Prisma.$StudentAchievementPayload>
/**
 * Model BehaviorRecord
 * 
 */
export type BehaviorRecord = $Result.DefaultSelection<Prisma.$BehaviorRecordPayload>
/**
 * Model ReportCard
 * 
 */
export type ReportCard = $Result.DefaultSelection<Prisma.$ReportCardPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model FileAttachment
 * 
 */
export type FileAttachment = $Result.DefaultSelection<Prisma.$FileAttachmentPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model TeacherSubject
 * 
 */
export type TeacherSubject = $Result.DefaultSelection<Prisma.$TeacherSubjectPayload>
/**
 * Model TeacherClass
 * 
 */
export type TeacherClass = $Result.DefaultSelection<Prisma.$TeacherClassPayload>
/**
 * Model ClassSubject
 * 
 */
export type ClassSubject = $Result.DefaultSelection<Prisma.$ClassSubjectPayload>
/**
 * Model AssignmentClass
 * 
 */
export type AssignmentClass = $Result.DefaultSelection<Prisma.$AssignmentClassPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  STUDENT: 'STUDENT',
  TEACHER: 'TEACHER',
  PARENT: 'PARENT',
  ADMIN: 'ADMIN',
  STAFF: 'STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ContactMethod: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  PHONE: 'PHONE'
};

export type ContactMethod = (typeof ContactMethod)[keyof typeof ContactMethod]


export const GradeType: {
  HOMEWORK: 'HOMEWORK',
  TEST: 'TEST',
  QUIZ: 'QUIZ',
  PROJECT: 'PROJECT',
  EXAM: 'EXAM'
};

export type GradeType = (typeof GradeType)[keyof typeof GradeType]


export const AssignmentType: {
  HOMEWORK: 'HOMEWORK',
  PROJECT: 'PROJECT',
  EXAM: 'EXAM',
  QUIZ: 'QUIZ'
};

export type AssignmentType = (typeof AssignmentType)[keyof typeof AssignmentType]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const SubmissionFormat: {
  ONLINE: 'ONLINE',
  PAPER: 'PAPER',
  BOTH: 'BOTH'
};

export type SubmissionFormat = (typeof SubmissionFormat)[keyof typeof SubmissionFormat]


export const SubmissionStatus: {
  PENDING: 'PENDING',
  SUBMITTED: 'SUBMITTED',
  GRADED: 'GRADED',
  LATE: 'LATE'
};

export type SubmissionStatus = (typeof SubmissionStatus)[keyof typeof SubmissionStatus]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  LATE: 'LATE',
  EXCUSED: 'EXCUSED'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const MessageType: {
  MESSAGE: 'MESSAGE',
  ANNOUNCEMENT: 'ANNOUNCEMENT',
  ALERT: 'ALERT',
  NOTIFICATION: 'NOTIFICATION'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const FinancialType: {
  TUITION: 'TUITION',
  FEES: 'FEES',
  MATERIALS: 'MATERIALS',
  TRANSPORT: 'TRANSPORT',
  MEALS: 'MEALS',
  OTHER: 'OTHER'
};

export type FinancialType = (typeof FinancialType)[keyof typeof FinancialType]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  TRANSFER: 'TRANSFER',
  CHECK: 'CHECK',
  MOBILE_MONEY: 'MOBILE_MONEY'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const AdmissionStatus: {
  SUBMITTED: 'SUBMITTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  WAITLISTED: 'WAITLISTED'
};

export type AdmissionStatus = (typeof AdmissionStatus)[keyof typeof AdmissionStatus]


export const StepStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  SKIPPED: 'SKIPPED'
};

export type StepStatus = (typeof StepStatus)[keyof typeof StepStatus]


export const ResourceType: {
  VIDEO: 'VIDEO',
  DOCUMENT: 'DOCUMENT',
  AUDIO: 'AUDIO',
  INTERACTIVE: 'INTERACTIVE',
  QUIZ: 'QUIZ',
  GAME: 'GAME'
};

export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType]


export const AccessLevel: {
  PUBLIC: 'PUBLIC',
  CLASS: 'CLASS',
  SCHOOL: 'SCHOOL',
  PREMIUM: 'PREMIUM'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const VirtualClassStatus: {
  SCHEDULED: 'SCHEDULED',
  LIVE: 'LIVE',
  ENDED: 'ENDED',
  CANCELLED: 'CANCELLED'
};

export type VirtualClassStatus = (typeof VirtualClassStatus)[keyof typeof VirtualClassStatus]


export const AchievementCategory: {
  ACADEMIC: 'ACADEMIC',
  BEHAVIOR: 'BEHAVIOR',
  PARTICIPATION: 'PARTICIPATION',
  LEADERSHIP: 'LEADERSHIP',
  CREATIVITY: 'CREATIVITY'
};

export type AchievementCategory = (typeof AchievementCategory)[keyof typeof AchievementCategory]


export const Rarity: {
  COMMON: 'COMMON',
  UNCOMMON: 'UNCOMMON',
  RARE: 'RARE',
  LEGENDARY: 'LEGENDARY'
};

export type Rarity = (typeof Rarity)[keyof typeof Rarity]


export const BehaviorType: {
  POSITIVE: 'POSITIVE',
  NEGATIVE: 'NEGATIVE',
  NEUTRAL: 'NEUTRAL'
};

export type BehaviorType = (typeof BehaviorType)[keyof typeof BehaviorType]


export const BehaviorCategory: {
  DISCIPLINE: 'DISCIPLINE',
  PARTICIPATION: 'PARTICIPATION',
  HOMEWORK: 'HOMEWORK',
  SOCIAL: 'SOCIAL',
  OTHER: 'OTHER'
};

export type BehaviorCategory = (typeof BehaviorCategory)[keyof typeof BehaviorCategory]


export const Severity: {
  MINOR: 'MINOR',
  MODERATE: 'MODERATE',
  MAJOR: 'MAJOR'
};

export type Severity = (typeof Severity)[keyof typeof Severity]


export const BehaviorGrade: {
  EXCELLENT: 'EXCELLENT',
  GOOD: 'GOOD',
  SATISFACTORY: 'SATISFACTORY',
  NEEDS_IMPROVEMENT: 'NEEDS_IMPROVEMENT'
};

export type BehaviorGrade = (typeof BehaviorGrade)[keyof typeof BehaviorGrade]


export const NotificationType: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  SUCCESS: 'SUCCESS'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationCategory: {
  ACADEMIC: 'ACADEMIC',
  ATTENDANCE: 'ATTENDANCE',
  FINANCIAL: 'FINANCIAL',
  ADMINISTRATIVE: 'ADMINISTRATIVE',
  SOCIAL: 'SOCIAL'
};

export type NotificationCategory = (typeof NotificationCategory)[keyof typeof NotificationCategory]


export const NotificationChannel: {
  EMAIL: 'EMAIL',
  SMS: 'SMS',
  PUSH: 'PUSH',
  IN_APP: 'IN_APP'
};

export type NotificationChannel = (typeof NotificationChannel)[keyof typeof NotificationChannel]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ContactMethod = $Enums.ContactMethod

export const ContactMethod: typeof $Enums.ContactMethod

export type GradeType = $Enums.GradeType

export const GradeType: typeof $Enums.GradeType

export type AssignmentType = $Enums.AssignmentType

export const AssignmentType: typeof $Enums.AssignmentType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type SubmissionFormat = $Enums.SubmissionFormat

export const SubmissionFormat: typeof $Enums.SubmissionFormat

export type SubmissionStatus = $Enums.SubmissionStatus

export const SubmissionStatus: typeof $Enums.SubmissionStatus

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type FinancialType = $Enums.FinancialType

export const FinancialType: typeof $Enums.FinancialType

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type AdmissionStatus = $Enums.AdmissionStatus

export const AdmissionStatus: typeof $Enums.AdmissionStatus

export type StepStatus = $Enums.StepStatus

export const StepStatus: typeof $Enums.StepStatus

export type ResourceType = $Enums.ResourceType

export const ResourceType: typeof $Enums.ResourceType

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

export type VirtualClassStatus = $Enums.VirtualClassStatus

export const VirtualClassStatus: typeof $Enums.VirtualClassStatus

export type AchievementCategory = $Enums.AchievementCategory

export const AchievementCategory: typeof $Enums.AchievementCategory

export type Rarity = $Enums.Rarity

export const Rarity: typeof $Enums.Rarity

export type BehaviorType = $Enums.BehaviorType

export const BehaviorType: typeof $Enums.BehaviorType

export type BehaviorCategory = $Enums.BehaviorCategory

export const BehaviorCategory: typeof $Enums.BehaviorCategory

export type Severity = $Enums.Severity

export const Severity: typeof $Enums.Severity

export type BehaviorGrade = $Enums.BehaviorGrade

export const BehaviorGrade: typeof $Enums.BehaviorGrade

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationCategory = $Enums.NotificationCategory

export const NotificationCategory: typeof $Enums.NotificationCategory

export type NotificationChannel = $Enums.NotificationChannel

export const NotificationChannel: typeof $Enums.NotificationChannel

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.teacher`: Exposes CRUD operations for the **Teacher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teacher.findMany()
    * ```
    */
  get teacher(): Prisma.TeacherDelegate<ExtArgs>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.class`: Exposes CRUD operations for the **Class** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classes
    * const classes = await prisma.class.findMany()
    * ```
    */
  get class(): Prisma.ClassDelegate<ExtArgs>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs>;

  /**
   * `prisma.assignment`: Exposes CRUD operations for the **Assignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignment.findMany()
    * ```
    */
  get assignment(): Prisma.AssignmentDelegate<ExtArgs>;

  /**
   * `prisma.assignmentSubmission`: Exposes CRUD operations for the **AssignmentSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignmentSubmissions
    * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
    * ```
    */
  get assignmentSubmission(): Prisma.AssignmentSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.attendanceRecord`: Exposes CRUD operations for the **AttendanceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceRecords
    * const attendanceRecords = await prisma.attendanceRecord.findMany()
    * ```
    */
  get attendanceRecord(): Prisma.AttendanceRecordDelegate<ExtArgs>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;

  /**
   * `prisma.financialRecord`: Exposes CRUD operations for the **FinancialRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialRecords
    * const financialRecords = await prisma.financialRecord.findMany()
    * ```
    */
  get financialRecord(): Prisma.FinancialRecordDelegate<ExtArgs>;

  /**
   * `prisma.admissionApplication`: Exposes CRUD operations for the **AdmissionApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmissionApplications
    * const admissionApplications = await prisma.admissionApplication.findMany()
    * ```
    */
  get admissionApplication(): Prisma.AdmissionApplicationDelegate<ExtArgs>;

  /**
   * `prisma.admissionStepProgress`: Exposes CRUD operations for the **AdmissionStepProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmissionStepProgresses
    * const admissionStepProgresses = await prisma.admissionStepProgress.findMany()
    * ```
    */
  get admissionStepProgress(): Prisma.AdmissionStepProgressDelegate<ExtArgs>;

  /**
   * `prisma.learningResource`: Exposes CRUD operations for the **LearningResource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningResources
    * const learningResources = await prisma.learningResource.findMany()
    * ```
    */
  get learningResource(): Prisma.LearningResourceDelegate<ExtArgs>;

  /**
   * `prisma.virtualClass`: Exposes CRUD operations for the **VirtualClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VirtualClasses
    * const virtualClasses = await prisma.virtualClass.findMany()
    * ```
    */
  get virtualClass(): Prisma.VirtualClassDelegate<ExtArgs>;

  /**
   * `prisma.virtualClassParticipant`: Exposes CRUD operations for the **VirtualClassParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VirtualClassParticipants
    * const virtualClassParticipants = await prisma.virtualClassParticipant.findMany()
    * ```
    */
  get virtualClassParticipant(): Prisma.VirtualClassParticipantDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.studentAchievement`: Exposes CRUD operations for the **StudentAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentAchievements
    * const studentAchievements = await prisma.studentAchievement.findMany()
    * ```
    */
  get studentAchievement(): Prisma.StudentAchievementDelegate<ExtArgs>;

  /**
   * `prisma.behaviorRecord`: Exposes CRUD operations for the **BehaviorRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehaviorRecords
    * const behaviorRecords = await prisma.behaviorRecord.findMany()
    * ```
    */
  get behaviorRecord(): Prisma.BehaviorRecordDelegate<ExtArgs>;

  /**
   * `prisma.reportCard`: Exposes CRUD operations for the **ReportCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportCards
    * const reportCards = await prisma.reportCard.findMany()
    * ```
    */
  get reportCard(): Prisma.ReportCardDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.fileAttachment`: Exposes CRUD operations for the **FileAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileAttachments
    * const fileAttachments = await prisma.fileAttachment.findMany()
    * ```
    */
  get fileAttachment(): Prisma.FileAttachmentDelegate<ExtArgs>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs>;

  /**
   * `prisma.teacherSubject`: Exposes CRUD operations for the **TeacherSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherSubjects
    * const teacherSubjects = await prisma.teacherSubject.findMany()
    * ```
    */
  get teacherSubject(): Prisma.TeacherSubjectDelegate<ExtArgs>;

  /**
   * `prisma.teacherClass`: Exposes CRUD operations for the **TeacherClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherClasses
    * const teacherClasses = await prisma.teacherClass.findMany()
    * ```
    */
  get teacherClass(): Prisma.TeacherClassDelegate<ExtArgs>;

  /**
   * `prisma.classSubject`: Exposes CRUD operations for the **ClassSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassSubjects
    * const classSubjects = await prisma.classSubject.findMany()
    * ```
    */
  get classSubject(): Prisma.ClassSubjectDelegate<ExtArgs>;

  /**
   * `prisma.assignmentClass`: Exposes CRUD operations for the **AssignmentClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssignmentClasses
    * const assignmentClasses = await prisma.assignmentClass.findMany()
    * ```
    */
  get assignmentClass(): Prisma.AssignmentClassDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Student: 'Student',
    Teacher: 'Teacher',
    Parent: 'Parent',
    Admin: 'Admin',
    Class: 'Class',
    Subject: 'Subject',
    Grade: 'Grade',
    Assignment: 'Assignment',
    AssignmentSubmission: 'AssignmentSubmission',
    AttendanceRecord: 'AttendanceRecord',
    Schedule: 'Schedule',
    Message: 'Message',
    FinancialRecord: 'FinancialRecord',
    AdmissionApplication: 'AdmissionApplication',
    AdmissionStepProgress: 'AdmissionStepProgress',
    LearningResource: 'LearningResource',
    VirtualClass: 'VirtualClass',
    VirtualClassParticipant: 'VirtualClassParticipant',
    Achievement: 'Achievement',
    StudentAchievement: 'StudentAchievement',
    BehaviorRecord: 'BehaviorRecord',
    ReportCard: 'ReportCard',
    Notification: 'Notification',
    FileAttachment: 'FileAttachment',
    UserSession: 'UserSession',
    TeacherSubject: 'TeacherSubject',
    TeacherClass: 'TeacherClass',
    ClassSubject: 'ClassSubject',
    AssignmentClass: 'AssignmentClass'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "student" | "teacher" | "parent" | "admin" | "class" | "subject" | "grade" | "assignment" | "assignmentSubmission" | "attendanceRecord" | "schedule" | "message" | "financialRecord" | "admissionApplication" | "admissionStepProgress" | "learningResource" | "virtualClass" | "virtualClassParticipant" | "achievement" | "studentAchievement" | "behaviorRecord" | "reportCard" | "notification" | "fileAttachment" | "userSession" | "teacherSubject" | "teacherClass" | "classSubject" | "assignmentClass"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Teacher: {
        payload: Prisma.$TeacherPayload<ExtArgs>
        fields: Prisma.TeacherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findFirst: {
            args: Prisma.TeacherFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          findMany: {
            args: Prisma.TeacherFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          create: {
            args: Prisma.TeacherCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          createMany: {
            args: Prisma.TeacherCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>[]
          }
          delete: {
            args: Prisma.TeacherDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          update: {
            args: Prisma.TeacherUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          deleteMany: {
            args: Prisma.TeacherDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherPayload>
          }
          aggregate: {
            args: Prisma.TeacherAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher>
          }
          groupBy: {
            args: Prisma.TeacherGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Class: {
        payload: Prisma.$ClassPayload<ExtArgs>
        fields: Prisma.ClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findFirst: {
            args: Prisma.ClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          findMany: {
            args: Prisma.ClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          create: {
            args: Prisma.ClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          createMany: {
            args: Prisma.ClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>[]
          }
          delete: {
            args: Prisma.ClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          update: {
            args: Prisma.ClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          deleteMany: {
            args: Prisma.ClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassPayload>
          }
          aggregate: {
            args: Prisma.ClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass>
          }
          groupBy: {
            args: Prisma.ClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassCountArgs<ExtArgs>
            result: $Utils.Optional<ClassCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      Assignment: {
        payload: Prisma.$AssignmentPayload<ExtArgs>
        fields: Prisma.AssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findFirst: {
            args: Prisma.AssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          findMany: {
            args: Prisma.AssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          create: {
            args: Prisma.AssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          createMany: {
            args: Prisma.AssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>[]
          }
          delete: {
            args: Prisma.AssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          update: {
            args: Prisma.AssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentPayload>
          }
          aggregate: {
            args: Prisma.AssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignment>
          }
          groupBy: {
            args: Prisma.AssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentCountAggregateOutputType> | number
          }
        }
      }
      AssignmentSubmission: {
        payload: Prisma.$AssignmentSubmissionPayload<ExtArgs>
        fields: Prisma.AssignmentSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findFirst: {
            args: Prisma.AssignmentSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          findMany: {
            args: Prisma.AssignmentSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          create: {
            args: Prisma.AssignmentSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          createMany: {
            args: Prisma.AssignmentSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>[]
          }
          delete: {
            args: Prisma.AssignmentSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          update: {
            args: Prisma.AssignmentSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentSubmissionPayload>
          }
          aggregate: {
            args: Prisma.AssignmentSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignmentSubmission>
          }
          groupBy: {
            args: Prisma.AssignmentSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentSubmissionCountAggregateOutputType> | number
          }
        }
      }
      AttendanceRecord: {
        payload: Prisma.$AttendanceRecordPayload<ExtArgs>
        fields: Prisma.AttendanceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findFirst: {
            args: Prisma.AttendanceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          findMany: {
            args: Prisma.AttendanceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          create: {
            args: Prisma.AttendanceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          createMany: {
            args: Prisma.AttendanceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>[]
          }
          delete: {
            args: Prisma.AttendanceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          update: {
            args: Prisma.AttendanceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceRecordPayload>
          }
          aggregate: {
            args: Prisma.AttendanceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceRecord>
          }
          groupBy: {
            args: Prisma.AttendanceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceRecordCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      FinancialRecord: {
        payload: Prisma.$FinancialRecordPayload<ExtArgs>
        fields: Prisma.FinancialRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          findFirst: {
            args: Prisma.FinancialRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          findMany: {
            args: Prisma.FinancialRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>[]
          }
          create: {
            args: Prisma.FinancialRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          createMany: {
            args: Prisma.FinancialRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FinancialRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>[]
          }
          delete: {
            args: Prisma.FinancialRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          update: {
            args: Prisma.FinancialRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          deleteMany: {
            args: Prisma.FinancialRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancialRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialRecordPayload>
          }
          aggregate: {
            args: Prisma.FinancialRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialRecord>
          }
          groupBy: {
            args: Prisma.FinancialRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialRecordCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialRecordCountAggregateOutputType> | number
          }
        }
      }
      AdmissionApplication: {
        payload: Prisma.$AdmissionApplicationPayload<ExtArgs>
        fields: Prisma.AdmissionApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>
          }
          findFirst: {
            args: Prisma.AdmissionApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>
          }
          findMany: {
            args: Prisma.AdmissionApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>[]
          }
          create: {
            args: Prisma.AdmissionApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>
          }
          createMany: {
            args: Prisma.AdmissionApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>[]
          }
          delete: {
            args: Prisma.AdmissionApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>
          }
          update: {
            args: Prisma.AdmissionApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionApplicationPayload>
          }
          aggregate: {
            args: Prisma.AdmissionApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissionApplication>
          }
          groupBy: {
            args: Prisma.AdmissionApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionApplicationCountAggregateOutputType> | number
          }
        }
      }
      AdmissionStepProgress: {
        payload: Prisma.$AdmissionStepProgressPayload<ExtArgs>
        fields: Prisma.AdmissionStepProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionStepProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionStepProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>
          }
          findFirst: {
            args: Prisma.AdmissionStepProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionStepProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>
          }
          findMany: {
            args: Prisma.AdmissionStepProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>[]
          }
          create: {
            args: Prisma.AdmissionStepProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>
          }
          createMany: {
            args: Prisma.AdmissionStepProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionStepProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>[]
          }
          delete: {
            args: Prisma.AdmissionStepProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>
          }
          update: {
            args: Prisma.AdmissionStepProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionStepProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionStepProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionStepProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionStepProgressPayload>
          }
          aggregate: {
            args: Prisma.AdmissionStepProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissionStepProgress>
          }
          groupBy: {
            args: Prisma.AdmissionStepProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionStepProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionStepProgressCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionStepProgressCountAggregateOutputType> | number
          }
        }
      }
      LearningResource: {
        payload: Prisma.$LearningResourcePayload<ExtArgs>
        fields: Prisma.LearningResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>
          }
          findFirst: {
            args: Prisma.LearningResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>
          }
          findMany: {
            args: Prisma.LearningResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>[]
          }
          create: {
            args: Prisma.LearningResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>
          }
          createMany: {
            args: Prisma.LearningResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningResourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>[]
          }
          delete: {
            args: Prisma.LearningResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>
          }
          update: {
            args: Prisma.LearningResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>
          }
          deleteMany: {
            args: Prisma.LearningResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningResourcePayload>
          }
          aggregate: {
            args: Prisma.LearningResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningResource>
          }
          groupBy: {
            args: Prisma.LearningResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningResourceCountArgs<ExtArgs>
            result: $Utils.Optional<LearningResourceCountAggregateOutputType> | number
          }
        }
      }
      VirtualClass: {
        payload: Prisma.$VirtualClassPayload<ExtArgs>
        fields: Prisma.VirtualClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VirtualClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VirtualClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>
          }
          findFirst: {
            args: Prisma.VirtualClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VirtualClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>
          }
          findMany: {
            args: Prisma.VirtualClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>[]
          }
          create: {
            args: Prisma.VirtualClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>
          }
          createMany: {
            args: Prisma.VirtualClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VirtualClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>[]
          }
          delete: {
            args: Prisma.VirtualClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>
          }
          update: {
            args: Prisma.VirtualClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>
          }
          deleteMany: {
            args: Prisma.VirtualClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VirtualClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VirtualClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassPayload>
          }
          aggregate: {
            args: Prisma.VirtualClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtualClass>
          }
          groupBy: {
            args: Prisma.VirtualClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<VirtualClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.VirtualClassCountArgs<ExtArgs>
            result: $Utils.Optional<VirtualClassCountAggregateOutputType> | number
          }
        }
      }
      VirtualClassParticipant: {
        payload: Prisma.$VirtualClassParticipantPayload<ExtArgs>
        fields: Prisma.VirtualClassParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VirtualClassParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VirtualClassParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>
          }
          findFirst: {
            args: Prisma.VirtualClassParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VirtualClassParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>
          }
          findMany: {
            args: Prisma.VirtualClassParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>[]
          }
          create: {
            args: Prisma.VirtualClassParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>
          }
          createMany: {
            args: Prisma.VirtualClassParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VirtualClassParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>[]
          }
          delete: {
            args: Prisma.VirtualClassParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>
          }
          update: {
            args: Prisma.VirtualClassParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>
          }
          deleteMany: {
            args: Prisma.VirtualClassParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VirtualClassParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VirtualClassParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VirtualClassParticipantPayload>
          }
          aggregate: {
            args: Prisma.VirtualClassParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVirtualClassParticipant>
          }
          groupBy: {
            args: Prisma.VirtualClassParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<VirtualClassParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.VirtualClassParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<VirtualClassParticipantCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      StudentAchievement: {
        payload: Prisma.$StudentAchievementPayload<ExtArgs>
        fields: Prisma.StudentAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>
          }
          findFirst: {
            args: Prisma.StudentAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>
          }
          findMany: {
            args: Prisma.StudentAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>[]
          }
          create: {
            args: Prisma.StudentAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>
          }
          createMany: {
            args: Prisma.StudentAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>[]
          }
          delete: {
            args: Prisma.StudentAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>
          }
          update: {
            args: Prisma.StudentAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>
          }
          deleteMany: {
            args: Prisma.StudentAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentAchievementPayload>
          }
          aggregate: {
            args: Prisma.StudentAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentAchievement>
          }
          groupBy: {
            args: Prisma.StudentAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<StudentAchievementCountAggregateOutputType> | number
          }
        }
      }
      BehaviorRecord: {
        payload: Prisma.$BehaviorRecordPayload<ExtArgs>
        fields: Prisma.BehaviorRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehaviorRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehaviorRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          findFirst: {
            args: Prisma.BehaviorRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehaviorRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          findMany: {
            args: Prisma.BehaviorRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>[]
          }
          create: {
            args: Prisma.BehaviorRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          createMany: {
            args: Prisma.BehaviorRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehaviorRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>[]
          }
          delete: {
            args: Prisma.BehaviorRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          update: {
            args: Prisma.BehaviorRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          deleteMany: {
            args: Prisma.BehaviorRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehaviorRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BehaviorRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorRecordPayload>
          }
          aggregate: {
            args: Prisma.BehaviorRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehaviorRecord>
          }
          groupBy: {
            args: Prisma.BehaviorRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehaviorRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehaviorRecordCountArgs<ExtArgs>
            result: $Utils.Optional<BehaviorRecordCountAggregateOutputType> | number
          }
        }
      }
      ReportCard: {
        payload: Prisma.$ReportCardPayload<ExtArgs>
        fields: Prisma.ReportCardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportCardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportCardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findFirst: {
            args: Prisma.ReportCardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportCardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          findMany: {
            args: Prisma.ReportCardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          create: {
            args: Prisma.ReportCardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          createMany: {
            args: Prisma.ReportCardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>[]
          }
          delete: {
            args: Prisma.ReportCardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          update: {
            args: Prisma.ReportCardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          deleteMany: {
            args: Prisma.ReportCardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportCardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportCardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportCardPayload>
          }
          aggregate: {
            args: Prisma.ReportCardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportCard>
          }
          groupBy: {
            args: Prisma.ReportCardGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportCardGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCardCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCardCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      FileAttachment: {
        payload: Prisma.$FileAttachmentPayload<ExtArgs>
        fields: Prisma.FileAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>
          }
          findFirst: {
            args: Prisma.FileAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>
          }
          findMany: {
            args: Prisma.FileAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>[]
          }
          create: {
            args: Prisma.FileAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>
          }
          createMany: {
            args: Prisma.FileAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>[]
          }
          delete: {
            args: Prisma.FileAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>
          }
          update: {
            args: Prisma.FileAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.FileAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAttachmentPayload>
          }
          aggregate: {
            args: Prisma.FileAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileAttachment>
          }
          groupBy: {
            args: Prisma.FileAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<FileAttachmentCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      TeacherSubject: {
        payload: Prisma.$TeacherSubjectPayload<ExtArgs>
        fields: Prisma.TeacherSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findFirst: {
            args: Prisma.TeacherSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          findMany: {
            args: Prisma.TeacherSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          create: {
            args: Prisma.TeacherSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          createMany: {
            args: Prisma.TeacherSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>[]
          }
          delete: {
            args: Prisma.TeacherSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          update: {
            args: Prisma.TeacherSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          deleteMany: {
            args: Prisma.TeacherSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherSubjectPayload>
          }
          aggregate: {
            args: Prisma.TeacherSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherSubject>
          }
          groupBy: {
            args: Prisma.TeacherSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherSubjectCountAggregateOutputType> | number
          }
        }
      }
      TeacherClass: {
        payload: Prisma.$TeacherClassPayload<ExtArgs>
        fields: Prisma.TeacherClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          findFirst: {
            args: Prisma.TeacherClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          findMany: {
            args: Prisma.TeacherClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>[]
          }
          create: {
            args: Prisma.TeacherClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          createMany: {
            args: Prisma.TeacherClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>[]
          }
          delete: {
            args: Prisma.TeacherClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          update: {
            args: Prisma.TeacherClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          deleteMany: {
            args: Prisma.TeacherClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeacherClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherClassPayload>
          }
          aggregate: {
            args: Prisma.TeacherClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherClass>
          }
          groupBy: {
            args: Prisma.TeacherClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherClassCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherClassCountAggregateOutputType> | number
          }
        }
      }
      ClassSubject: {
        payload: Prisma.$ClassSubjectPayload<ExtArgs>
        fields: Prisma.ClassSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          findFirst: {
            args: Prisma.ClassSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          findMany: {
            args: Prisma.ClassSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>[]
          }
          create: {
            args: Prisma.ClassSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          createMany: {
            args: Prisma.ClassSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>[]
          }
          delete: {
            args: Prisma.ClassSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          update: {
            args: Prisma.ClassSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          deleteMany: {
            args: Prisma.ClassSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClassSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassSubjectPayload>
          }
          aggregate: {
            args: Prisma.ClassSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassSubject>
          }
          groupBy: {
            args: Prisma.ClassSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<ClassSubjectCountAggregateOutputType> | number
          }
        }
      }
      AssignmentClass: {
        payload: Prisma.$AssignmentClassPayload<ExtArgs>
        fields: Prisma.AssignmentClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssignmentClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssignmentClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>
          }
          findFirst: {
            args: Prisma.AssignmentClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssignmentClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>
          }
          findMany: {
            args: Prisma.AssignmentClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>[]
          }
          create: {
            args: Prisma.AssignmentClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>
          }
          createMany: {
            args: Prisma.AssignmentClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssignmentClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>[]
          }
          delete: {
            args: Prisma.AssignmentClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>
          }
          update: {
            args: Prisma.AssignmentClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>
          }
          deleteMany: {
            args: Prisma.AssignmentClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssignmentClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AssignmentClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssignmentClassPayload>
          }
          aggregate: {
            args: Prisma.AssignmentClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignmentClass>
          }
          groupBy: {
            args: Prisma.AssignmentClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssignmentClassCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentClassCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sentMessages: number
    receivedMessages: number
    notifications: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    parents: number
    grades: number
    attendanceRecords: number
    assignments: number
    achievements: number
    behaviorRecords: number
    financialRecords: number
    reportCards: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | StudentCountOutputTypeCountParentsArgs
    grades?: boolean | StudentCountOutputTypeCountGradesArgs
    attendanceRecords?: boolean | StudentCountOutputTypeCountAttendanceRecordsArgs
    assignments?: boolean | StudentCountOutputTypeCountAssignmentsArgs
    achievements?: boolean | StudentCountOutputTypeCountAchievementsArgs
    behaviorRecords?: boolean | StudentCountOutputTypeCountBehaviorRecordsArgs
    financialRecords?: boolean | StudentCountOutputTypeCountFinancialRecordsArgs
    reportCards?: boolean | StudentCountOutputTypeCountReportCardsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAchievementWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountBehaviorRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountFinancialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountReportCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
  }


  /**
   * Count Type TeacherCountOutputType
   */

  export type TeacherCountOutputType = {
    subjects: number
    classes: number
    grades: number
    assignments: number
    attendanceRecords: number
    schedules: number
    virtualClasses: number
    resources: number
    behaviorRecords: number
  }

  export type TeacherCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | TeacherCountOutputTypeCountSubjectsArgs
    classes?: boolean | TeacherCountOutputTypeCountClassesArgs
    grades?: boolean | TeacherCountOutputTypeCountGradesArgs
    assignments?: boolean | TeacherCountOutputTypeCountAssignmentsArgs
    attendanceRecords?: boolean | TeacherCountOutputTypeCountAttendanceRecordsArgs
    schedules?: boolean | TeacherCountOutputTypeCountSchedulesArgs
    virtualClasses?: boolean | TeacherCountOutputTypeCountVirtualClassesArgs
    resources?: boolean | TeacherCountOutputTypeCountResourcesArgs
    behaviorRecords?: boolean | TeacherCountOutputTypeCountBehaviorRecordsArgs
  }

  // Custom InputTypes
  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherCountOutputType
     */
    select?: TeacherCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountVirtualClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningResourceWhereInput
  }

  /**
   * TeacherCountOutputType without action
   */
  export type TeacherCountOutputTypeCountBehaviorRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorRecordWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    children: number
    admissionApplications: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ParentCountOutputTypeCountChildrenArgs
    admissionApplications?: boolean | ParentCountOutputTypeCountAdmissionApplicationsArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountAdmissionApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionApplicationWhereInput
  }


  /**
   * Count Type ClassCountOutputType
   */

  export type ClassCountOutputType = {
    students: number
    teachers: number
    subjects: number
    schedules: number
    assignments: number
    attendanceRecords: number
    virtualClasses: number
  }

  export type ClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | ClassCountOutputTypeCountStudentsArgs
    teachers?: boolean | ClassCountOutputTypeCountTeachersArgs
    subjects?: boolean | ClassCountOutputTypeCountSubjectsArgs
    schedules?: boolean | ClassCountOutputTypeCountSchedulesArgs
    assignments?: boolean | ClassCountOutputTypeCountAssignmentsArgs
    attendanceRecords?: boolean | ClassCountOutputTypeCountAttendanceRecordsArgs
    virtualClasses?: boolean | ClassCountOutputTypeCountVirtualClassesArgs
  }

  // Custom InputTypes
  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassCountOutputType
     */
    select?: ClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentClassWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountAttendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
  }

  /**
   * ClassCountOutputType without action
   */
  export type ClassCountOutputTypeCountVirtualClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassParticipantWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    teachers: number
    classes: number
    grades: number
    assignments: number
    schedules: number
    resources: number
    virtualClasses: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | SubjectCountOutputTypeCountTeachersArgs
    classes?: boolean | SubjectCountOutputTypeCountClassesArgs
    grades?: boolean | SubjectCountOutputTypeCountGradesArgs
    assignments?: boolean | SubjectCountOutputTypeCountAssignmentsArgs
    schedules?: boolean | SubjectCountOutputTypeCountSchedulesArgs
    resources?: boolean | SubjectCountOutputTypeCountResourcesArgs
    virtualClasses?: boolean | SubjectCountOutputTypeCountVirtualClassesArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountResourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningResourceWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountVirtualClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassWhereInput
  }


  /**
   * Count Type AssignmentCountOutputType
   */

  export type AssignmentCountOutputType = {
    classes: number
    submissions: number
    attachments: number
  }

  export type AssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | AssignmentCountOutputTypeCountClassesArgs
    submissions?: boolean | AssignmentCountOutputTypeCountSubmissionsArgs
    attachments?: boolean | AssignmentCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentCountOutputType
     */
    select?: AssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentClassWhereInput
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * AssignmentCountOutputType without action
   */
  export type AssignmentCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAttachmentWhereInput
  }


  /**
   * Count Type AssignmentSubmissionCountOutputType
   */

  export type AssignmentSubmissionCountOutputType = {
    attachments: number
  }

  export type AssignmentSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | AssignmentSubmissionCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * AssignmentSubmissionCountOutputType without action
   */
  export type AssignmentSubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmissionCountOutputType
     */
    select?: AssignmentSubmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssignmentSubmissionCountOutputType without action
   */
  export type AssignmentSubmissionCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAttachmentWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    recipients: number
    replies: number
    attachments: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | MessageCountOutputTypeCountRecipientsArgs
    replies?: boolean | MessageCountOutputTypeCountRepliesArgs
    attachments?: boolean | MessageCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAttachmentWhereInput
  }


  /**
   * Count Type AdmissionApplicationCountOutputType
   */

  export type AdmissionApplicationCountOutputType = {
    documents: number
    stepProgress: number
  }

  export type AdmissionApplicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | AdmissionApplicationCountOutputTypeCountDocumentsArgs
    stepProgress?: boolean | AdmissionApplicationCountOutputTypeCountStepProgressArgs
  }

  // Custom InputTypes
  /**
   * AdmissionApplicationCountOutputType without action
   */
  export type AdmissionApplicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplicationCountOutputType
     */
    select?: AdmissionApplicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdmissionApplicationCountOutputType without action
   */
  export type AdmissionApplicationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAttachmentWhereInput
  }

  /**
   * AdmissionApplicationCountOutputType without action
   */
  export type AdmissionApplicationCountOutputTypeCountStepProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionStepProgressWhereInput
  }


  /**
   * Count Type VirtualClassCountOutputType
   */

  export type VirtualClassCountOutputType = {
    classes: number
  }

  export type VirtualClassCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | VirtualClassCountOutputTypeCountClassesArgs
  }

  // Custom InputTypes
  /**
   * VirtualClassCountOutputType without action
   */
  export type VirtualClassCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassCountOutputType
     */
    select?: VirtualClassCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VirtualClassCountOutputType without action
   */
  export type VirtualClassCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassParticipantWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    students: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | AchievementCountOutputTypeCountStudentsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAchievementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    avatar: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    avatar: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    avatar: number
    phone: number
    address: number
    dateOfBirth: number
    role: number
    isActive: number
    lastLoginAt: number
    emailVerifiedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    avatar?: true
    phone?: true
    address?: true
    dateOfBirth?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    emailVerifiedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    avatar: string | null
    phone: string | null
    address: string | null
    dateOfBirth: Date | null
    role: $Enums.UserRole
    isActive: boolean
    lastLoginAt: Date | null
    emailVerifiedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    avatar?: boolean
    phone?: boolean
    address?: boolean
    dateOfBirth?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    emailVerifiedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | User$studentArgs<ExtArgs>
    teacher?: boolean | User$teacherArgs<ExtArgs>
    parent?: boolean | User$parentArgs<ExtArgs>
    admin?: boolean | User$adminArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs> | null
      parent: Prisma.$ParentPayload<ExtArgs> | null
      admin: Prisma.$AdminPayload<ExtArgs> | null
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      avatar: string | null
      phone: string | null
      address: string | null
      dateOfBirth: Date | null
      role: $Enums.UserRole
      isActive: boolean
      lastLoginAt: Date | null
      emailVerifiedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teacher<T extends User$teacherArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parent<T extends User$parentArgs<ExtArgs> = {}>(args?: Subset<T, User$parentArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    admin<T extends User$adminArgs<ExtArgs> = {}>(args?: Subset<T, User$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.teacher
   */
  export type User$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    where?: TeacherWhereInput
  }

  /**
   * User.parent
   */
  export type User$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * User.admin
   */
  export type User$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    userId: string | null
    classId: string | null
    admissionDate: Date | null
    academicYear: string | null
    emergencyMedicalContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    userId: string | null
    classId: string | null
    admissionDate: Date | null
    academicYear: string | null
    emergencyMedicalContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    studentId: number
    userId: number
    classId: number
    parentIds: number
    admissionDate: number
    academicYear: number
    allergies: number
    medications: number
    emergencyMedicalContact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    classId?: true
    admissionDate?: true
    academicYear?: true
    emergencyMedicalContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    classId?: true
    admissionDate?: true
    academicYear?: true
    emergencyMedicalContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    studentId?: true
    userId?: true
    classId?: true
    parentIds?: true
    admissionDate?: true
    academicYear?: true
    allergies?: true
    medications?: true
    emergencyMedicalContact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    studentId: string
    userId: string
    classId: string | null
    parentIds: string[]
    admissionDate: Date
    academicYear: string
    allergies: string[]
    medications: string[]
    emergencyMedicalContact: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    userId?: boolean
    classId?: boolean
    parentIds?: boolean
    admissionDate?: boolean
    academicYear?: boolean
    allergies?: boolean
    medications?: boolean
    emergencyMedicalContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    grades?: boolean | Student$gradesArgs<ExtArgs>
    attendanceRecords?: boolean | Student$attendanceRecordsArgs<ExtArgs>
    assignments?: boolean | Student$assignmentsArgs<ExtArgs>
    achievements?: boolean | Student$achievementsArgs<ExtArgs>
    behaviorRecords?: boolean | Student$behaviorRecordsArgs<ExtArgs>
    financialRecords?: boolean | Student$financialRecordsArgs<ExtArgs>
    reportCards?: boolean | Student$reportCardsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    userId?: boolean
    classId?: boolean
    parentIds?: boolean
    admissionDate?: boolean
    academicYear?: boolean
    allergies?: boolean
    medications?: boolean
    emergencyMedicalContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    studentId?: boolean
    userId?: boolean
    classId?: boolean
    parentIds?: boolean
    admissionDate?: boolean
    academicYear?: boolean
    allergies?: boolean
    medications?: boolean
    emergencyMedicalContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    grades?: boolean | Student$gradesArgs<ExtArgs>
    attendanceRecords?: boolean | Student$attendanceRecordsArgs<ExtArgs>
    assignments?: boolean | Student$assignmentsArgs<ExtArgs>
    achievements?: boolean | Student$achievementsArgs<ExtArgs>
    behaviorRecords?: boolean | Student$behaviorRecordsArgs<ExtArgs>
    financialRecords?: boolean | Student$financialRecordsArgs<ExtArgs>
    reportCards?: boolean | Student$reportCardsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    class?: boolean | Student$classArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs> | null
      parents: Prisma.$ParentPayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      assignments: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      achievements: Prisma.$StudentAchievementPayload<ExtArgs>[]
      behaviorRecords: Prisma.$BehaviorRecordPayload<ExtArgs>[]
      financialRecords: Prisma.$FinancialRecordPayload<ExtArgs>[]
      reportCards: Prisma.$ReportCardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      userId: string
      classId: string | null
      parentIds: string[]
      admissionDate: Date
      academicYear: string
      allergies: string[]
      medications: string[]
      emergencyMedicalContact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends Student$classArgs<ExtArgs> = {}>(args?: Subset<T, Student$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    parents<T extends Student$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany"> | Null>
    grades<T extends Student$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Student$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany"> | Null>
    attendanceRecords<T extends Student$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends Student$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends Student$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, Student$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    behaviorRecords<T extends Student$behaviorRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$behaviorRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findMany"> | Null>
    financialRecords<T extends Student$financialRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Student$financialRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany"> | Null>
    reportCards<T extends Student$reportCardsArgs<ExtArgs> = {}>(args?: Subset<T, Student$reportCardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly studentId: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly classId: FieldRef<"Student", 'String'>
    readonly parentIds: FieldRef<"Student", 'String[]'>
    readonly admissionDate: FieldRef<"Student", 'DateTime'>
    readonly academicYear: FieldRef<"Student", 'String'>
    readonly allergies: FieldRef<"Student", 'String[]'>
    readonly medications: FieldRef<"Student", 'String[]'>
    readonly emergencyMedicalContact: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.class
   */
  export type Student$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * Student.parents
   */
  export type Student$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    cursor?: ParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Student.grades
   */
  export type Student$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Student.attendanceRecords
   */
  export type Student$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Student.assignments
   */
  export type Student$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * Student.achievements
   */
  export type Student$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    where?: StudentAchievementWhereInput
    orderBy?: StudentAchievementOrderByWithRelationInput | StudentAchievementOrderByWithRelationInput[]
    cursor?: StudentAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAchievementScalarFieldEnum | StudentAchievementScalarFieldEnum[]
  }

  /**
   * Student.behaviorRecords
   */
  export type Student$behaviorRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    where?: BehaviorRecordWhereInput
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    cursor?: BehaviorRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * Student.financialRecords
   */
  export type Student$financialRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    cursor?: FinancialRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * Student.reportCards
   */
  export type Student$reportCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    cursor?: ReportCardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Teacher
   */

  export type AggregateTeacher = {
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  export type TeacherMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    userId: string | null
    department: string | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    userId: string | null
    department: string | null
    hireDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeacherCountAggregateOutputType = {
    id: number
    employeeId: number
    userId: number
    department: number
    qualifications: number
    hireDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeacherMinAggregateInputType = {
    id?: true
    employeeId?: true
    userId?: true
    department?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherMaxAggregateInputType = {
    id?: true
    employeeId?: true
    userId?: true
    department?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeacherCountAggregateInputType = {
    id?: true
    employeeId?: true
    userId?: true
    department?: true
    qualifications?: true
    hireDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeacherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teacher to aggregate.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teachers
    **/
    _count?: true | TeacherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherMaxAggregateInputType
  }

  export type GetTeacherAggregateType<T extends TeacherAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher[P]>
      : GetScalarType<T[P], AggregateTeacher[P]>
  }




  export type TeacherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherWhereInput
    orderBy?: TeacherOrderByWithAggregationInput | TeacherOrderByWithAggregationInput[]
    by: TeacherScalarFieldEnum[] | TeacherScalarFieldEnum
    having?: TeacherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherCountAggregateInputType | true
    _min?: TeacherMinAggregateInputType
    _max?: TeacherMaxAggregateInputType
  }

  export type TeacherGroupByOutputType = {
    id: string
    employeeId: string
    userId: string
    department: string
    qualifications: string[]
    hireDate: Date
    createdAt: Date
    updatedAt: Date
    _count: TeacherCountAggregateOutputType | null
    _min: TeacherMinAggregateOutputType | null
    _max: TeacherMaxAggregateOutputType | null
  }

  type GetTeacherGroupByPayload<T extends TeacherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    userId?: boolean
    department?: boolean
    qualifications?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    subjects?: boolean | Teacher$subjectsArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    grades?: boolean | Teacher$gradesArgs<ExtArgs>
    assignments?: boolean | Teacher$assignmentsArgs<ExtArgs>
    attendanceRecords?: boolean | Teacher$attendanceRecordsArgs<ExtArgs>
    schedules?: boolean | Teacher$schedulesArgs<ExtArgs>
    virtualClasses?: boolean | Teacher$virtualClassesArgs<ExtArgs>
    resources?: boolean | Teacher$resourcesArgs<ExtArgs>
    behaviorRecords?: boolean | Teacher$behaviorRecordsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    userId?: boolean
    department?: boolean
    qualifications?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher"]>

  export type TeacherSelectScalar = {
    id?: boolean
    employeeId?: boolean
    userId?: boolean
    department?: boolean
    qualifications?: boolean
    hireDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeacherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    subjects?: boolean | Teacher$subjectsArgs<ExtArgs>
    classes?: boolean | Teacher$classesArgs<ExtArgs>
    grades?: boolean | Teacher$gradesArgs<ExtArgs>
    assignments?: boolean | Teacher$assignmentsArgs<ExtArgs>
    attendanceRecords?: boolean | Teacher$attendanceRecordsArgs<ExtArgs>
    schedules?: boolean | Teacher$schedulesArgs<ExtArgs>
    virtualClasses?: boolean | Teacher$virtualClassesArgs<ExtArgs>
    resources?: boolean | Teacher$resourcesArgs<ExtArgs>
    behaviorRecords?: boolean | Teacher$behaviorRecordsArgs<ExtArgs>
    _count?: boolean | TeacherCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Teacher"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      subjects: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      classes: Prisma.$TeacherClassPayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      virtualClasses: Prisma.$VirtualClassPayload<ExtArgs>[]
      resources: Prisma.$LearningResourcePayload<ExtArgs>[]
      behaviorRecords: Prisma.$BehaviorRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      userId: string
      department: string
      qualifications: string[]
      hireDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teacher"]>
    composites: {}
  }

  type TeacherGetPayload<S extends boolean | null | undefined | TeacherDefaultArgs> = $Result.GetResult<Prisma.$TeacherPayload, S>

  type TeacherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherCountAggregateInputType | true
    }

  export interface TeacherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Teacher'], meta: { name: 'Teacher' } }
    /**
     * Find zero or one Teacher that matches the filter.
     * @param {TeacherFindUniqueArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherFindUniqueArgs>(args: SelectSubset<T, TeacherFindUniqueArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Teacher that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherFindUniqueOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Teacher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherFindFirstArgs>(args?: SelectSubset<T, TeacherFindFirstArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Teacher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindFirstOrThrowArgs} args - Arguments to find a Teacher
     * @example
     * // Get one Teacher
     * const teacher = await prisma.teacher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teacher.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teacher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherWithIdOnly = await prisma.teacher.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherFindManyArgs>(args?: SelectSubset<T, TeacherFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Teacher.
     * @param {TeacherCreateArgs} args - Arguments to create a Teacher.
     * @example
     * // Create one Teacher
     * const Teacher = await prisma.teacher.create({
     *   data: {
     *     // ... data to create a Teacher
     *   }
     * })
     * 
     */
    create<T extends TeacherCreateArgs>(args: SelectSubset<T, TeacherCreateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teachers.
     * @param {TeacherCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherCreateManyArgs>(args?: SelectSubset<T, TeacherCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {TeacherCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teacher = await prisma.teacher.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teacherWithIdOnly = await prisma.teacher.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Teacher.
     * @param {TeacherDeleteArgs} args - Arguments to delete one Teacher.
     * @example
     * // Delete one Teacher
     * const Teacher = await prisma.teacher.delete({
     *   where: {
     *     // ... filter to delete one Teacher
     *   }
     * })
     * 
     */
    delete<T extends TeacherDeleteArgs>(args: SelectSubset<T, TeacherDeleteArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Teacher.
     * @param {TeacherUpdateArgs} args - Arguments to update one Teacher.
     * @example
     * // Update one Teacher
     * const teacher = await prisma.teacher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherUpdateArgs>(args: SelectSubset<T, TeacherUpdateArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teachers.
     * @param {TeacherDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teacher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherDeleteManyArgs>(args?: SelectSubset<T, TeacherDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teacher = await prisma.teacher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherUpdateManyArgs>(args: SelectSubset<T, TeacherUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Teacher.
     * @param {TeacherUpsertArgs} args - Arguments to update or create a Teacher.
     * @example
     * // Update or create a Teacher
     * const teacher = await prisma.teacher.upsert({
     *   create: {
     *     // ... data to create a Teacher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher we want to update
     *   }
     * })
     */
    upsert<T extends TeacherUpsertArgs>(args: SelectSubset<T, TeacherUpsertArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teacher.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends TeacherCountArgs>(
      args?: Subset<T, TeacherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherAggregateArgs>(args: Subset<T, TeacherAggregateArgs>): Prisma.PrismaPromise<GetTeacherAggregateType<T>>

    /**
     * Group by Teacher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherGroupByArgs['orderBy'] }
        : { orderBy?: TeacherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Teacher model
   */
  readonly fields: TeacherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Teacher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subjects<T extends Teacher$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends Teacher$classesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findMany"> | Null>
    grades<T extends Teacher$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends Teacher$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    attendanceRecords<T extends Teacher$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Teacher$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    virtualClasses<T extends Teacher$virtualClassesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$virtualClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findMany"> | Null>
    resources<T extends Teacher$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "findMany"> | Null>
    behaviorRecords<T extends Teacher$behaviorRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Teacher$behaviorRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Teacher model
   */ 
  interface TeacherFieldRefs {
    readonly id: FieldRef<"Teacher", 'String'>
    readonly employeeId: FieldRef<"Teacher", 'String'>
    readonly userId: FieldRef<"Teacher", 'String'>
    readonly department: FieldRef<"Teacher", 'String'>
    readonly qualifications: FieldRef<"Teacher", 'String[]'>
    readonly hireDate: FieldRef<"Teacher", 'DateTime'>
    readonly createdAt: FieldRef<"Teacher", 'DateTime'>
    readonly updatedAt: FieldRef<"Teacher", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Teacher findUnique
   */
  export type TeacherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findUniqueOrThrow
   */
  export type TeacherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher findFirst
   */
  export type TeacherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findFirstOrThrow
   */
  export type TeacherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teacher to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teachers.
     */
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher findMany
   */
  export type TeacherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter, which Teachers to fetch.
     */
    where?: TeacherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teachers to fetch.
     */
    orderBy?: TeacherOrderByWithRelationInput | TeacherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teachers.
     */
    cursor?: TeacherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teachers.
     */
    skip?: number
    distinct?: TeacherScalarFieldEnum | TeacherScalarFieldEnum[]
  }

  /**
   * Teacher create
   */
  export type TeacherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to create a Teacher.
     */
    data: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
  }

  /**
   * Teacher createMany
   */
  export type TeacherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Teacher createManyAndReturn
   */
  export type TeacherCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teachers.
     */
    data: TeacherCreateManyInput | TeacherCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Teacher update
   */
  export type TeacherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The data needed to update a Teacher.
     */
    data: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
    /**
     * Choose, which Teacher to update.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher updateMany
   */
  export type TeacherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teachers.
     */
    data: XOR<TeacherUpdateManyMutationInput, TeacherUncheckedUpdateManyInput>
    /**
     * Filter which Teachers to update
     */
    where?: TeacherWhereInput
  }

  /**
   * Teacher upsert
   */
  export type TeacherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * The filter to search for the Teacher to update in case it exists.
     */
    where: TeacherWhereUniqueInput
    /**
     * In case the Teacher found by the `where` argument doesn't exist, create a new Teacher with this data.
     */
    create: XOR<TeacherCreateInput, TeacherUncheckedCreateInput>
    /**
     * In case the Teacher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherUpdateInput, TeacherUncheckedUpdateInput>
  }

  /**
   * Teacher delete
   */
  export type TeacherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
    /**
     * Filter which Teacher to delete.
     */
    where: TeacherWhereUniqueInput
  }

  /**
   * Teacher deleteMany
   */
  export type TeacherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teachers to delete
     */
    where?: TeacherWhereInput
  }

  /**
   * Teacher.subjects
   */
  export type Teacher$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * Teacher.classes
   */
  export type Teacher$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    where?: TeacherClassWhereInput
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    cursor?: TeacherClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * Teacher.grades
   */
  export type Teacher$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Teacher.assignments
   */
  export type Teacher$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Teacher.attendanceRecords
   */
  export type Teacher$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Teacher.schedules
   */
  export type Teacher$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Teacher.virtualClasses
   */
  export type Teacher$virtualClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    where?: VirtualClassWhereInput
    orderBy?: VirtualClassOrderByWithRelationInput | VirtualClassOrderByWithRelationInput[]
    cursor?: VirtualClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualClassScalarFieldEnum | VirtualClassScalarFieldEnum[]
  }

  /**
   * Teacher.resources
   */
  export type Teacher$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    where?: LearningResourceWhereInput
    orderBy?: LearningResourceOrderByWithRelationInput | LearningResourceOrderByWithRelationInput[]
    cursor?: LearningResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningResourceScalarFieldEnum | LearningResourceScalarFieldEnum[]
  }

  /**
   * Teacher.behaviorRecords
   */
  export type Teacher$behaviorRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    where?: BehaviorRecordWhereInput
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    cursor?: BehaviorRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * Teacher without action
   */
  export type TeacherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Teacher
     */
    select?: TeacherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    preferredContactMethod: $Enums.ContactMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    preferredContactMethod: $Enums.ContactMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    userId: number
    occupation: number
    preferredContactMethod: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    preferredContactMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    preferredContactMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    preferredContactMethod?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    userId: string
    occupation: string | null
    preferredContactMethod: $Enums.ContactMethod
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    occupation?: boolean
    preferredContactMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    admissionApplications?: boolean | Parent$admissionApplicationsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    occupation?: boolean
    preferredContactMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectScalar = {
    id?: boolean
    userId?: boolean
    occupation?: boolean
    preferredContactMethod?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    admissionApplications?: boolean | Parent$admissionApplicationsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      children: Prisma.$StudentPayload<ExtArgs>[]
      admissionApplications: Prisma.$AdmissionApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      occupation: string | null
      preferredContactMethod: $Enums.ContactMethod
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    children<T extends Parent$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Parent$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    admissionApplications<T extends Parent$admissionApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Parent$admissionApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */ 
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly userId: FieldRef<"Parent", 'String'>
    readonly occupation: FieldRef<"Parent", 'String'>
    readonly preferredContactMethod: FieldRef<"Parent", 'ContactMethod'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent createManyAndReturn
   */
  export type ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
  }

  /**
   * Parent.children
   */
  export type Parent$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Parent.admissionApplications
   */
  export type Parent$admissionApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    where?: AdmissionApplicationWhereInput
    orderBy?: AdmissionApplicationOrderByWithRelationInput | AdmissionApplicationOrderByWithRelationInput[]
    cursor?: AdmissionApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionApplicationScalarFieldEnum | AdmissionApplicationScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permissions: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly permissions: FieldRef<"Admin", 'String[]'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model Class
   */

  export type AggregateClass = {
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  export type ClassAvgAggregateOutputType = {
    maxStudents: number | null
  }

  export type ClassSumAggregateOutputType = {
    maxStudents: number | null
  }

  export type ClassMinAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    academicYear: string | null
    room: string | null
    maxStudents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassMaxAggregateOutputType = {
    id: string | null
    name: string | null
    level: string | null
    academicYear: string | null
    room: string | null
    maxStudents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClassCountAggregateOutputType = {
    id: number
    name: number
    level: number
    academicYear: number
    room: number
    maxStudents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClassAvgAggregateInputType = {
    maxStudents?: true
  }

  export type ClassSumAggregateInputType = {
    maxStudents?: true
  }

  export type ClassMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    academicYear?: true
    room?: true
    maxStudents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    academicYear?: true
    room?: true
    maxStudents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClassCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    academicYear?: true
    room?: true
    maxStudents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Class to aggregate.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classes
    **/
    _count?: true | ClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassMaxAggregateInputType
  }

  export type GetClassAggregateType<T extends ClassAggregateArgs> = {
        [P in keyof T & keyof AggregateClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass[P]>
      : GetScalarType<T[P], AggregateClass[P]>
  }




  export type ClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassWhereInput
    orderBy?: ClassOrderByWithAggregationInput | ClassOrderByWithAggregationInput[]
    by: ClassScalarFieldEnum[] | ClassScalarFieldEnum
    having?: ClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassCountAggregateInputType | true
    _avg?: ClassAvgAggregateInputType
    _sum?: ClassSumAggregateInputType
    _min?: ClassMinAggregateInputType
    _max?: ClassMaxAggregateInputType
  }

  export type ClassGroupByOutputType = {
    id: string
    name: string
    level: string
    academicYear: string
    room: string | null
    maxStudents: number
    createdAt: Date
    updatedAt: Date
    _count: ClassCountAggregateOutputType | null
    _avg: ClassAvgAggregateOutputType | null
    _sum: ClassSumAggregateOutputType | null
    _min: ClassMinAggregateOutputType | null
    _max: ClassMaxAggregateOutputType | null
  }

  type GetClassGroupByPayload<T extends ClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassGroupByOutputType[P]>
            : GetScalarType<T[P], ClassGroupByOutputType[P]>
        }
      >
    >


  export type ClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    academicYear?: boolean
    room?: boolean
    maxStudents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    students?: boolean | Class$studentsArgs<ExtArgs>
    teachers?: boolean | Class$teachersArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    schedules?: boolean | Class$schedulesArgs<ExtArgs>
    assignments?: boolean | Class$assignmentsArgs<ExtArgs>
    attendanceRecords?: boolean | Class$attendanceRecordsArgs<ExtArgs>
    virtualClasses?: boolean | Class$virtualClassesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class"]>

  export type ClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    academicYear?: boolean
    room?: boolean
    maxStudents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["class"]>

  export type ClassSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    academicYear?: boolean
    room?: boolean
    maxStudents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | Class$studentsArgs<ExtArgs>
    teachers?: boolean | Class$teachersArgs<ExtArgs>
    subjects?: boolean | Class$subjectsArgs<ExtArgs>
    schedules?: boolean | Class$schedulesArgs<ExtArgs>
    assignments?: boolean | Class$assignmentsArgs<ExtArgs>
    attendanceRecords?: boolean | Class$attendanceRecordsArgs<ExtArgs>
    virtualClasses?: boolean | Class$virtualClassesArgs<ExtArgs>
    _count?: boolean | ClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Class"
    objects: {
      students: Prisma.$StudentPayload<ExtArgs>[]
      teachers: Prisma.$TeacherClassPayload<ExtArgs>[]
      subjects: Prisma.$ClassSubjectPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      assignments: Prisma.$AssignmentClassPayload<ExtArgs>[]
      attendanceRecords: Prisma.$AttendanceRecordPayload<ExtArgs>[]
      virtualClasses: Prisma.$VirtualClassParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      level: string
      academicYear: string
      room: string | null
      maxStudents: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["class"]>
    composites: {}
  }

  type ClassGetPayload<S extends boolean | null | undefined | ClassDefaultArgs> = $Result.GetResult<Prisma.$ClassPayload, S>

  type ClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassCountAggregateInputType | true
    }

  export interface ClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Class'], meta: { name: 'Class' } }
    /**
     * Find zero or one Class that matches the filter.
     * @param {ClassFindUniqueArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassFindUniqueArgs>(args: SelectSubset<T, ClassFindUniqueArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Class that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassFindUniqueOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Class that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassFindFirstArgs>(args?: SelectSubset<T, ClassFindFirstArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Class that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindFirstOrThrowArgs} args - Arguments to find a Class
     * @example
     * // Get one Class
     * const class = await prisma.class.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Classes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classes
     * const classes = await prisma.class.findMany()
     * 
     * // Get first 10 Classes
     * const classes = await prisma.class.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classWithIdOnly = await prisma.class.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassFindManyArgs>(args?: SelectSubset<T, ClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Class.
     * @param {ClassCreateArgs} args - Arguments to create a Class.
     * @example
     * // Create one Class
     * const Class = await prisma.class.create({
     *   data: {
     *     // ... data to create a Class
     *   }
     * })
     * 
     */
    create<T extends ClassCreateArgs>(args: SelectSubset<T, ClassCreateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Classes.
     * @param {ClassCreateManyArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassCreateManyArgs>(args?: SelectSubset<T, ClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classes and returns the data saved in the database.
     * @param {ClassCreateManyAndReturnArgs} args - Arguments to create many Classes.
     * @example
     * // Create many Classes
     * const class = await prisma.class.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classes and only return the `id`
     * const classWithIdOnly = await prisma.class.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Class.
     * @param {ClassDeleteArgs} args - Arguments to delete one Class.
     * @example
     * // Delete one Class
     * const Class = await prisma.class.delete({
     *   where: {
     *     // ... filter to delete one Class
     *   }
     * })
     * 
     */
    delete<T extends ClassDeleteArgs>(args: SelectSubset<T, ClassDeleteArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Class.
     * @param {ClassUpdateArgs} args - Arguments to update one Class.
     * @example
     * // Update one Class
     * const class = await prisma.class.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassUpdateArgs>(args: SelectSubset<T, ClassUpdateArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Classes.
     * @param {ClassDeleteManyArgs} args - Arguments to filter Classes to delete.
     * @example
     * // Delete a few Classes
     * const { count } = await prisma.class.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassDeleteManyArgs>(args?: SelectSubset<T, ClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classes
     * const class = await prisma.class.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassUpdateManyArgs>(args: SelectSubset<T, ClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Class.
     * @param {ClassUpsertArgs} args - Arguments to update or create a Class.
     * @example
     * // Update or create a Class
     * const class = await prisma.class.upsert({
     *   create: {
     *     // ... data to create a Class
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class we want to update
     *   }
     * })
     */
    upsert<T extends ClassUpsertArgs>(args: SelectSubset<T, ClassUpsertArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Classes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassCountArgs} args - Arguments to filter Classes to count.
     * @example
     * // Count the number of Classes
     * const count = await prisma.class.count({
     *   where: {
     *     // ... the filter for the Classes we want to count
     *   }
     * })
    **/
    count<T extends ClassCountArgs>(
      args?: Subset<T, ClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassAggregateArgs>(args: Subset<T, ClassAggregateArgs>): Prisma.PrismaPromise<GetClassAggregateType<T>>

    /**
     * Group by Class.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassGroupByArgs['orderBy'] }
        : { orderBy?: ClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Class model
   */
  readonly fields: ClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Class.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends Class$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    teachers<T extends Class$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Class$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findMany"> | Null>
    subjects<T extends Class$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Class$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Class$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Class$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends Class$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Class$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "findMany"> | Null>
    attendanceRecords<T extends Class$attendanceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Class$attendanceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany"> | Null>
    virtualClasses<T extends Class$virtualClassesArgs<ExtArgs> = {}>(args?: Subset<T, Class$virtualClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Class model
   */ 
  interface ClassFieldRefs {
    readonly id: FieldRef<"Class", 'String'>
    readonly name: FieldRef<"Class", 'String'>
    readonly level: FieldRef<"Class", 'String'>
    readonly academicYear: FieldRef<"Class", 'String'>
    readonly room: FieldRef<"Class", 'String'>
    readonly maxStudents: FieldRef<"Class", 'Int'>
    readonly createdAt: FieldRef<"Class", 'DateTime'>
    readonly updatedAt: FieldRef<"Class", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Class findUnique
   */
  export type ClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findUniqueOrThrow
   */
  export type ClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class findFirst
   */
  export type ClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findFirstOrThrow
   */
  export type ClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Class to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classes.
     */
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class findMany
   */
  export type ClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter, which Classes to fetch.
     */
    where?: ClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classes to fetch.
     */
    orderBy?: ClassOrderByWithRelationInput | ClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classes.
     */
    cursor?: ClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Classes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classes.
     */
    skip?: number
    distinct?: ClassScalarFieldEnum | ClassScalarFieldEnum[]
  }

  /**
   * Class create
   */
  export type ClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to create a Class.
     */
    data: XOR<ClassCreateInput, ClassUncheckedCreateInput>
  }

  /**
   * Class createMany
   */
  export type ClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class createManyAndReturn
   */
  export type ClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Classes.
     */
    data: ClassCreateManyInput | ClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Class update
   */
  export type ClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The data needed to update a Class.
     */
    data: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
    /**
     * Choose, which Class to update.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class updateMany
   */
  export type ClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classes.
     */
    data: XOR<ClassUpdateManyMutationInput, ClassUncheckedUpdateManyInput>
    /**
     * Filter which Classes to update
     */
    where?: ClassWhereInput
  }

  /**
   * Class upsert
   */
  export type ClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * The filter to search for the Class to update in case it exists.
     */
    where: ClassWhereUniqueInput
    /**
     * In case the Class found by the `where` argument doesn't exist, create a new Class with this data.
     */
    create: XOR<ClassCreateInput, ClassUncheckedCreateInput>
    /**
     * In case the Class was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassUpdateInput, ClassUncheckedUpdateInput>
  }

  /**
   * Class delete
   */
  export type ClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    /**
     * Filter which Class to delete.
     */
    where: ClassWhereUniqueInput
  }

  /**
   * Class deleteMany
   */
  export type ClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classes to delete
     */
    where?: ClassWhereInput
  }

  /**
   * Class.students
   */
  export type Class$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Class.teachers
   */
  export type Class$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    where?: TeacherClassWhereInput
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    cursor?: TeacherClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * Class.subjects
   */
  export type Class$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    cursor?: ClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * Class.schedules
   */
  export type Class$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Class.assignments
   */
  export type Class$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    where?: AssignmentClassWhereInput
    orderBy?: AssignmentClassOrderByWithRelationInput | AssignmentClassOrderByWithRelationInput[]
    cursor?: AssignmentClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentClassScalarFieldEnum | AssignmentClassScalarFieldEnum[]
  }

  /**
   * Class.attendanceRecords
   */
  export type Class$attendanceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    cursor?: AttendanceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * Class.virtualClasses
   */
  export type Class$virtualClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    where?: VirtualClassParticipantWhereInput
    orderBy?: VirtualClassParticipantOrderByWithRelationInput | VirtualClassParticipantOrderByWithRelationInput[]
    cursor?: VirtualClassParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualClassParticipantScalarFieldEnum | VirtualClassParticipantScalarFieldEnum[]
  }

  /**
   * Class without action
   */
  export type ClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    credits: number | null
  }

  export type SubjectSumAggregateOutputType = {
    credits: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    department: string | null
    credits: number | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    description: string | null
    department: string | null
    credits: number | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    code: number
    description: number
    department: number
    credits: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    credits?: true
  }

  export type SubjectSumAggregateInputType = {
    credits?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    department?: true
    credits?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    department?: true
    credits?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    description?: true
    department?: true
    credits?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    code: string
    description: string | null
    department: string
    credits: number
    color: string
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    department?: boolean
    credits?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teachers?: boolean | Subject$teachersArgs<ExtArgs>
    classes?: boolean | Subject$classesArgs<ExtArgs>
    grades?: boolean | Subject$gradesArgs<ExtArgs>
    assignments?: boolean | Subject$assignmentsArgs<ExtArgs>
    schedules?: boolean | Subject$schedulesArgs<ExtArgs>
    resources?: boolean | Subject$resourcesArgs<ExtArgs>
    virtualClasses?: boolean | Subject$virtualClassesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    department?: boolean
    credits?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    department?: boolean
    credits?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | Subject$teachersArgs<ExtArgs>
    classes?: boolean | Subject$classesArgs<ExtArgs>
    grades?: boolean | Subject$gradesArgs<ExtArgs>
    assignments?: boolean | Subject$assignmentsArgs<ExtArgs>
    schedules?: boolean | Subject$schedulesArgs<ExtArgs>
    resources?: boolean | Subject$resourcesArgs<ExtArgs>
    virtualClasses?: boolean | Subject$virtualClassesArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      teachers: Prisma.$TeacherSubjectPayload<ExtArgs>[]
      classes: Prisma.$ClassSubjectPayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
      assignments: Prisma.$AssignmentPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      resources: Prisma.$LearningResourcePayload<ExtArgs>[]
      virtualClasses: Prisma.$VirtualClassPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      description: string | null
      department: string
      credits: number
      color: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teachers<T extends Subject$teachersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    classes<T extends Subject$classesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany"> | Null>
    grades<T extends Subject$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends Subject$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Subject$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    resources<T extends Subject$resourcesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$resourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "findMany"> | Null>
    virtualClasses<T extends Subject$virtualClassesArgs<ExtArgs> = {}>(args?: Subset<T, Subject$virtualClassesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */ 
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly code: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly department: FieldRef<"Subject", 'String'>
    readonly credits: FieldRef<"Subject", 'Int'>
    readonly color: FieldRef<"Subject", 'String'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
  }

  /**
   * Subject.teachers
   */
  export type Subject$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    cursor?: TeacherSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * Subject.classes
   */
  export type Subject$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    cursor?: ClassSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * Subject.grades
   */
  export type Subject$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Subject.assignments
   */
  export type Subject$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    cursor?: AssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Subject.schedules
   */
  export type Subject$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Subject.resources
   */
  export type Subject$resourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    where?: LearningResourceWhereInput
    orderBy?: LearningResourceOrderByWithRelationInput | LearningResourceOrderByWithRelationInput[]
    cursor?: LearningResourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningResourceScalarFieldEnum | LearningResourceScalarFieldEnum[]
  }

  /**
   * Subject.virtualClasses
   */
  export type Subject$virtualClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    where?: VirtualClassWhereInput
    orderBy?: VirtualClassOrderByWithRelationInput | VirtualClassOrderByWithRelationInput[]
    cursor?: VirtualClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualClassScalarFieldEnum | VirtualClassScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    value: number | null
    maxValue: number | null
  }

  export type GradeSumAggregateOutputType = {
    value: number | null
    maxValue: number | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    teacherId: string | null
    value: number | null
    maxValue: number | null
    type: $Enums.GradeType | null
    comment: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    subjectId: string | null
    teacherId: string | null
    value: number | null
    maxValue: number | null
    type: $Enums.GradeType | null
    comment: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    studentId: number
    subjectId: number
    teacherId: number
    value: number
    maxValue: number
    type: number
    comment: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    value?: true
    maxValue?: true
  }

  export type GradeSumAggregateInputType = {
    value?: true
    maxValue?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    teacherId?: true
    value?: true
    maxValue?: true
    type?: true
    comment?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    teacherId?: true
    value?: true
    maxValue?: true
    type?: true
    comment?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    studentId?: true
    subjectId?: true
    teacherId?: true
    value?: true
    maxValue?: true
    type?: true
    comment?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    studentId: string
    subjectId: string
    teacherId: string
    value: number
    maxValue: number
    type: $Enums.GradeType
    comment: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    value?: boolean
    maxValue?: boolean
    type?: boolean
    comment?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    value?: boolean
    maxValue?: boolean
    type?: boolean
    comment?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    studentId?: boolean
    subjectId?: boolean
    teacherId?: boolean
    value?: boolean
    maxValue?: boolean
    type?: boolean
    comment?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      subjectId: string
      teacherId: string
      value: number
      maxValue: number
      type: $Enums.GradeType
      comment: string | null
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */ 
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly studentId: FieldRef<"Grade", 'String'>
    readonly subjectId: FieldRef<"Grade", 'String'>
    readonly teacherId: FieldRef<"Grade", 'String'>
    readonly value: FieldRef<"Grade", 'Float'>
    readonly maxValue: FieldRef<"Grade", 'Float'>
    readonly type: FieldRef<"Grade", 'GradeType'>
    readonly comment: FieldRef<"Grade", 'String'>
    readonly date: FieldRef<"Grade", 'DateTime'>
    readonly createdAt: FieldRef<"Grade", 'DateTime'>
    readonly updatedAt: FieldRef<"Grade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model Assignment
   */

  export type AggregateAssignment = {
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  export type AssignmentAvgAggregateOutputType = {
    maxGrade: number | null
  }

  export type AssignmentSumAggregateOutputType = {
    maxGrade: number | null
  }

  export type AssignmentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    instructions: string | null
    type: $Enums.AssignmentType | null
    priority: $Enums.Priority | null
    maxGrade: number | null
    dueDate: Date | null
    submissionFormat: $Enums.SubmissionFormat | null
    teacherId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    instructions: string | null
    type: $Enums.AssignmentType | null
    priority: $Enums.Priority | null
    maxGrade: number | null
    dueDate: Date | null
    submissionFormat: $Enums.SubmissionFormat | null
    teacherId: string | null
    subjectId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    instructions: number
    type: number
    priority: number
    maxGrade: number
    dueDate: number
    submissionFormat: number
    teacherId: number
    subjectId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssignmentAvgAggregateInputType = {
    maxGrade?: true
  }

  export type AssignmentSumAggregateInputType = {
    maxGrade?: true
  }

  export type AssignmentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    instructions?: true
    type?: true
    priority?: true
    maxGrade?: true
    dueDate?: true
    submissionFormat?: true
    teacherId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    instructions?: true
    type?: true
    priority?: true
    maxGrade?: true
    dueDate?: true
    submissionFormat?: true
    teacherId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    instructions?: true
    type?: true
    priority?: true
    maxGrade?: true
    dueDate?: true
    submissionFormat?: true
    teacherId?: true
    subjectId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignment to aggregate.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assignments
    **/
    _count?: true | AssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentMaxAggregateInputType
  }

  export type GetAssignmentAggregateType<T extends AssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignment[P]>
      : GetScalarType<T[P], AggregateAssignment[P]>
  }




  export type AssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentWhereInput
    orderBy?: AssignmentOrderByWithAggregationInput | AssignmentOrderByWithAggregationInput[]
    by: AssignmentScalarFieldEnum[] | AssignmentScalarFieldEnum
    having?: AssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentCountAggregateInputType | true
    _avg?: AssignmentAvgAggregateInputType
    _sum?: AssignmentSumAggregateInputType
    _min?: AssignmentMinAggregateInputType
    _max?: AssignmentMaxAggregateInputType
  }

  export type AssignmentGroupByOutputType = {
    id: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority: $Enums.Priority
    maxGrade: number
    dueDate: Date
    submissionFormat: $Enums.SubmissionFormat
    teacherId: string
    subjectId: string
    createdAt: Date
    updatedAt: Date
    _count: AssignmentCountAggregateOutputType | null
    _avg: AssignmentAvgAggregateOutputType | null
    _sum: AssignmentSumAggregateOutputType | null
    _min: AssignmentMinAggregateOutputType | null
    _max: AssignmentMaxAggregateOutputType | null
  }

  type GetAssignmentGroupByPayload<T extends AssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    instructions?: boolean
    type?: boolean
    priority?: boolean
    maxGrade?: boolean
    dueDate?: boolean
    submissionFormat?: boolean
    teacherId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classes?: boolean | Assignment$classesArgs<ExtArgs>
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    attachments?: boolean | Assignment$attachmentsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    instructions?: boolean
    type?: boolean
    priority?: boolean
    maxGrade?: boolean
    dueDate?: boolean
    submissionFormat?: boolean
    teacherId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignment"]>

  export type AssignmentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    instructions?: boolean
    type?: boolean
    priority?: boolean
    maxGrade?: boolean
    dueDate?: boolean
    submissionFormat?: boolean
    teacherId?: boolean
    subjectId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classes?: boolean | Assignment$classesArgs<ExtArgs>
    submissions?: boolean | Assignment$submissionsArgs<ExtArgs>
    attachments?: boolean | Assignment$attachmentsArgs<ExtArgs>
    _count?: boolean | AssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $AssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assignment"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      classes: Prisma.$AssignmentClassPayload<ExtArgs>[]
      submissions: Prisma.$AssignmentSubmissionPayload<ExtArgs>[]
      attachments: Prisma.$FileAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      instructions: string
      type: $Enums.AssignmentType
      priority: $Enums.Priority
      maxGrade: number
      dueDate: Date
      submissionFormat: $Enums.SubmissionFormat
      teacherId: string
      subjectId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assignment"]>
    composites: {}
  }

  type AssignmentGetPayload<S extends boolean | null | undefined | AssignmentDefaultArgs> = $Result.GetResult<Prisma.$AssignmentPayload, S>

  type AssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentCountAggregateInputType | true
    }

  export interface AssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assignment'], meta: { name: 'Assignment' } }
    /**
     * Find zero or one Assignment that matches the filter.
     * @param {AssignmentFindUniqueArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentFindUniqueArgs>(args: SelectSubset<T, AssignmentFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Assignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentFindUniqueOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Assignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentFindFirstArgs>(args?: SelectSubset<T, AssignmentFindFirstArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Assignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindFirstOrThrowArgs} args - Arguments to find a Assignment
     * @example
     * // Get one Assignment
     * const assignment = await prisma.assignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignment.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentWithIdOnly = await prisma.assignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentFindManyArgs>(args?: SelectSubset<T, AssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Assignment.
     * @param {AssignmentCreateArgs} args - Arguments to create a Assignment.
     * @example
     * // Create one Assignment
     * const Assignment = await prisma.assignment.create({
     *   data: {
     *     // ... data to create a Assignment
     *   }
     * })
     * 
     */
    create<T extends AssignmentCreateArgs>(args: SelectSubset<T, AssignmentCreateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Assignments.
     * @param {AssignmentCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentCreateManyArgs>(args?: SelectSubset<T, AssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {AssignmentCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignment = await prisma.assignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentWithIdOnly = await prisma.assignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Assignment.
     * @param {AssignmentDeleteArgs} args - Arguments to delete one Assignment.
     * @example
     * // Delete one Assignment
     * const Assignment = await prisma.assignment.delete({
     *   where: {
     *     // ... filter to delete one Assignment
     *   }
     * })
     * 
     */
    delete<T extends AssignmentDeleteArgs>(args: SelectSubset<T, AssignmentDeleteArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Assignment.
     * @param {AssignmentUpdateArgs} args - Arguments to update one Assignment.
     * @example
     * // Update one Assignment
     * const assignment = await prisma.assignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentUpdateArgs>(args: SelectSubset<T, AssignmentUpdateArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Assignments.
     * @param {AssignmentDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentDeleteManyArgs>(args?: SelectSubset<T, AssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignment = await prisma.assignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentUpdateManyArgs>(args: SelectSubset<T, AssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Assignment.
     * @param {AssignmentUpsertArgs} args - Arguments to update or create a Assignment.
     * @example
     * // Update or create a Assignment
     * const assignment = await prisma.assignment.upsert({
     *   create: {
     *     // ... data to create a Assignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignment we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentUpsertArgs>(args: SelectSubset<T, AssignmentUpsertArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignment.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends AssignmentCountArgs>(
      args?: Subset<T, AssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentAggregateArgs>(args: Subset<T, AssignmentAggregateArgs>): Prisma.PrismaPromise<GetAssignmentAggregateType<T>>

    /**
     * Group by Assignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assignment model
   */
  readonly fields: AssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    classes<T extends Assignment$classesArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends Assignment$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends Assignment$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Assignment$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assignment model
   */ 
  interface AssignmentFieldRefs {
    readonly id: FieldRef<"Assignment", 'String'>
    readonly title: FieldRef<"Assignment", 'String'>
    readonly description: FieldRef<"Assignment", 'String'>
    readonly instructions: FieldRef<"Assignment", 'String'>
    readonly type: FieldRef<"Assignment", 'AssignmentType'>
    readonly priority: FieldRef<"Assignment", 'Priority'>
    readonly maxGrade: FieldRef<"Assignment", 'Float'>
    readonly dueDate: FieldRef<"Assignment", 'DateTime'>
    readonly submissionFormat: FieldRef<"Assignment", 'SubmissionFormat'>
    readonly teacherId: FieldRef<"Assignment", 'String'>
    readonly subjectId: FieldRef<"Assignment", 'String'>
    readonly createdAt: FieldRef<"Assignment", 'DateTime'>
    readonly updatedAt: FieldRef<"Assignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assignment findUnique
   */
  export type AssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findUniqueOrThrow
   */
  export type AssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment findFirst
   */
  export type AssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findFirstOrThrow
   */
  export type AssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignment to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assignments.
     */
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment findMany
   */
  export type AssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter, which Assignments to fetch.
     */
    where?: AssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assignments to fetch.
     */
    orderBy?: AssignmentOrderByWithRelationInput | AssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assignments.
     */
    cursor?: AssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assignments.
     */
    skip?: number
    distinct?: AssignmentScalarFieldEnum | AssignmentScalarFieldEnum[]
  }

  /**
   * Assignment create
   */
  export type AssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Assignment.
     */
    data: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
  }

  /**
   * Assignment createMany
   */
  export type AssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assignment createManyAndReturn
   */
  export type AssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Assignments.
     */
    data: AssignmentCreateManyInput | AssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assignment update
   */
  export type AssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Assignment.
     */
    data: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
    /**
     * Choose, which Assignment to update.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment updateMany
   */
  export type AssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assignments.
     */
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyInput>
    /**
     * Filter which Assignments to update
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment upsert
   */
  export type AssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Assignment to update in case it exists.
     */
    where: AssignmentWhereUniqueInput
    /**
     * In case the Assignment found by the `where` argument doesn't exist, create a new Assignment with this data.
     */
    create: XOR<AssignmentCreateInput, AssignmentUncheckedCreateInput>
    /**
     * In case the Assignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentUpdateInput, AssignmentUncheckedUpdateInput>
  }

  /**
   * Assignment delete
   */
  export type AssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    /**
     * Filter which Assignment to delete.
     */
    where: AssignmentWhereUniqueInput
  }

  /**
   * Assignment deleteMany
   */
  export type AssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assignments to delete
     */
    where?: AssignmentWhereInput
  }

  /**
   * Assignment.classes
   */
  export type Assignment$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    where?: AssignmentClassWhereInput
    orderBy?: AssignmentClassOrderByWithRelationInput | AssignmentClassOrderByWithRelationInput[]
    cursor?: AssignmentClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentClassScalarFieldEnum | AssignmentClassScalarFieldEnum[]
  }

  /**
   * Assignment.submissions
   */
  export type Assignment$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    cursor?: AssignmentSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * Assignment.attachments
   */
  export type Assignment$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    where?: FileAttachmentWhereInput
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    cursor?: FileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileAttachmentScalarFieldEnum | FileAttachmentScalarFieldEnum[]
  }

  /**
   * Assignment without action
   */
  export type AssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
  }


  /**
   * Model AssignmentSubmission
   */

  export type AggregateAssignmentSubmission = {
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  export type AssignmentSubmissionAvgAggregateOutputType = {
    grade: number | null
  }

  export type AssignmentSubmissionSumAggregateOutputType = {
    grade: number | null
  }

  export type AssignmentSubmissionMinAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
    content: string | null
    submittedAt: Date | null
    grade: number | null
    feedback: string | null
    status: $Enums.SubmissionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentSubmissionMaxAggregateOutputType = {
    id: string | null
    assignmentId: string | null
    studentId: string | null
    content: string | null
    submittedAt: Date | null
    grade: number | null
    feedback: string | null
    status: $Enums.SubmissionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AssignmentSubmissionCountAggregateOutputType = {
    id: number
    assignmentId: number
    studentId: number
    content: number
    submittedAt: number
    grade: number
    feedback: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AssignmentSubmissionAvgAggregateInputType = {
    grade?: true
  }

  export type AssignmentSubmissionSumAggregateInputType = {
    grade?: true
  }

  export type AssignmentSubmissionMinAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    content?: true
    submittedAt?: true
    grade?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentSubmissionMaxAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    content?: true
    submittedAt?: true
    grade?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AssignmentSubmissionCountAggregateInputType = {
    id?: true
    assignmentId?: true
    studentId?: true
    content?: true
    submittedAt?: true
    grade?: true
    feedback?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AssignmentSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmission to aggregate.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignmentSubmissions
    **/
    _count?: true | AssignmentSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type GetAssignmentSubmissionAggregateType<T extends AssignmentSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignmentSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
      : GetScalarType<T[P], AggregateAssignmentSubmission[P]>
  }




  export type AssignmentSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentSubmissionWhereInput
    orderBy?: AssignmentSubmissionOrderByWithAggregationInput | AssignmentSubmissionOrderByWithAggregationInput[]
    by: AssignmentSubmissionScalarFieldEnum[] | AssignmentSubmissionScalarFieldEnum
    having?: AssignmentSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentSubmissionCountAggregateInputType | true
    _avg?: AssignmentSubmissionAvgAggregateInputType
    _sum?: AssignmentSubmissionSumAggregateInputType
    _min?: AssignmentSubmissionMinAggregateInputType
    _max?: AssignmentSubmissionMaxAggregateInputType
  }

  export type AssignmentSubmissionGroupByOutputType = {
    id: string
    assignmentId: string
    studentId: string
    content: string | null
    submittedAt: Date | null
    grade: number | null
    feedback: string | null
    status: $Enums.SubmissionStatus
    createdAt: Date
    updatedAt: Date
    _count: AssignmentSubmissionCountAggregateOutputType | null
    _avg: AssignmentSubmissionAvgAggregateOutputType | null
    _sum: AssignmentSubmissionSumAggregateOutputType | null
    _min: AssignmentSubmissionMinAggregateOutputType | null
    _max: AssignmentSubmissionMaxAggregateOutputType | null
  }

  type GetAssignmentSubmissionGroupByPayload<T extends AssignmentSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    content?: boolean
    submittedAt?: boolean
    grade?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    attachments?: boolean | AssignmentSubmission$attachmentsArgs<ExtArgs>
    _count?: boolean | AssignmentSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    content?: boolean
    submittedAt?: boolean
    grade?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentSubmission"]>

  export type AssignmentSubmissionSelectScalar = {
    id?: boolean
    assignmentId?: boolean
    studentId?: boolean
    content?: boolean
    submittedAt?: boolean
    grade?: boolean
    feedback?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AssignmentSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    attachments?: boolean | AssignmentSubmission$attachmentsArgs<ExtArgs>
    _count?: boolean | AssignmentSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $AssignmentSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignmentSubmission"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      attachments: Prisma.$FileAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignmentId: string
      studentId: string
      content: string | null
      submittedAt: Date | null
      grade: number | null
      feedback: string | null
      status: $Enums.SubmissionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["assignmentSubmission"]>
    composites: {}
  }

  type AssignmentSubmissionGetPayload<S extends boolean | null | undefined | AssignmentSubmissionDefaultArgs> = $Result.GetResult<Prisma.$AssignmentSubmissionPayload, S>

  type AssignmentSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentSubmissionCountAggregateInputType | true
    }

  export interface AssignmentSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignmentSubmission'], meta: { name: 'AssignmentSubmission' } }
    /**
     * Find zero or one AssignmentSubmission that matches the filter.
     * @param {AssignmentSubmissionFindUniqueArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentSubmissionFindUniqueArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssignmentSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentSubmissionFindUniqueOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssignmentSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentSubmissionFindFirstArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssignmentSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindFirstOrThrowArgs} args - Arguments to find a AssignmentSubmission
     * @example
     * // Get one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssignmentSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany()
     * 
     * // Get first 10 AssignmentSubmissions
     * const assignmentSubmissions = await prisma.assignmentSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssignmentSubmissionFindManyArgs>(args?: SelectSubset<T, AssignmentSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssignmentSubmission.
     * @param {AssignmentSubmissionCreateArgs} args - Arguments to create a AssignmentSubmission.
     * @example
     * // Create one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.create({
     *   data: {
     *     // ... data to create a AssignmentSubmission
     *   }
     * })
     * 
     */
    create<T extends AssignmentSubmissionCreateArgs>(args: SelectSubset<T, AssignmentSubmissionCreateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssignmentSubmissions.
     * @param {AssignmentSubmissionCreateManyArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentSubmissionCreateManyArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignmentSubmissions and returns the data saved in the database.
     * @param {AssignmentSubmissionCreateManyAndReturnArgs} args - Arguments to create many AssignmentSubmissions.
     * @example
     * // Create many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignmentSubmissions and only return the `id`
     * const assignmentSubmissionWithIdOnly = await prisma.assignmentSubmission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssignmentSubmission.
     * @param {AssignmentSubmissionDeleteArgs} args - Arguments to delete one AssignmentSubmission.
     * @example
     * // Delete one AssignmentSubmission
     * const AssignmentSubmission = await prisma.assignmentSubmission.delete({
     *   where: {
     *     // ... filter to delete one AssignmentSubmission
     *   }
     * })
     * 
     */
    delete<T extends AssignmentSubmissionDeleteArgs>(args: SelectSubset<T, AssignmentSubmissionDeleteArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpdateArgs} args - Arguments to update one AssignmentSubmission.
     * @example
     * // Update one AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentSubmissionUpdateArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssignmentSubmissions.
     * @param {AssignmentSubmissionDeleteManyArgs} args - Arguments to filter AssignmentSubmissions to delete.
     * @example
     * // Delete a few AssignmentSubmissions
     * const { count } = await prisma.assignmentSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentSubmissionDeleteManyArgs>(args?: SelectSubset<T, AssignmentSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignmentSubmissions
     * const assignmentSubmission = await prisma.assignmentSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentSubmissionUpdateManyArgs>(args: SelectSubset<T, AssignmentSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssignmentSubmission.
     * @param {AssignmentSubmissionUpsertArgs} args - Arguments to update or create a AssignmentSubmission.
     * @example
     * // Update or create a AssignmentSubmission
     * const assignmentSubmission = await prisma.assignmentSubmission.upsert({
     *   create: {
     *     // ... data to create a AssignmentSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignmentSubmission we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentSubmissionUpsertArgs>(args: SelectSubset<T, AssignmentSubmissionUpsertArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssignmentSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionCountArgs} args - Arguments to filter AssignmentSubmissions to count.
     * @example
     * // Count the number of AssignmentSubmissions
     * const count = await prisma.assignmentSubmission.count({
     *   where: {
     *     // ... the filter for the AssignmentSubmissions we want to count
     *   }
     * })
    **/
    count<T extends AssignmentSubmissionCountArgs>(
      args?: Subset<T, AssignmentSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentSubmissionAggregateArgs>(args: Subset<T, AssignmentSubmissionAggregateArgs>): Prisma.PrismaPromise<GetAssignmentSubmissionAggregateType<T>>

    /**
     * Group by AssignmentSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignmentSubmission model
   */
  readonly fields: AssignmentSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignmentSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends AssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentDefaultArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    attachments<T extends AssignmentSubmission$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentSubmission$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignmentSubmission model
   */ 
  interface AssignmentSubmissionFieldRefs {
    readonly id: FieldRef<"AssignmentSubmission", 'String'>
    readonly assignmentId: FieldRef<"AssignmentSubmission", 'String'>
    readonly studentId: FieldRef<"AssignmentSubmission", 'String'>
    readonly content: FieldRef<"AssignmentSubmission", 'String'>
    readonly submittedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly grade: FieldRef<"AssignmentSubmission", 'Float'>
    readonly feedback: FieldRef<"AssignmentSubmission", 'String'>
    readonly status: FieldRef<"AssignmentSubmission", 'SubmissionStatus'>
    readonly createdAt: FieldRef<"AssignmentSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"AssignmentSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AssignmentSubmission findUnique
   */
  export type AssignmentSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findUniqueOrThrow
   */
  export type AssignmentSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission findFirst
   */
  export type AssignmentSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findFirstOrThrow
   */
  export type AssignmentSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmission to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentSubmissions.
     */
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission findMany
   */
  export type AssignmentSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentSubmissions to fetch.
     */
    where?: AssignmentSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentSubmissions to fetch.
     */
    orderBy?: AssignmentSubmissionOrderByWithRelationInput | AssignmentSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignmentSubmissions.
     */
    cursor?: AssignmentSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentSubmissions.
     */
    skip?: number
    distinct?: AssignmentSubmissionScalarFieldEnum | AssignmentSubmissionScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission create
   */
  export type AssignmentSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
  }

  /**
   * AssignmentSubmission createMany
   */
  export type AssignmentSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignmentSubmission createManyAndReturn
   */
  export type AssignmentSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssignmentSubmissions.
     */
    data: AssignmentSubmissionCreateManyInput | AssignmentSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentSubmission update
   */
  export type AssignmentSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignmentSubmission.
     */
    data: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
    /**
     * Choose, which AssignmentSubmission to update.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission updateMany
   */
  export type AssignmentSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignmentSubmissions.
     */
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentSubmissions to update
     */
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * AssignmentSubmission upsert
   */
  export type AssignmentSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignmentSubmission to update in case it exists.
     */
    where: AssignmentSubmissionWhereUniqueInput
    /**
     * In case the AssignmentSubmission found by the `where` argument doesn't exist, create a new AssignmentSubmission with this data.
     */
    create: XOR<AssignmentSubmissionCreateInput, AssignmentSubmissionUncheckedCreateInput>
    /**
     * In case the AssignmentSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentSubmissionUpdateInput, AssignmentSubmissionUncheckedUpdateInput>
  }

  /**
   * AssignmentSubmission delete
   */
  export type AssignmentSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    /**
     * Filter which AssignmentSubmission to delete.
     */
    where: AssignmentSubmissionWhereUniqueInput
  }

  /**
   * AssignmentSubmission deleteMany
   */
  export type AssignmentSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentSubmissions to delete
     */
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * AssignmentSubmission.attachments
   */
  export type AssignmentSubmission$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    where?: FileAttachmentWhereInput
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    cursor?: FileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileAttachmentScalarFieldEnum | FileAttachmentScalarFieldEnum[]
  }

  /**
   * AssignmentSubmission without action
   */
  export type AssignmentSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceRecord
   */

  export type AggregateAttendanceRecord = {
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  export type AttendanceRecordMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    teacherId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    period: string | null
    reason: string | null
    notifiedParents: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    classId: string | null
    teacherId: string | null
    date: Date | null
    status: $Enums.AttendanceStatus | null
    period: string | null
    reason: string | null
    notifiedParents: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AttendanceRecordCountAggregateOutputType = {
    id: number
    studentId: number
    classId: number
    teacherId: number
    date: number
    status: number
    period: number
    reason: number
    notifiedParents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AttendanceRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    teacherId?: true
    date?: true
    status?: true
    period?: true
    reason?: true
    notifiedParents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    teacherId?: true
    date?: true
    status?: true
    period?: true
    reason?: true
    notifiedParents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AttendanceRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    classId?: true
    teacherId?: true
    date?: true
    status?: true
    period?: true
    reason?: true
    notifiedParents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AttendanceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecord to aggregate.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceRecords
    **/
    _count?: true | AttendanceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type GetAttendanceRecordAggregateType<T extends AttendanceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceRecord[P]>
      : GetScalarType<T[P], AggregateAttendanceRecord[P]>
  }




  export type AttendanceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceRecordWhereInput
    orderBy?: AttendanceRecordOrderByWithAggregationInput | AttendanceRecordOrderByWithAggregationInput[]
    by: AttendanceRecordScalarFieldEnum[] | AttendanceRecordScalarFieldEnum
    having?: AttendanceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceRecordCountAggregateInputType | true
    _min?: AttendanceRecordMinAggregateInputType
    _max?: AttendanceRecordMaxAggregateInputType
  }

  export type AttendanceRecordGroupByOutputType = {
    id: string
    studentId: string
    classId: string | null
    teacherId: string
    date: Date
    status: $Enums.AttendanceStatus
    period: string | null
    reason: string | null
    notifiedParents: boolean
    createdAt: Date
    updatedAt: Date
    _count: AttendanceRecordCountAggregateOutputType | null
    _min: AttendanceRecordMinAggregateOutputType | null
    _max: AttendanceRecordMaxAggregateOutputType | null
  }

  type GetAttendanceRecordGroupByPayload<T extends AttendanceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceRecordGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    teacherId?: boolean
    date?: boolean
    status?: boolean
    period?: boolean
    reason?: boolean
    notifiedParents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | AttendanceRecord$classArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    classId?: boolean
    teacherId?: boolean
    date?: boolean
    status?: boolean
    period?: boolean
    reason?: boolean
    notifiedParents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | AttendanceRecord$classArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceRecord"]>

  export type AttendanceRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    classId?: boolean
    teacherId?: boolean
    date?: boolean
    status?: boolean
    period?: boolean
    reason?: boolean
    notifiedParents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AttendanceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | AttendanceRecord$classArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type AttendanceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    class?: boolean | AttendanceRecord$classArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $AttendanceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs> | null
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      classId: string | null
      teacherId: string
      date: Date
      status: $Enums.AttendanceStatus
      period: string | null
      reason: string | null
      notifiedParents: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["attendanceRecord"]>
    composites: {}
  }

  type AttendanceRecordGetPayload<S extends boolean | null | undefined | AttendanceRecordDefaultArgs> = $Result.GetResult<Prisma.$AttendanceRecordPayload, S>

  type AttendanceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceRecordCountAggregateInputType | true
    }

  export interface AttendanceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceRecord'], meta: { name: 'AttendanceRecord' } }
    /**
     * Find zero or one AttendanceRecord that matches the filter.
     * @param {AttendanceRecordFindUniqueArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceRecordFindUniqueArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttendanceRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceRecordFindUniqueOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttendanceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceRecordFindFirstArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttendanceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindFirstOrThrowArgs} args - Arguments to find a AttendanceRecord
     * @example
     * // Get one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttendanceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany()
     * 
     * // Get first 10 AttendanceRecords
     * const attendanceRecords = await prisma.attendanceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceRecordFindManyArgs>(args?: SelectSubset<T, AttendanceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttendanceRecord.
     * @param {AttendanceRecordCreateArgs} args - Arguments to create a AttendanceRecord.
     * @example
     * // Create one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.create({
     *   data: {
     *     // ... data to create a AttendanceRecord
     *   }
     * })
     * 
     */
    create<T extends AttendanceRecordCreateArgs>(args: SelectSubset<T, AttendanceRecordCreateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttendanceRecords.
     * @param {AttendanceRecordCreateManyArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceRecordCreateManyArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceRecords and returns the data saved in the database.
     * @param {AttendanceRecordCreateManyAndReturnArgs} args - Arguments to create many AttendanceRecords.
     * @example
     * // Create many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceRecords and only return the `id`
     * const attendanceRecordWithIdOnly = await prisma.attendanceRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttendanceRecord.
     * @param {AttendanceRecordDeleteArgs} args - Arguments to delete one AttendanceRecord.
     * @example
     * // Delete one AttendanceRecord
     * const AttendanceRecord = await prisma.attendanceRecord.delete({
     *   where: {
     *     // ... filter to delete one AttendanceRecord
     *   }
     * })
     * 
     */
    delete<T extends AttendanceRecordDeleteArgs>(args: SelectSubset<T, AttendanceRecordDeleteArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttendanceRecord.
     * @param {AttendanceRecordUpdateArgs} args - Arguments to update one AttendanceRecord.
     * @example
     * // Update one AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceRecordUpdateArgs>(args: SelectSubset<T, AttendanceRecordUpdateArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttendanceRecords.
     * @param {AttendanceRecordDeleteManyArgs} args - Arguments to filter AttendanceRecords to delete.
     * @example
     * // Delete a few AttendanceRecords
     * const { count } = await prisma.attendanceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceRecordDeleteManyArgs>(args?: SelectSubset<T, AttendanceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceRecords
     * const attendanceRecord = await prisma.attendanceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceRecordUpdateManyArgs>(args: SelectSubset<T, AttendanceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceRecord.
     * @param {AttendanceRecordUpsertArgs} args - Arguments to update or create a AttendanceRecord.
     * @example
     * // Update or create a AttendanceRecord
     * const attendanceRecord = await prisma.attendanceRecord.upsert({
     *   create: {
     *     // ... data to create a AttendanceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceRecord we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceRecordUpsertArgs>(args: SelectSubset<T, AttendanceRecordUpsertArgs<ExtArgs>>): Prisma__AttendanceRecordClient<$Result.GetResult<Prisma.$AttendanceRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttendanceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordCountArgs} args - Arguments to filter AttendanceRecords to count.
     * @example
     * // Count the number of AttendanceRecords
     * const count = await prisma.attendanceRecord.count({
     *   where: {
     *     // ... the filter for the AttendanceRecords we want to count
     *   }
     * })
    **/
    count<T extends AttendanceRecordCountArgs>(
      args?: Subset<T, AttendanceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceRecordAggregateArgs>(args: Subset<T, AttendanceRecordAggregateArgs>): Prisma.PrismaPromise<GetAttendanceRecordAggregateType<T>>

    /**
     * Group by AttendanceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceRecordGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceRecord model
   */
  readonly fields: AttendanceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends AttendanceRecord$classArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceRecord$classArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceRecord model
   */ 
  interface AttendanceRecordFieldRefs {
    readonly id: FieldRef<"AttendanceRecord", 'String'>
    readonly studentId: FieldRef<"AttendanceRecord", 'String'>
    readonly classId: FieldRef<"AttendanceRecord", 'String'>
    readonly teacherId: FieldRef<"AttendanceRecord", 'String'>
    readonly date: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly status: FieldRef<"AttendanceRecord", 'AttendanceStatus'>
    readonly period: FieldRef<"AttendanceRecord", 'String'>
    readonly reason: FieldRef<"AttendanceRecord", 'String'>
    readonly notifiedParents: FieldRef<"AttendanceRecord", 'Boolean'>
    readonly createdAt: FieldRef<"AttendanceRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"AttendanceRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceRecord findUnique
   */
  export type AttendanceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findUniqueOrThrow
   */
  export type AttendanceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord findFirst
   */
  export type AttendanceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findFirstOrThrow
   */
  export type AttendanceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecord to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceRecords.
     */
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord findMany
   */
  export type AttendanceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceRecords to fetch.
     */
    where?: AttendanceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceRecords to fetch.
     */
    orderBy?: AttendanceRecordOrderByWithRelationInput | AttendanceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceRecords.
     */
    cursor?: AttendanceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceRecords.
     */
    skip?: number
    distinct?: AttendanceRecordScalarFieldEnum | AttendanceRecordScalarFieldEnum[]
  }

  /**
   * AttendanceRecord create
   */
  export type AttendanceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceRecord.
     */
    data: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
  }

  /**
   * AttendanceRecord createMany
   */
  export type AttendanceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceRecord createManyAndReturn
   */
  export type AttendanceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttendanceRecords.
     */
    data: AttendanceRecordCreateManyInput | AttendanceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceRecord update
   */
  export type AttendanceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceRecord.
     */
    data: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
    /**
     * Choose, which AttendanceRecord to update.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord updateMany
   */
  export type AttendanceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceRecords.
     */
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceRecords to update
     */
    where?: AttendanceRecordWhereInput
  }

  /**
   * AttendanceRecord upsert
   */
  export type AttendanceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceRecord to update in case it exists.
     */
    where: AttendanceRecordWhereUniqueInput
    /**
     * In case the AttendanceRecord found by the `where` argument doesn't exist, create a new AttendanceRecord with this data.
     */
    create: XOR<AttendanceRecordCreateInput, AttendanceRecordUncheckedCreateInput>
    /**
     * In case the AttendanceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceRecordUpdateInput, AttendanceRecordUncheckedUpdateInput>
  }

  /**
   * AttendanceRecord delete
   */
  export type AttendanceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
    /**
     * Filter which AttendanceRecord to delete.
     */
    where: AttendanceRecordWhereUniqueInput
  }

  /**
   * AttendanceRecord deleteMany
   */
  export type AttendanceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceRecords to delete
     */
    where?: AttendanceRecordWhereInput
  }

  /**
   * AttendanceRecord.class
   */
  export type AttendanceRecord$classArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Class
     */
    select?: ClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassInclude<ExtArgs> | null
    where?: ClassWhereInput
  }

  /**
   * AttendanceRecord without action
   */
  export type AttendanceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceRecord
     */
    select?: AttendanceRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceRecordInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null
    duration: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    dayOfWeek: number | null
    duration: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    classId: string | null
    teacherId: string | null
    subjectId: string | null
    room: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    duration: number | null
    academicYear: string | null
    semester: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    classId: string | null
    teacherId: string | null
    subjectId: string | null
    room: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    duration: number | null
    academicYear: string | null
    semester: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    classId: number
    teacherId: number
    subjectId: number
    room: number
    dayOfWeek: number
    startTime: number
    endTime: number
    duration: number
    academicYear: number
    semester: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    dayOfWeek?: true
    duration?: true
  }

  export type ScheduleSumAggregateInputType = {
    dayOfWeek?: true
    duration?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    classId?: true
    teacherId?: true
    subjectId?: true
    room?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    duration?: true
    academicYear?: true
    semester?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    classId?: true
    teacherId?: true
    subjectId?: true
    room?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    duration?: true
    academicYear?: true
    semester?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    classId?: true
    teacherId?: true
    subjectId?: true
    room?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    duration?: true
    academicYear?: true
    semester?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    classId: string
    teacherId: string
    subjectId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    teacherId?: boolean
    subjectId?: boolean
    room?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    academicYear?: boolean
    semester?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classId?: boolean
    teacherId?: boolean
    subjectId?: boolean
    room?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    academicYear?: boolean
    semester?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    classId?: boolean
    teacherId?: boolean
    subjectId?: boolean
    room?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    academicYear?: boolean
    semester?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      classId: string
      teacherId: string
      subjectId: string
      room: string
      dayOfWeek: number
      startTime: string
      endTime: string
      duration: number
      academicYear: string
      semester: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */ 
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly classId: FieldRef<"Schedule", 'String'>
    readonly teacherId: FieldRef<"Schedule", 'String'>
    readonly subjectId: FieldRef<"Schedule", 'String'>
    readonly room: FieldRef<"Schedule", 'String'>
    readonly dayOfWeek: FieldRef<"Schedule", 'Int'>
    readonly startTime: FieldRef<"Schedule", 'String'>
    readonly endTime: FieldRef<"Schedule", 'String'>
    readonly duration: FieldRef<"Schedule", 'Int'>
    readonly academicYear: FieldRef<"Schedule", 'String'>
    readonly semester: FieldRef<"Schedule", 'String'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    senderId: string | null
    subject: string | null
    content: string | null
    type: $Enums.MessageType | null
    priority: $Enums.Priority | null
    read: boolean | null
    parentMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    senderId: string | null
    subject: string | null
    content: string | null
    type: $Enums.MessageType | null
    priority: $Enums.Priority | null
    read: boolean | null
    parentMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    senderId: number
    recipientIds: number
    subject: number
    content: number
    type: number
    priority: number
    read: number
    parentMessageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    senderId?: true
    subject?: true
    content?: true
    type?: true
    priority?: true
    read?: true
    parentMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    senderId?: true
    subject?: true
    content?: true
    type?: true
    priority?: true
    read?: true
    parentMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    senderId?: true
    recipientIds?: true
    subject?: true
    content?: true
    type?: true
    priority?: true
    read?: true
    parentMessageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    senderId: string
    recipientIds: string[]
    subject: string
    content: string
    type: $Enums.MessageType
    priority: $Enums.Priority
    read: boolean
    parentMessageId: string | null
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientIds?: boolean
    subject?: boolean
    content?: boolean
    type?: boolean
    priority?: boolean
    read?: boolean
    parentMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipients?: boolean | Message$recipientsArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    senderId?: boolean
    recipientIds?: boolean
    subject?: boolean
    content?: boolean
    type?: boolean
    priority?: boolean
    read?: boolean
    parentMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    senderId?: boolean
    recipientIds?: boolean
    subject?: boolean
    content?: boolean
    type?: boolean
    priority?: boolean
    read?: boolean
    parentMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    recipients?: boolean | Message$recipientsArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
    replies?: boolean | Message$repliesArgs<ExtArgs>
    attachments?: boolean | Message$attachmentsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    parentMessage?: boolean | Message$parentMessageArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      recipients: Prisma.$UserPayload<ExtArgs>[]
      parentMessage: Prisma.$MessagePayload<ExtArgs> | null
      replies: Prisma.$MessagePayload<ExtArgs>[]
      attachments: Prisma.$FileAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      senderId: string
      recipientIds: string[]
      subject: string
      content: string
      type: $Enums.MessageType
      priority: $Enums.Priority
      read: boolean
      parentMessageId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    recipients<T extends Message$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Message$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    parentMessage<T extends Message$parentMessageArgs<ExtArgs> = {}>(args?: Subset<T, Message$parentMessageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends Message$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Message$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany"> | Null>
    attachments<T extends Message$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Message$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly recipientIds: FieldRef<"Message", 'String[]'>
    readonly subject: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly priority: FieldRef<"Message", 'Priority'>
    readonly read: FieldRef<"Message", 'Boolean'>
    readonly parentMessageId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }

  /**
   * Message.recipients
   */
  export type Message$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Message.parentMessage
   */
  export type Message$parentMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Message.replies
   */
  export type Message$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message.attachments
   */
  export type Message$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    where?: FileAttachmentWhereInput
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    cursor?: FileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileAttachmentScalarFieldEnum | FileAttachmentScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model FinancialRecord
   */

  export type AggregateFinancialRecord = {
    _count: FinancialRecordCountAggregateOutputType | null
    _avg: FinancialRecordAvgAggregateOutputType | null
    _sum: FinancialRecordSumAggregateOutputType | null
    _min: FinancialRecordMinAggregateOutputType | null
    _max: FinancialRecordMaxAggregateOutputType | null
  }

  export type FinancialRecordAvgAggregateOutputType = {
    amount: number | null
  }

  export type FinancialRecordSumAggregateOutputType = {
    amount: number | null
  }

  export type FinancialRecordMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    type: $Enums.FinancialType | null
    amount: number | null
    currency: string | null
    dueDate: Date | null
    paidDate: Date | null
    status: $Enums.PaymentStatus | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    invoiceNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialRecordMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    type: $Enums.FinancialType | null
    amount: number | null
    currency: string | null
    dueDate: Date | null
    paidDate: Date | null
    status: $Enums.PaymentStatus | null
    description: string | null
    paymentMethod: $Enums.PaymentMethod | null
    invoiceNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FinancialRecordCountAggregateOutputType = {
    id: number
    studentId: number
    type: number
    amount: number
    currency: number
    dueDate: number
    paidDate: number
    status: number
    description: number
    paymentMethod: number
    invoiceNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FinancialRecordAvgAggregateInputType = {
    amount?: true
  }

  export type FinancialRecordSumAggregateInputType = {
    amount?: true
  }

  export type FinancialRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    amount?: true
    currency?: true
    dueDate?: true
    paidDate?: true
    status?: true
    description?: true
    paymentMethod?: true
    invoiceNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    amount?: true
    currency?: true
    dueDate?: true
    paidDate?: true
    status?: true
    description?: true
    paymentMethod?: true
    invoiceNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FinancialRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    type?: true
    amount?: true
    currency?: true
    dueDate?: true
    paidDate?: true
    status?: true
    description?: true
    paymentMethod?: true
    invoiceNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FinancialRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialRecord to aggregate.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialRecords
    **/
    _count?: true | FinancialRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialRecordMaxAggregateInputType
  }

  export type GetFinancialRecordAggregateType<T extends FinancialRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialRecord[P]>
      : GetScalarType<T[P], AggregateFinancialRecord[P]>
  }




  export type FinancialRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialRecordWhereInput
    orderBy?: FinancialRecordOrderByWithAggregationInput | FinancialRecordOrderByWithAggregationInput[]
    by: FinancialRecordScalarFieldEnum[] | FinancialRecordScalarFieldEnum
    having?: FinancialRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialRecordCountAggregateInputType | true
    _avg?: FinancialRecordAvgAggregateInputType
    _sum?: FinancialRecordSumAggregateInputType
    _min?: FinancialRecordMinAggregateInputType
    _max?: FinancialRecordMaxAggregateInputType
  }

  export type FinancialRecordGroupByOutputType = {
    id: string
    studentId: string
    type: $Enums.FinancialType
    amount: number
    currency: string
    dueDate: Date
    paidDate: Date | null
    status: $Enums.PaymentStatus
    description: string
    paymentMethod: $Enums.PaymentMethod | null
    invoiceNumber: string
    createdAt: Date
    updatedAt: Date
    _count: FinancialRecordCountAggregateOutputType | null
    _avg: FinancialRecordAvgAggregateOutputType | null
    _sum: FinancialRecordSumAggregateOutputType | null
    _min: FinancialRecordMinAggregateOutputType | null
    _max: FinancialRecordMaxAggregateOutputType | null
  }

  type GetFinancialRecordGroupByPayload<T extends FinancialRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialRecordGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialRecordGroupByOutputType[P]>
        }
      >
    >


  export type FinancialRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    dueDate?: boolean
    paidDate?: boolean
    status?: boolean
    description?: boolean
    paymentMethod?: boolean
    invoiceNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialRecord"]>

  export type FinancialRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    dueDate?: boolean
    paidDate?: boolean
    status?: boolean
    description?: boolean
    paymentMethod?: boolean
    invoiceNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialRecord"]>

  export type FinancialRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    dueDate?: boolean
    paidDate?: boolean
    status?: boolean
    description?: boolean
    paymentMethod?: boolean
    invoiceNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FinancialRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type FinancialRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $FinancialRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      type: $Enums.FinancialType
      amount: number
      currency: string
      dueDate: Date
      paidDate: Date | null
      status: $Enums.PaymentStatus
      description: string
      paymentMethod: $Enums.PaymentMethod | null
      invoiceNumber: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["financialRecord"]>
    composites: {}
  }

  type FinancialRecordGetPayload<S extends boolean | null | undefined | FinancialRecordDefaultArgs> = $Result.GetResult<Prisma.$FinancialRecordPayload, S>

  type FinancialRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancialRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancialRecordCountAggregateInputType | true
    }

  export interface FinancialRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialRecord'], meta: { name: 'FinancialRecord' } }
    /**
     * Find zero or one FinancialRecord that matches the filter.
     * @param {FinancialRecordFindUniqueArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialRecordFindUniqueArgs>(args: SelectSubset<T, FinancialRecordFindUniqueArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancialRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancialRecordFindUniqueOrThrowArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancialRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordFindFirstArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialRecordFindFirstArgs>(args?: SelectSubset<T, FinancialRecordFindFirstArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancialRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordFindFirstOrThrowArgs} args - Arguments to find a FinancialRecord
     * @example
     * // Get one FinancialRecord
     * const financialRecord = await prisma.financialRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancialRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialRecords
     * const financialRecords = await prisma.financialRecord.findMany()
     * 
     * // Get first 10 FinancialRecords
     * const financialRecords = await prisma.financialRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financialRecordWithIdOnly = await prisma.financialRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FinancialRecordFindManyArgs>(args?: SelectSubset<T, FinancialRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancialRecord.
     * @param {FinancialRecordCreateArgs} args - Arguments to create a FinancialRecord.
     * @example
     * // Create one FinancialRecord
     * const FinancialRecord = await prisma.financialRecord.create({
     *   data: {
     *     // ... data to create a FinancialRecord
     *   }
     * })
     * 
     */
    create<T extends FinancialRecordCreateArgs>(args: SelectSubset<T, FinancialRecordCreateArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancialRecords.
     * @param {FinancialRecordCreateManyArgs} args - Arguments to create many FinancialRecords.
     * @example
     * // Create many FinancialRecords
     * const financialRecord = await prisma.financialRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialRecordCreateManyArgs>(args?: SelectSubset<T, FinancialRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FinancialRecords and returns the data saved in the database.
     * @param {FinancialRecordCreateManyAndReturnArgs} args - Arguments to create many FinancialRecords.
     * @example
     * // Create many FinancialRecords
     * const financialRecord = await prisma.financialRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FinancialRecords and only return the `id`
     * const financialRecordWithIdOnly = await prisma.financialRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FinancialRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, FinancialRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FinancialRecord.
     * @param {FinancialRecordDeleteArgs} args - Arguments to delete one FinancialRecord.
     * @example
     * // Delete one FinancialRecord
     * const FinancialRecord = await prisma.financialRecord.delete({
     *   where: {
     *     // ... filter to delete one FinancialRecord
     *   }
     * })
     * 
     */
    delete<T extends FinancialRecordDeleteArgs>(args: SelectSubset<T, FinancialRecordDeleteArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancialRecord.
     * @param {FinancialRecordUpdateArgs} args - Arguments to update one FinancialRecord.
     * @example
     * // Update one FinancialRecord
     * const financialRecord = await prisma.financialRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialRecordUpdateArgs>(args: SelectSubset<T, FinancialRecordUpdateArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancialRecords.
     * @param {FinancialRecordDeleteManyArgs} args - Arguments to filter FinancialRecords to delete.
     * @example
     * // Delete a few FinancialRecords
     * const { count } = await prisma.financialRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialRecordDeleteManyArgs>(args?: SelectSubset<T, FinancialRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialRecords
     * const financialRecord = await prisma.financialRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialRecordUpdateManyArgs>(args: SelectSubset<T, FinancialRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialRecord.
     * @param {FinancialRecordUpsertArgs} args - Arguments to update or create a FinancialRecord.
     * @example
     * // Update or create a FinancialRecord
     * const financialRecord = await prisma.financialRecord.upsert({
     *   create: {
     *     // ... data to create a FinancialRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialRecord we want to update
     *   }
     * })
     */
    upsert<T extends FinancialRecordUpsertArgs>(args: SelectSubset<T, FinancialRecordUpsertArgs<ExtArgs>>): Prisma__FinancialRecordClient<$Result.GetResult<Prisma.$FinancialRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancialRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordCountArgs} args - Arguments to filter FinancialRecords to count.
     * @example
     * // Count the number of FinancialRecords
     * const count = await prisma.financialRecord.count({
     *   where: {
     *     // ... the filter for the FinancialRecords we want to count
     *   }
     * })
    **/
    count<T extends FinancialRecordCountArgs>(
      args?: Subset<T, FinancialRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialRecordAggregateArgs>(args: Subset<T, FinancialRecordAggregateArgs>): Prisma.PrismaPromise<GetFinancialRecordAggregateType<T>>

    /**
     * Group by FinancialRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialRecordGroupByArgs['orderBy'] }
        : { orderBy?: FinancialRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialRecord model
   */
  readonly fields: FinancialRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialRecord model
   */ 
  interface FinancialRecordFieldRefs {
    readonly id: FieldRef<"FinancialRecord", 'String'>
    readonly studentId: FieldRef<"FinancialRecord", 'String'>
    readonly type: FieldRef<"FinancialRecord", 'FinancialType'>
    readonly amount: FieldRef<"FinancialRecord", 'Float'>
    readonly currency: FieldRef<"FinancialRecord", 'String'>
    readonly dueDate: FieldRef<"FinancialRecord", 'DateTime'>
    readonly paidDate: FieldRef<"FinancialRecord", 'DateTime'>
    readonly status: FieldRef<"FinancialRecord", 'PaymentStatus'>
    readonly description: FieldRef<"FinancialRecord", 'String'>
    readonly paymentMethod: FieldRef<"FinancialRecord", 'PaymentMethod'>
    readonly invoiceNumber: FieldRef<"FinancialRecord", 'String'>
    readonly createdAt: FieldRef<"FinancialRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"FinancialRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FinancialRecord findUnique
   */
  export type FinancialRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord findUniqueOrThrow
   */
  export type FinancialRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord findFirst
   */
  export type FinancialRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialRecords.
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialRecords.
     */
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * FinancialRecord findFirstOrThrow
   */
  export type FinancialRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecord to fetch.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialRecords.
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialRecords.
     */
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * FinancialRecord findMany
   */
  export type FinancialRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter, which FinancialRecords to fetch.
     */
    where?: FinancialRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialRecords to fetch.
     */
    orderBy?: FinancialRecordOrderByWithRelationInput | FinancialRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialRecords.
     */
    cursor?: FinancialRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialRecords.
     */
    skip?: number
    distinct?: FinancialRecordScalarFieldEnum | FinancialRecordScalarFieldEnum[]
  }

  /**
   * FinancialRecord create
   */
  export type FinancialRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialRecord.
     */
    data: XOR<FinancialRecordCreateInput, FinancialRecordUncheckedCreateInput>
  }

  /**
   * FinancialRecord createMany
   */
  export type FinancialRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialRecords.
     */
    data: FinancialRecordCreateManyInput | FinancialRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialRecord createManyAndReturn
   */
  export type FinancialRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FinancialRecords.
     */
    data: FinancialRecordCreateManyInput | FinancialRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FinancialRecord update
   */
  export type FinancialRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialRecord.
     */
    data: XOR<FinancialRecordUpdateInput, FinancialRecordUncheckedUpdateInput>
    /**
     * Choose, which FinancialRecord to update.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord updateMany
   */
  export type FinancialRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialRecords.
     */
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyInput>
    /**
     * Filter which FinancialRecords to update
     */
    where?: FinancialRecordWhereInput
  }

  /**
   * FinancialRecord upsert
   */
  export type FinancialRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialRecord to update in case it exists.
     */
    where: FinancialRecordWhereUniqueInput
    /**
     * In case the FinancialRecord found by the `where` argument doesn't exist, create a new FinancialRecord with this data.
     */
    create: XOR<FinancialRecordCreateInput, FinancialRecordUncheckedCreateInput>
    /**
     * In case the FinancialRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialRecordUpdateInput, FinancialRecordUncheckedUpdateInput>
  }

  /**
   * FinancialRecord delete
   */
  export type FinancialRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
    /**
     * Filter which FinancialRecord to delete.
     */
    where: FinancialRecordWhereUniqueInput
  }

  /**
   * FinancialRecord deleteMany
   */
  export type FinancialRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialRecords to delete
     */
    where?: FinancialRecordWhereInput
  }

  /**
   * FinancialRecord without action
   */
  export type FinancialRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialRecord
     */
    select?: FinancialRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialRecordInclude<ExtArgs> | null
  }


  /**
   * Model AdmissionApplication
   */

  export type AggregateAdmissionApplication = {
    _count: AdmissionApplicationCountAggregateOutputType | null
    _min: AdmissionApplicationMinAggregateOutputType | null
    _max: AdmissionApplicationMaxAggregateOutputType | null
  }

  export type AdmissionApplicationMinAggregateOutputType = {
    id: string | null
    applicationNumber: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    nationality: string | null
    previousSchool: string | null
    desiredClass: string | null
    academicYear: string | null
    specialNeeds: string | null
    parentId: string | null
    fatherName: string | null
    fatherEmail: string | null
    fatherPhone: string | null
    fatherOccupation: string | null
    motherName: string | null
    motherEmail: string | null
    motherPhone: string | null
    motherOccupation: string | null
    guardianName: string | null
    guardianEmail: string | null
    guardianPhone: string | null
    familyAddress: string | null
    status: $Enums.AdmissionStatus | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionApplicationMaxAggregateOutputType = {
    id: string | null
    applicationNumber: string | null
    firstName: string | null
    lastName: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    nationality: string | null
    previousSchool: string | null
    desiredClass: string | null
    academicYear: string | null
    specialNeeds: string | null
    parentId: string | null
    fatherName: string | null
    fatherEmail: string | null
    fatherPhone: string | null
    fatherOccupation: string | null
    motherName: string | null
    motherEmail: string | null
    motherPhone: string | null
    motherOccupation: string | null
    guardianName: string | null
    guardianEmail: string | null
    guardianPhone: string | null
    familyAddress: string | null
    status: $Enums.AdmissionStatus | null
    submittedAt: Date | null
    reviewedAt: Date | null
    reviewedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionApplicationCountAggregateOutputType = {
    id: number
    applicationNumber: number
    firstName: number
    lastName: number
    dateOfBirth: number
    gender: number
    nationality: number
    previousSchool: number
    desiredClass: number
    academicYear: number
    specialNeeds: number
    parentId: number
    fatherName: number
    fatherEmail: number
    fatherPhone: number
    fatherOccupation: number
    motherName: number
    motherEmail: number
    motherPhone: number
    motherOccupation: number
    guardianName: number
    guardianEmail: number
    guardianPhone: number
    familyAddress: number
    status: number
    submittedAt: number
    reviewedAt: number
    reviewedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionApplicationMinAggregateInputType = {
    id?: true
    applicationNumber?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    nationality?: true
    previousSchool?: true
    desiredClass?: true
    academicYear?: true
    specialNeeds?: true
    parentId?: true
    fatherName?: true
    fatherEmail?: true
    fatherPhone?: true
    fatherOccupation?: true
    motherName?: true
    motherEmail?: true
    motherPhone?: true
    motherOccupation?: true
    guardianName?: true
    guardianEmail?: true
    guardianPhone?: true
    familyAddress?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionApplicationMaxAggregateInputType = {
    id?: true
    applicationNumber?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    nationality?: true
    previousSchool?: true
    desiredClass?: true
    academicYear?: true
    specialNeeds?: true
    parentId?: true
    fatherName?: true
    fatherEmail?: true
    fatherPhone?: true
    fatherOccupation?: true
    motherName?: true
    motherEmail?: true
    motherPhone?: true
    motherOccupation?: true
    guardianName?: true
    guardianEmail?: true
    guardianPhone?: true
    familyAddress?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionApplicationCountAggregateInputType = {
    id?: true
    applicationNumber?: true
    firstName?: true
    lastName?: true
    dateOfBirth?: true
    gender?: true
    nationality?: true
    previousSchool?: true
    desiredClass?: true
    academicYear?: true
    specialNeeds?: true
    parentId?: true
    fatherName?: true
    fatherEmail?: true
    fatherPhone?: true
    fatherOccupation?: true
    motherName?: true
    motherEmail?: true
    motherPhone?: true
    motherOccupation?: true
    guardianName?: true
    guardianEmail?: true
    guardianPhone?: true
    familyAddress?: true
    status?: true
    submittedAt?: true
    reviewedAt?: true
    reviewedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionApplication to aggregate.
     */
    where?: AdmissionApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionApplications to fetch.
     */
    orderBy?: AdmissionApplicationOrderByWithRelationInput | AdmissionApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmissionApplications
    **/
    _count?: true | AdmissionApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionApplicationMaxAggregateInputType
  }

  export type GetAdmissionApplicationAggregateType<T extends AdmissionApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissionApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissionApplication[P]>
      : GetScalarType<T[P], AggregateAdmissionApplication[P]>
  }




  export type AdmissionApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionApplicationWhereInput
    orderBy?: AdmissionApplicationOrderByWithAggregationInput | AdmissionApplicationOrderByWithAggregationInput[]
    by: AdmissionApplicationScalarFieldEnum[] | AdmissionApplicationScalarFieldEnum
    having?: AdmissionApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionApplicationCountAggregateInputType | true
    _min?: AdmissionApplicationMinAggregateInputType
    _max?: AdmissionApplicationMaxAggregateInputType
  }

  export type AdmissionApplicationGroupByOutputType = {
    id: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date
    gender: $Enums.Gender
    nationality: string
    previousSchool: string | null
    desiredClass: string
    academicYear: string
    specialNeeds: string | null
    parentId: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation: string | null
    guardianName: string | null
    guardianEmail: string | null
    guardianPhone: string | null
    familyAddress: string
    status: $Enums.AdmissionStatus
    submittedAt: Date
    reviewedAt: Date | null
    reviewedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdmissionApplicationCountAggregateOutputType | null
    _min: AdmissionApplicationMinAggregateOutputType | null
    _max: AdmissionApplicationMaxAggregateOutputType | null
  }

  type GetAdmissionApplicationGroupByPayload<T extends AdmissionApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionApplicationGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    nationality?: boolean
    previousSchool?: boolean
    desiredClass?: boolean
    academicYear?: boolean
    specialNeeds?: boolean
    parentId?: boolean
    fatherName?: boolean
    fatherEmail?: boolean
    fatherPhone?: boolean
    fatherOccupation?: boolean
    motherName?: boolean
    motherEmail?: boolean
    motherPhone?: boolean
    motherOccupation?: boolean
    guardianName?: boolean
    guardianEmail?: boolean
    guardianPhone?: boolean
    familyAddress?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | AdmissionApplication$parentArgs<ExtArgs>
    documents?: boolean | AdmissionApplication$documentsArgs<ExtArgs>
    stepProgress?: boolean | AdmissionApplication$stepProgressArgs<ExtArgs>
    _count?: boolean | AdmissionApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionApplication"]>

  export type AdmissionApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    nationality?: boolean
    previousSchool?: boolean
    desiredClass?: boolean
    academicYear?: boolean
    specialNeeds?: boolean
    parentId?: boolean
    fatherName?: boolean
    fatherEmail?: boolean
    fatherPhone?: boolean
    fatherOccupation?: boolean
    motherName?: boolean
    motherEmail?: boolean
    motherPhone?: boolean
    motherOccupation?: boolean
    guardianName?: boolean
    guardianEmail?: boolean
    guardianPhone?: boolean
    familyAddress?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | AdmissionApplication$parentArgs<ExtArgs>
  }, ExtArgs["result"]["admissionApplication"]>

  export type AdmissionApplicationSelectScalar = {
    id?: boolean
    applicationNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    nationality?: boolean
    previousSchool?: boolean
    desiredClass?: boolean
    academicYear?: boolean
    specialNeeds?: boolean
    parentId?: boolean
    fatherName?: boolean
    fatherEmail?: boolean
    fatherPhone?: boolean
    fatherOccupation?: boolean
    motherName?: boolean
    motherEmail?: boolean
    motherPhone?: boolean
    motherOccupation?: boolean
    guardianName?: boolean
    guardianEmail?: boolean
    guardianPhone?: boolean
    familyAddress?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedAt?: boolean
    reviewedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | AdmissionApplication$parentArgs<ExtArgs>
    documents?: boolean | AdmissionApplication$documentsArgs<ExtArgs>
    stepProgress?: boolean | AdmissionApplication$stepProgressArgs<ExtArgs>
    _count?: boolean | AdmissionApplicationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdmissionApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | AdmissionApplication$parentArgs<ExtArgs>
  }

  export type $AdmissionApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmissionApplication"
    objects: {
      parent: Prisma.$ParentPayload<ExtArgs> | null
      documents: Prisma.$FileAttachmentPayload<ExtArgs>[]
      stepProgress: Prisma.$AdmissionStepProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationNumber: string
      firstName: string
      lastName: string
      dateOfBirth: Date
      gender: $Enums.Gender
      nationality: string
      previousSchool: string | null
      desiredClass: string
      academicYear: string
      specialNeeds: string | null
      parentId: string | null
      fatherName: string
      fatherEmail: string
      fatherPhone: string
      fatherOccupation: string | null
      motherName: string
      motherEmail: string
      motherPhone: string
      motherOccupation: string | null
      guardianName: string | null
      guardianEmail: string | null
      guardianPhone: string | null
      familyAddress: string
      status: $Enums.AdmissionStatus
      submittedAt: Date
      reviewedAt: Date | null
      reviewedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admissionApplication"]>
    composites: {}
  }

  type AdmissionApplicationGetPayload<S extends boolean | null | undefined | AdmissionApplicationDefaultArgs> = $Result.GetResult<Prisma.$AdmissionApplicationPayload, S>

  type AdmissionApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionApplicationCountAggregateInputType | true
    }

  export interface AdmissionApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmissionApplication'], meta: { name: 'AdmissionApplication' } }
    /**
     * Find zero or one AdmissionApplication that matches the filter.
     * @param {AdmissionApplicationFindUniqueArgs} args - Arguments to find a AdmissionApplication
     * @example
     * // Get one AdmissionApplication
     * const admissionApplication = await prisma.admissionApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionApplicationFindUniqueArgs>(args: SelectSubset<T, AdmissionApplicationFindUniqueArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdmissionApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionApplicationFindUniqueOrThrowArgs} args - Arguments to find a AdmissionApplication
     * @example
     * // Get one AdmissionApplication
     * const admissionApplication = await prisma.admissionApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdmissionApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionApplicationFindFirstArgs} args - Arguments to find a AdmissionApplication
     * @example
     * // Get one AdmissionApplication
     * const admissionApplication = await prisma.admissionApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionApplicationFindFirstArgs>(args?: SelectSubset<T, AdmissionApplicationFindFirstArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdmissionApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionApplicationFindFirstOrThrowArgs} args - Arguments to find a AdmissionApplication
     * @example
     * // Get one AdmissionApplication
     * const admissionApplication = await prisma.admissionApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdmissionApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmissionApplications
     * const admissionApplications = await prisma.admissionApplication.findMany()
     * 
     * // Get first 10 AdmissionApplications
     * const admissionApplications = await prisma.admissionApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionApplicationWithIdOnly = await prisma.admissionApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionApplicationFindManyArgs>(args?: SelectSubset<T, AdmissionApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdmissionApplication.
     * @param {AdmissionApplicationCreateArgs} args - Arguments to create a AdmissionApplication.
     * @example
     * // Create one AdmissionApplication
     * const AdmissionApplication = await prisma.admissionApplication.create({
     *   data: {
     *     // ... data to create a AdmissionApplication
     *   }
     * })
     * 
     */
    create<T extends AdmissionApplicationCreateArgs>(args: SelectSubset<T, AdmissionApplicationCreateArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdmissionApplications.
     * @param {AdmissionApplicationCreateManyArgs} args - Arguments to create many AdmissionApplications.
     * @example
     * // Create many AdmissionApplications
     * const admissionApplication = await prisma.admissionApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionApplicationCreateManyArgs>(args?: SelectSubset<T, AdmissionApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdmissionApplications and returns the data saved in the database.
     * @param {AdmissionApplicationCreateManyAndReturnArgs} args - Arguments to create many AdmissionApplications.
     * @example
     * // Create many AdmissionApplications
     * const admissionApplication = await prisma.admissionApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdmissionApplications and only return the `id`
     * const admissionApplicationWithIdOnly = await prisma.admissionApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdmissionApplication.
     * @param {AdmissionApplicationDeleteArgs} args - Arguments to delete one AdmissionApplication.
     * @example
     * // Delete one AdmissionApplication
     * const AdmissionApplication = await prisma.admissionApplication.delete({
     *   where: {
     *     // ... filter to delete one AdmissionApplication
     *   }
     * })
     * 
     */
    delete<T extends AdmissionApplicationDeleteArgs>(args: SelectSubset<T, AdmissionApplicationDeleteArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdmissionApplication.
     * @param {AdmissionApplicationUpdateArgs} args - Arguments to update one AdmissionApplication.
     * @example
     * // Update one AdmissionApplication
     * const admissionApplication = await prisma.admissionApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionApplicationUpdateArgs>(args: SelectSubset<T, AdmissionApplicationUpdateArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdmissionApplications.
     * @param {AdmissionApplicationDeleteManyArgs} args - Arguments to filter AdmissionApplications to delete.
     * @example
     * // Delete a few AdmissionApplications
     * const { count } = await prisma.admissionApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionApplicationDeleteManyArgs>(args?: SelectSubset<T, AdmissionApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmissionApplications
     * const admissionApplication = await prisma.admissionApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionApplicationUpdateManyArgs>(args: SelectSubset<T, AdmissionApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmissionApplication.
     * @param {AdmissionApplicationUpsertArgs} args - Arguments to update or create a AdmissionApplication.
     * @example
     * // Update or create a AdmissionApplication
     * const admissionApplication = await prisma.admissionApplication.upsert({
     *   create: {
     *     // ... data to create a AdmissionApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmissionApplication we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionApplicationUpsertArgs>(args: SelectSubset<T, AdmissionApplicationUpsertArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdmissionApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionApplicationCountArgs} args - Arguments to filter AdmissionApplications to count.
     * @example
     * // Count the number of AdmissionApplications
     * const count = await prisma.admissionApplication.count({
     *   where: {
     *     // ... the filter for the AdmissionApplications we want to count
     *   }
     * })
    **/
    count<T extends AdmissionApplicationCountArgs>(
      args?: Subset<T, AdmissionApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmissionApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionApplicationAggregateArgs>(args: Subset<T, AdmissionApplicationAggregateArgs>): Prisma.PrismaPromise<GetAdmissionApplicationAggregateType<T>>

    /**
     * Group by AdmissionApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionApplicationGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmissionApplication model
   */
  readonly fields: AdmissionApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmissionApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends AdmissionApplication$parentArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionApplication$parentArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    documents<T extends AdmissionApplication$documentsArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionApplication$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findMany"> | Null>
    stepProgress<T extends AdmissionApplication$stepProgressArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionApplication$stepProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmissionApplication model
   */ 
  interface AdmissionApplicationFieldRefs {
    readonly id: FieldRef<"AdmissionApplication", 'String'>
    readonly applicationNumber: FieldRef<"AdmissionApplication", 'String'>
    readonly firstName: FieldRef<"AdmissionApplication", 'String'>
    readonly lastName: FieldRef<"AdmissionApplication", 'String'>
    readonly dateOfBirth: FieldRef<"AdmissionApplication", 'DateTime'>
    readonly gender: FieldRef<"AdmissionApplication", 'Gender'>
    readonly nationality: FieldRef<"AdmissionApplication", 'String'>
    readonly previousSchool: FieldRef<"AdmissionApplication", 'String'>
    readonly desiredClass: FieldRef<"AdmissionApplication", 'String'>
    readonly academicYear: FieldRef<"AdmissionApplication", 'String'>
    readonly specialNeeds: FieldRef<"AdmissionApplication", 'String'>
    readonly parentId: FieldRef<"AdmissionApplication", 'String'>
    readonly fatherName: FieldRef<"AdmissionApplication", 'String'>
    readonly fatherEmail: FieldRef<"AdmissionApplication", 'String'>
    readonly fatherPhone: FieldRef<"AdmissionApplication", 'String'>
    readonly fatherOccupation: FieldRef<"AdmissionApplication", 'String'>
    readonly motherName: FieldRef<"AdmissionApplication", 'String'>
    readonly motherEmail: FieldRef<"AdmissionApplication", 'String'>
    readonly motherPhone: FieldRef<"AdmissionApplication", 'String'>
    readonly motherOccupation: FieldRef<"AdmissionApplication", 'String'>
    readonly guardianName: FieldRef<"AdmissionApplication", 'String'>
    readonly guardianEmail: FieldRef<"AdmissionApplication", 'String'>
    readonly guardianPhone: FieldRef<"AdmissionApplication", 'String'>
    readonly familyAddress: FieldRef<"AdmissionApplication", 'String'>
    readonly status: FieldRef<"AdmissionApplication", 'AdmissionStatus'>
    readonly submittedAt: FieldRef<"AdmissionApplication", 'DateTime'>
    readonly reviewedAt: FieldRef<"AdmissionApplication", 'DateTime'>
    readonly reviewedBy: FieldRef<"AdmissionApplication", 'String'>
    readonly notes: FieldRef<"AdmissionApplication", 'String'>
    readonly createdAt: FieldRef<"AdmissionApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"AdmissionApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdmissionApplication findUnique
   */
  export type AdmissionApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionApplication to fetch.
     */
    where: AdmissionApplicationWhereUniqueInput
  }

  /**
   * AdmissionApplication findUniqueOrThrow
   */
  export type AdmissionApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionApplication to fetch.
     */
    where: AdmissionApplicationWhereUniqueInput
  }

  /**
   * AdmissionApplication findFirst
   */
  export type AdmissionApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionApplication to fetch.
     */
    where?: AdmissionApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionApplications to fetch.
     */
    orderBy?: AdmissionApplicationOrderByWithRelationInput | AdmissionApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionApplications.
     */
    cursor?: AdmissionApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionApplications.
     */
    distinct?: AdmissionApplicationScalarFieldEnum | AdmissionApplicationScalarFieldEnum[]
  }

  /**
   * AdmissionApplication findFirstOrThrow
   */
  export type AdmissionApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionApplication to fetch.
     */
    where?: AdmissionApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionApplications to fetch.
     */
    orderBy?: AdmissionApplicationOrderByWithRelationInput | AdmissionApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionApplications.
     */
    cursor?: AdmissionApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionApplications.
     */
    distinct?: AdmissionApplicationScalarFieldEnum | AdmissionApplicationScalarFieldEnum[]
  }

  /**
   * AdmissionApplication findMany
   */
  export type AdmissionApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionApplications to fetch.
     */
    where?: AdmissionApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionApplications to fetch.
     */
    orderBy?: AdmissionApplicationOrderByWithRelationInput | AdmissionApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmissionApplications.
     */
    cursor?: AdmissionApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionApplications.
     */
    skip?: number
    distinct?: AdmissionApplicationScalarFieldEnum | AdmissionApplicationScalarFieldEnum[]
  }

  /**
   * AdmissionApplication create
   */
  export type AdmissionApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmissionApplication.
     */
    data: XOR<AdmissionApplicationCreateInput, AdmissionApplicationUncheckedCreateInput>
  }

  /**
   * AdmissionApplication createMany
   */
  export type AdmissionApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmissionApplications.
     */
    data: AdmissionApplicationCreateManyInput | AdmissionApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionApplication createManyAndReturn
   */
  export type AdmissionApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdmissionApplications.
     */
    data: AdmissionApplicationCreateManyInput | AdmissionApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdmissionApplication update
   */
  export type AdmissionApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmissionApplication.
     */
    data: XOR<AdmissionApplicationUpdateInput, AdmissionApplicationUncheckedUpdateInput>
    /**
     * Choose, which AdmissionApplication to update.
     */
    where: AdmissionApplicationWhereUniqueInput
  }

  /**
   * AdmissionApplication updateMany
   */
  export type AdmissionApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmissionApplications.
     */
    data: XOR<AdmissionApplicationUpdateManyMutationInput, AdmissionApplicationUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionApplications to update
     */
    where?: AdmissionApplicationWhereInput
  }

  /**
   * AdmissionApplication upsert
   */
  export type AdmissionApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmissionApplication to update in case it exists.
     */
    where: AdmissionApplicationWhereUniqueInput
    /**
     * In case the AdmissionApplication found by the `where` argument doesn't exist, create a new AdmissionApplication with this data.
     */
    create: XOR<AdmissionApplicationCreateInput, AdmissionApplicationUncheckedCreateInput>
    /**
     * In case the AdmissionApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionApplicationUpdateInput, AdmissionApplicationUncheckedUpdateInput>
  }

  /**
   * AdmissionApplication delete
   */
  export type AdmissionApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    /**
     * Filter which AdmissionApplication to delete.
     */
    where: AdmissionApplicationWhereUniqueInput
  }

  /**
   * AdmissionApplication deleteMany
   */
  export type AdmissionApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionApplications to delete
     */
    where?: AdmissionApplicationWhereInput
  }

  /**
   * AdmissionApplication.parent
   */
  export type AdmissionApplication$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * AdmissionApplication.documents
   */
  export type AdmissionApplication$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    where?: FileAttachmentWhereInput
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    cursor?: FileAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileAttachmentScalarFieldEnum | FileAttachmentScalarFieldEnum[]
  }

  /**
   * AdmissionApplication.stepProgress
   */
  export type AdmissionApplication$stepProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    where?: AdmissionStepProgressWhereInput
    orderBy?: AdmissionStepProgressOrderByWithRelationInput | AdmissionStepProgressOrderByWithRelationInput[]
    cursor?: AdmissionStepProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionStepProgressScalarFieldEnum | AdmissionStepProgressScalarFieldEnum[]
  }

  /**
   * AdmissionApplication without action
   */
  export type AdmissionApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
  }


  /**
   * Model AdmissionStepProgress
   */

  export type AggregateAdmissionStepProgress = {
    _count: AdmissionStepProgressCountAggregateOutputType | null
    _min: AdmissionStepProgressMinAggregateOutputType | null
    _max: AdmissionStepProgressMaxAggregateOutputType | null
  }

  export type AdmissionStepProgressMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    stepName: string | null
    status: $Enums.StepStatus | null
    startedAt: Date | null
    completedAt: Date | null
    assignedTo: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionStepProgressMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    stepName: string | null
    status: $Enums.StepStatus | null
    startedAt: Date | null
    completedAt: Date | null
    assignedTo: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdmissionStepProgressCountAggregateOutputType = {
    id: number
    applicationId: number
    stepName: number
    status: number
    startedAt: number
    completedAt: number
    assignedTo: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdmissionStepProgressMinAggregateInputType = {
    id?: true
    applicationId?: true
    stepName?: true
    status?: true
    startedAt?: true
    completedAt?: true
    assignedTo?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionStepProgressMaxAggregateInputType = {
    id?: true
    applicationId?: true
    stepName?: true
    status?: true
    startedAt?: true
    completedAt?: true
    assignedTo?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdmissionStepProgressCountAggregateInputType = {
    id?: true
    applicationId?: true
    stepName?: true
    status?: true
    startedAt?: true
    completedAt?: true
    assignedTo?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdmissionStepProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionStepProgress to aggregate.
     */
    where?: AdmissionStepProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionStepProgresses to fetch.
     */
    orderBy?: AdmissionStepProgressOrderByWithRelationInput | AdmissionStepProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionStepProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionStepProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionStepProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmissionStepProgresses
    **/
    _count?: true | AdmissionStepProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionStepProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionStepProgressMaxAggregateInputType
  }

  export type GetAdmissionStepProgressAggregateType<T extends AdmissionStepProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissionStepProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissionStepProgress[P]>
      : GetScalarType<T[P], AggregateAdmissionStepProgress[P]>
  }




  export type AdmissionStepProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionStepProgressWhereInput
    orderBy?: AdmissionStepProgressOrderByWithAggregationInput | AdmissionStepProgressOrderByWithAggregationInput[]
    by: AdmissionStepProgressScalarFieldEnum[] | AdmissionStepProgressScalarFieldEnum
    having?: AdmissionStepProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionStepProgressCountAggregateInputType | true
    _min?: AdmissionStepProgressMinAggregateInputType
    _max?: AdmissionStepProgressMaxAggregateInputType
  }

  export type AdmissionStepProgressGroupByOutputType = {
    id: string
    applicationId: string
    stepName: string
    status: $Enums.StepStatus
    startedAt: Date | null
    completedAt: Date | null
    assignedTo: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdmissionStepProgressCountAggregateOutputType | null
    _min: AdmissionStepProgressMinAggregateOutputType | null
    _max: AdmissionStepProgressMaxAggregateOutputType | null
  }

  type GetAdmissionStepProgressGroupByPayload<T extends AdmissionStepProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionStepProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionStepProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionStepProgressGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionStepProgressGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionStepProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    stepName?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    assignedTo?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | AdmissionApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionStepProgress"]>

  export type AdmissionStepProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    stepName?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    assignedTo?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    application?: boolean | AdmissionApplicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionStepProgress"]>

  export type AdmissionStepProgressSelectScalar = {
    id?: boolean
    applicationId?: boolean
    stepName?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    assignedTo?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdmissionStepProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | AdmissionApplicationDefaultArgs<ExtArgs>
  }
  export type AdmissionStepProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | AdmissionApplicationDefaultArgs<ExtArgs>
  }

  export type $AdmissionStepProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmissionStepProgress"
    objects: {
      application: Prisma.$AdmissionApplicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      stepName: string
      status: $Enums.StepStatus
      startedAt: Date | null
      completedAt: Date | null
      assignedTo: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admissionStepProgress"]>
    composites: {}
  }

  type AdmissionStepProgressGetPayload<S extends boolean | null | undefined | AdmissionStepProgressDefaultArgs> = $Result.GetResult<Prisma.$AdmissionStepProgressPayload, S>

  type AdmissionStepProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionStepProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionStepProgressCountAggregateInputType | true
    }

  export interface AdmissionStepProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmissionStepProgress'], meta: { name: 'AdmissionStepProgress' } }
    /**
     * Find zero or one AdmissionStepProgress that matches the filter.
     * @param {AdmissionStepProgressFindUniqueArgs} args - Arguments to find a AdmissionStepProgress
     * @example
     * // Get one AdmissionStepProgress
     * const admissionStepProgress = await prisma.admissionStepProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionStepProgressFindUniqueArgs>(args: SelectSubset<T, AdmissionStepProgressFindUniqueArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdmissionStepProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionStepProgressFindUniqueOrThrowArgs} args - Arguments to find a AdmissionStepProgress
     * @example
     * // Get one AdmissionStepProgress
     * const admissionStepProgress = await prisma.admissionStepProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionStepProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionStepProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdmissionStepProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionStepProgressFindFirstArgs} args - Arguments to find a AdmissionStepProgress
     * @example
     * // Get one AdmissionStepProgress
     * const admissionStepProgress = await prisma.admissionStepProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionStepProgressFindFirstArgs>(args?: SelectSubset<T, AdmissionStepProgressFindFirstArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdmissionStepProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionStepProgressFindFirstOrThrowArgs} args - Arguments to find a AdmissionStepProgress
     * @example
     * // Get one AdmissionStepProgress
     * const admissionStepProgress = await prisma.admissionStepProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionStepProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionStepProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdmissionStepProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionStepProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmissionStepProgresses
     * const admissionStepProgresses = await prisma.admissionStepProgress.findMany()
     * 
     * // Get first 10 AdmissionStepProgresses
     * const admissionStepProgresses = await prisma.admissionStepProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionStepProgressWithIdOnly = await prisma.admissionStepProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionStepProgressFindManyArgs>(args?: SelectSubset<T, AdmissionStepProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdmissionStepProgress.
     * @param {AdmissionStepProgressCreateArgs} args - Arguments to create a AdmissionStepProgress.
     * @example
     * // Create one AdmissionStepProgress
     * const AdmissionStepProgress = await prisma.admissionStepProgress.create({
     *   data: {
     *     // ... data to create a AdmissionStepProgress
     *   }
     * })
     * 
     */
    create<T extends AdmissionStepProgressCreateArgs>(args: SelectSubset<T, AdmissionStepProgressCreateArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdmissionStepProgresses.
     * @param {AdmissionStepProgressCreateManyArgs} args - Arguments to create many AdmissionStepProgresses.
     * @example
     * // Create many AdmissionStepProgresses
     * const admissionStepProgress = await prisma.admissionStepProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionStepProgressCreateManyArgs>(args?: SelectSubset<T, AdmissionStepProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdmissionStepProgresses and returns the data saved in the database.
     * @param {AdmissionStepProgressCreateManyAndReturnArgs} args - Arguments to create many AdmissionStepProgresses.
     * @example
     * // Create many AdmissionStepProgresses
     * const admissionStepProgress = await prisma.admissionStepProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdmissionStepProgresses and only return the `id`
     * const admissionStepProgressWithIdOnly = await prisma.admissionStepProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionStepProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionStepProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdmissionStepProgress.
     * @param {AdmissionStepProgressDeleteArgs} args - Arguments to delete one AdmissionStepProgress.
     * @example
     * // Delete one AdmissionStepProgress
     * const AdmissionStepProgress = await prisma.admissionStepProgress.delete({
     *   where: {
     *     // ... filter to delete one AdmissionStepProgress
     *   }
     * })
     * 
     */
    delete<T extends AdmissionStepProgressDeleteArgs>(args: SelectSubset<T, AdmissionStepProgressDeleteArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdmissionStepProgress.
     * @param {AdmissionStepProgressUpdateArgs} args - Arguments to update one AdmissionStepProgress.
     * @example
     * // Update one AdmissionStepProgress
     * const admissionStepProgress = await prisma.admissionStepProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionStepProgressUpdateArgs>(args: SelectSubset<T, AdmissionStepProgressUpdateArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdmissionStepProgresses.
     * @param {AdmissionStepProgressDeleteManyArgs} args - Arguments to filter AdmissionStepProgresses to delete.
     * @example
     * // Delete a few AdmissionStepProgresses
     * const { count } = await prisma.admissionStepProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionStepProgressDeleteManyArgs>(args?: SelectSubset<T, AdmissionStepProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionStepProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionStepProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmissionStepProgresses
     * const admissionStepProgress = await prisma.admissionStepProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionStepProgressUpdateManyArgs>(args: SelectSubset<T, AdmissionStepProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmissionStepProgress.
     * @param {AdmissionStepProgressUpsertArgs} args - Arguments to update or create a AdmissionStepProgress.
     * @example
     * // Update or create a AdmissionStepProgress
     * const admissionStepProgress = await prisma.admissionStepProgress.upsert({
     *   create: {
     *     // ... data to create a AdmissionStepProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmissionStepProgress we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionStepProgressUpsertArgs>(args: SelectSubset<T, AdmissionStepProgressUpsertArgs<ExtArgs>>): Prisma__AdmissionStepProgressClient<$Result.GetResult<Prisma.$AdmissionStepProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdmissionStepProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionStepProgressCountArgs} args - Arguments to filter AdmissionStepProgresses to count.
     * @example
     * // Count the number of AdmissionStepProgresses
     * const count = await prisma.admissionStepProgress.count({
     *   where: {
     *     // ... the filter for the AdmissionStepProgresses we want to count
     *   }
     * })
    **/
    count<T extends AdmissionStepProgressCountArgs>(
      args?: Subset<T, AdmissionStepProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionStepProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmissionStepProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionStepProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionStepProgressAggregateArgs>(args: Subset<T, AdmissionStepProgressAggregateArgs>): Prisma.PrismaPromise<GetAdmissionStepProgressAggregateType<T>>

    /**
     * Group by AdmissionStepProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionStepProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionStepProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionStepProgressGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionStepProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionStepProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionStepProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmissionStepProgress model
   */
  readonly fields: AdmissionStepProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmissionStepProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionStepProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends AdmissionApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionApplicationDefaultArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmissionStepProgress model
   */ 
  interface AdmissionStepProgressFieldRefs {
    readonly id: FieldRef<"AdmissionStepProgress", 'String'>
    readonly applicationId: FieldRef<"AdmissionStepProgress", 'String'>
    readonly stepName: FieldRef<"AdmissionStepProgress", 'String'>
    readonly status: FieldRef<"AdmissionStepProgress", 'StepStatus'>
    readonly startedAt: FieldRef<"AdmissionStepProgress", 'DateTime'>
    readonly completedAt: FieldRef<"AdmissionStepProgress", 'DateTime'>
    readonly assignedTo: FieldRef<"AdmissionStepProgress", 'String'>
    readonly notes: FieldRef<"AdmissionStepProgress", 'String'>
    readonly createdAt: FieldRef<"AdmissionStepProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"AdmissionStepProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdmissionStepProgress findUnique
   */
  export type AdmissionStepProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionStepProgress to fetch.
     */
    where: AdmissionStepProgressWhereUniqueInput
  }

  /**
   * AdmissionStepProgress findUniqueOrThrow
   */
  export type AdmissionStepProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionStepProgress to fetch.
     */
    where: AdmissionStepProgressWhereUniqueInput
  }

  /**
   * AdmissionStepProgress findFirst
   */
  export type AdmissionStepProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionStepProgress to fetch.
     */
    where?: AdmissionStepProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionStepProgresses to fetch.
     */
    orderBy?: AdmissionStepProgressOrderByWithRelationInput | AdmissionStepProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionStepProgresses.
     */
    cursor?: AdmissionStepProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionStepProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionStepProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionStepProgresses.
     */
    distinct?: AdmissionStepProgressScalarFieldEnum | AdmissionStepProgressScalarFieldEnum[]
  }

  /**
   * AdmissionStepProgress findFirstOrThrow
   */
  export type AdmissionStepProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionStepProgress to fetch.
     */
    where?: AdmissionStepProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionStepProgresses to fetch.
     */
    orderBy?: AdmissionStepProgressOrderByWithRelationInput | AdmissionStepProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionStepProgresses.
     */
    cursor?: AdmissionStepProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionStepProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionStepProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionStepProgresses.
     */
    distinct?: AdmissionStepProgressScalarFieldEnum | AdmissionStepProgressScalarFieldEnum[]
  }

  /**
   * AdmissionStepProgress findMany
   */
  export type AdmissionStepProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionStepProgresses to fetch.
     */
    where?: AdmissionStepProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionStepProgresses to fetch.
     */
    orderBy?: AdmissionStepProgressOrderByWithRelationInput | AdmissionStepProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmissionStepProgresses.
     */
    cursor?: AdmissionStepProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionStepProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionStepProgresses.
     */
    skip?: number
    distinct?: AdmissionStepProgressScalarFieldEnum | AdmissionStepProgressScalarFieldEnum[]
  }

  /**
   * AdmissionStepProgress create
   */
  export type AdmissionStepProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmissionStepProgress.
     */
    data: XOR<AdmissionStepProgressCreateInput, AdmissionStepProgressUncheckedCreateInput>
  }

  /**
   * AdmissionStepProgress createMany
   */
  export type AdmissionStepProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmissionStepProgresses.
     */
    data: AdmissionStepProgressCreateManyInput | AdmissionStepProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionStepProgress createManyAndReturn
   */
  export type AdmissionStepProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdmissionStepProgresses.
     */
    data: AdmissionStepProgressCreateManyInput | AdmissionStepProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdmissionStepProgress update
   */
  export type AdmissionStepProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmissionStepProgress.
     */
    data: XOR<AdmissionStepProgressUpdateInput, AdmissionStepProgressUncheckedUpdateInput>
    /**
     * Choose, which AdmissionStepProgress to update.
     */
    where: AdmissionStepProgressWhereUniqueInput
  }

  /**
   * AdmissionStepProgress updateMany
   */
  export type AdmissionStepProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmissionStepProgresses.
     */
    data: XOR<AdmissionStepProgressUpdateManyMutationInput, AdmissionStepProgressUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionStepProgresses to update
     */
    where?: AdmissionStepProgressWhereInput
  }

  /**
   * AdmissionStepProgress upsert
   */
  export type AdmissionStepProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmissionStepProgress to update in case it exists.
     */
    where: AdmissionStepProgressWhereUniqueInput
    /**
     * In case the AdmissionStepProgress found by the `where` argument doesn't exist, create a new AdmissionStepProgress with this data.
     */
    create: XOR<AdmissionStepProgressCreateInput, AdmissionStepProgressUncheckedCreateInput>
    /**
     * In case the AdmissionStepProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionStepProgressUpdateInput, AdmissionStepProgressUncheckedUpdateInput>
  }

  /**
   * AdmissionStepProgress delete
   */
  export type AdmissionStepProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
    /**
     * Filter which AdmissionStepProgress to delete.
     */
    where: AdmissionStepProgressWhereUniqueInput
  }

  /**
   * AdmissionStepProgress deleteMany
   */
  export type AdmissionStepProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionStepProgresses to delete
     */
    where?: AdmissionStepProgressWhereInput
  }

  /**
   * AdmissionStepProgress without action
   */
  export type AdmissionStepProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionStepProgress
     */
    select?: AdmissionStepProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionStepProgressInclude<ExtArgs> | null
  }


  /**
   * Model LearningResource
   */

  export type AggregateLearningResource = {
    _count: LearningResourceCountAggregateOutputType | null
    _avg: LearningResourceAvgAggregateOutputType | null
    _sum: LearningResourceSumAggregateOutputType | null
    _min: LearningResourceMinAggregateOutputType | null
    _max: LearningResourceMaxAggregateOutputType | null
  }

  export type LearningResourceAvgAggregateOutputType = {
    duration: number | null
  }

  export type LearningResourceSumAggregateOutputType = {
    duration: number | null
  }

  export type LearningResourceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.ResourceType | null
    subjectId: string | null
    level: string | null
    url: string | null
    thumbnail: string | null
    duration: number | null
    createdById: string | null
    accessLevel: $Enums.AccessLevel | null
    downloadable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningResourceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.ResourceType | null
    subjectId: string | null
    level: string | null
    url: string | null
    thumbnail: string | null
    duration: number | null
    createdById: string | null
    accessLevel: $Enums.AccessLevel | null
    downloadable: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LearningResourceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    subjectId: number
    level: number
    url: number
    thumbnail: number
    duration: number
    tags: number
    createdById: number
    accessLevel: number
    downloadable: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LearningResourceAvgAggregateInputType = {
    duration?: true
  }

  export type LearningResourceSumAggregateInputType = {
    duration?: true
  }

  export type LearningResourceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    subjectId?: true
    level?: true
    url?: true
    thumbnail?: true
    duration?: true
    createdById?: true
    accessLevel?: true
    downloadable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningResourceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    subjectId?: true
    level?: true
    url?: true
    thumbnail?: true
    duration?: true
    createdById?: true
    accessLevel?: true
    downloadable?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LearningResourceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    subjectId?: true
    level?: true
    url?: true
    thumbnail?: true
    duration?: true
    tags?: true
    createdById?: true
    accessLevel?: true
    downloadable?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LearningResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningResource to aggregate.
     */
    where?: LearningResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningResources to fetch.
     */
    orderBy?: LearningResourceOrderByWithRelationInput | LearningResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningResources
    **/
    _count?: true | LearningResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningResourceMaxAggregateInputType
  }

  export type GetLearningResourceAggregateType<T extends LearningResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningResource[P]>
      : GetScalarType<T[P], AggregateLearningResource[P]>
  }




  export type LearningResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningResourceWhereInput
    orderBy?: LearningResourceOrderByWithAggregationInput | LearningResourceOrderByWithAggregationInput[]
    by: LearningResourceScalarFieldEnum[] | LearningResourceScalarFieldEnum
    having?: LearningResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningResourceCountAggregateInputType | true
    _avg?: LearningResourceAvgAggregateInputType
    _sum?: LearningResourceSumAggregateInputType
    _min?: LearningResourceMinAggregateInputType
    _max?: LearningResourceMaxAggregateInputType
  }

  export type LearningResourceGroupByOutputType = {
    id: string
    title: string
    description: string
    type: $Enums.ResourceType
    subjectId: string
    level: string
    url: string
    thumbnail: string | null
    duration: number | null
    tags: string[]
    createdById: string
    accessLevel: $Enums.AccessLevel
    downloadable: boolean
    createdAt: Date
    updatedAt: Date
    _count: LearningResourceCountAggregateOutputType | null
    _avg: LearningResourceAvgAggregateOutputType | null
    _sum: LearningResourceSumAggregateOutputType | null
    _min: LearningResourceMinAggregateOutputType | null
    _max: LearningResourceMaxAggregateOutputType | null
  }

  type GetLearningResourceGroupByPayload<T extends LearningResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningResourceGroupByOutputType[P]>
            : GetScalarType<T[P], LearningResourceGroupByOutputType[P]>
        }
      >
    >


  export type LearningResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    subjectId?: boolean
    level?: boolean
    url?: boolean
    thumbnail?: boolean
    duration?: boolean
    tags?: boolean
    createdById?: boolean
    accessLevel?: boolean
    downloadable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningResource"]>

  export type LearningResourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    subjectId?: boolean
    level?: boolean
    url?: boolean
    thumbnail?: boolean
    duration?: boolean
    tags?: boolean
    createdById?: boolean
    accessLevel?: boolean
    downloadable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningResource"]>

  export type LearningResourceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    subjectId?: boolean
    level?: boolean
    url?: boolean
    thumbnail?: boolean
    duration?: boolean
    tags?: boolean
    createdById?: boolean
    accessLevel?: boolean
    downloadable?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LearningResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type LearningResourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    createdBy?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $LearningResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningResource"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs>
      createdBy: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: $Enums.ResourceType
      subjectId: string
      level: string
      url: string
      thumbnail: string | null
      duration: number | null
      tags: string[]
      createdById: string
      accessLevel: $Enums.AccessLevel
      downloadable: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["learningResource"]>
    composites: {}
  }

  type LearningResourceGetPayload<S extends boolean | null | undefined | LearningResourceDefaultArgs> = $Result.GetResult<Prisma.$LearningResourcePayload, S>

  type LearningResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningResourceCountAggregateInputType | true
    }

  export interface LearningResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningResource'], meta: { name: 'LearningResource' } }
    /**
     * Find zero or one LearningResource that matches the filter.
     * @param {LearningResourceFindUniqueArgs} args - Arguments to find a LearningResource
     * @example
     * // Get one LearningResource
     * const learningResource = await prisma.learningResource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningResourceFindUniqueArgs>(args: SelectSubset<T, LearningResourceFindUniqueArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningResource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningResourceFindUniqueOrThrowArgs} args - Arguments to find a LearningResource
     * @example
     * // Get one LearningResource
     * const learningResource = await prisma.learningResource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningResource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningResourceFindFirstArgs} args - Arguments to find a LearningResource
     * @example
     * // Get one LearningResource
     * const learningResource = await prisma.learningResource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningResourceFindFirstArgs>(args?: SelectSubset<T, LearningResourceFindFirstArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningResource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningResourceFindFirstOrThrowArgs} args - Arguments to find a LearningResource
     * @example
     * // Get one LearningResource
     * const learningResource = await prisma.learningResource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningResources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningResources
     * const learningResources = await prisma.learningResource.findMany()
     * 
     * // Get first 10 LearningResources
     * const learningResources = await prisma.learningResource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningResourceWithIdOnly = await prisma.learningResource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningResourceFindManyArgs>(args?: SelectSubset<T, LearningResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningResource.
     * @param {LearningResourceCreateArgs} args - Arguments to create a LearningResource.
     * @example
     * // Create one LearningResource
     * const LearningResource = await prisma.learningResource.create({
     *   data: {
     *     // ... data to create a LearningResource
     *   }
     * })
     * 
     */
    create<T extends LearningResourceCreateArgs>(args: SelectSubset<T, LearningResourceCreateArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningResources.
     * @param {LearningResourceCreateManyArgs} args - Arguments to create many LearningResources.
     * @example
     * // Create many LearningResources
     * const learningResource = await prisma.learningResource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningResourceCreateManyArgs>(args?: SelectSubset<T, LearningResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningResources and returns the data saved in the database.
     * @param {LearningResourceCreateManyAndReturnArgs} args - Arguments to create many LearningResources.
     * @example
     * // Create many LearningResources
     * const learningResource = await prisma.learningResource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningResources and only return the `id`
     * const learningResourceWithIdOnly = await prisma.learningResource.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningResourceCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningResourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningResource.
     * @param {LearningResourceDeleteArgs} args - Arguments to delete one LearningResource.
     * @example
     * // Delete one LearningResource
     * const LearningResource = await prisma.learningResource.delete({
     *   where: {
     *     // ... filter to delete one LearningResource
     *   }
     * })
     * 
     */
    delete<T extends LearningResourceDeleteArgs>(args: SelectSubset<T, LearningResourceDeleteArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningResource.
     * @param {LearningResourceUpdateArgs} args - Arguments to update one LearningResource.
     * @example
     * // Update one LearningResource
     * const learningResource = await prisma.learningResource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningResourceUpdateArgs>(args: SelectSubset<T, LearningResourceUpdateArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningResources.
     * @param {LearningResourceDeleteManyArgs} args - Arguments to filter LearningResources to delete.
     * @example
     * // Delete a few LearningResources
     * const { count } = await prisma.learningResource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningResourceDeleteManyArgs>(args?: SelectSubset<T, LearningResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningResources
     * const learningResource = await prisma.learningResource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningResourceUpdateManyArgs>(args: SelectSubset<T, LearningResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningResource.
     * @param {LearningResourceUpsertArgs} args - Arguments to update or create a LearningResource.
     * @example
     * // Update or create a LearningResource
     * const learningResource = await prisma.learningResource.upsert({
     *   create: {
     *     // ... data to create a LearningResource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningResource we want to update
     *   }
     * })
     */
    upsert<T extends LearningResourceUpsertArgs>(args: SelectSubset<T, LearningResourceUpsertArgs<ExtArgs>>): Prisma__LearningResourceClient<$Result.GetResult<Prisma.$LearningResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningResources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningResourceCountArgs} args - Arguments to filter LearningResources to count.
     * @example
     * // Count the number of LearningResources
     * const count = await prisma.learningResource.count({
     *   where: {
     *     // ... the filter for the LearningResources we want to count
     *   }
     * })
    **/
    count<T extends LearningResourceCountArgs>(
      args?: Subset<T, LearningResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningResourceAggregateArgs>(args: Subset<T, LearningResourceAggregateArgs>): Prisma.PrismaPromise<GetLearningResourceAggregateType<T>>

    /**
     * Group by LearningResource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningResourceGroupByArgs['orderBy'] }
        : { orderBy?: LearningResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningResource model
   */
  readonly fields: LearningResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningResource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    createdBy<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningResource model
   */ 
  interface LearningResourceFieldRefs {
    readonly id: FieldRef<"LearningResource", 'String'>
    readonly title: FieldRef<"LearningResource", 'String'>
    readonly description: FieldRef<"LearningResource", 'String'>
    readonly type: FieldRef<"LearningResource", 'ResourceType'>
    readonly subjectId: FieldRef<"LearningResource", 'String'>
    readonly level: FieldRef<"LearningResource", 'String'>
    readonly url: FieldRef<"LearningResource", 'String'>
    readonly thumbnail: FieldRef<"LearningResource", 'String'>
    readonly duration: FieldRef<"LearningResource", 'Int'>
    readonly tags: FieldRef<"LearningResource", 'String[]'>
    readonly createdById: FieldRef<"LearningResource", 'String'>
    readonly accessLevel: FieldRef<"LearningResource", 'AccessLevel'>
    readonly downloadable: FieldRef<"LearningResource", 'Boolean'>
    readonly createdAt: FieldRef<"LearningResource", 'DateTime'>
    readonly updatedAt: FieldRef<"LearningResource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningResource findUnique
   */
  export type LearningResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningResource to fetch.
     */
    where: LearningResourceWhereUniqueInput
  }

  /**
   * LearningResource findUniqueOrThrow
   */
  export type LearningResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningResource to fetch.
     */
    where: LearningResourceWhereUniqueInput
  }

  /**
   * LearningResource findFirst
   */
  export type LearningResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningResource to fetch.
     */
    where?: LearningResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningResources to fetch.
     */
    orderBy?: LearningResourceOrderByWithRelationInput | LearningResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningResources.
     */
    cursor?: LearningResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningResources.
     */
    distinct?: LearningResourceScalarFieldEnum | LearningResourceScalarFieldEnum[]
  }

  /**
   * LearningResource findFirstOrThrow
   */
  export type LearningResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningResource to fetch.
     */
    where?: LearningResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningResources to fetch.
     */
    orderBy?: LearningResourceOrderByWithRelationInput | LearningResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningResources.
     */
    cursor?: LearningResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningResources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningResources.
     */
    distinct?: LearningResourceScalarFieldEnum | LearningResourceScalarFieldEnum[]
  }

  /**
   * LearningResource findMany
   */
  export type LearningResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * Filter, which LearningResources to fetch.
     */
    where?: LearningResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningResources to fetch.
     */
    orderBy?: LearningResourceOrderByWithRelationInput | LearningResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningResources.
     */
    cursor?: LearningResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningResources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningResources.
     */
    skip?: number
    distinct?: LearningResourceScalarFieldEnum | LearningResourceScalarFieldEnum[]
  }

  /**
   * LearningResource create
   */
  export type LearningResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningResource.
     */
    data: XOR<LearningResourceCreateInput, LearningResourceUncheckedCreateInput>
  }

  /**
   * LearningResource createMany
   */
  export type LearningResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningResources.
     */
    data: LearningResourceCreateManyInput | LearningResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningResource createManyAndReturn
   */
  export type LearningResourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningResources.
     */
    data: LearningResourceCreateManyInput | LearningResourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningResource update
   */
  export type LearningResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningResource.
     */
    data: XOR<LearningResourceUpdateInput, LearningResourceUncheckedUpdateInput>
    /**
     * Choose, which LearningResource to update.
     */
    where: LearningResourceWhereUniqueInput
  }

  /**
   * LearningResource updateMany
   */
  export type LearningResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningResources.
     */
    data: XOR<LearningResourceUpdateManyMutationInput, LearningResourceUncheckedUpdateManyInput>
    /**
     * Filter which LearningResources to update
     */
    where?: LearningResourceWhereInput
  }

  /**
   * LearningResource upsert
   */
  export type LearningResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningResource to update in case it exists.
     */
    where: LearningResourceWhereUniqueInput
    /**
     * In case the LearningResource found by the `where` argument doesn't exist, create a new LearningResource with this data.
     */
    create: XOR<LearningResourceCreateInput, LearningResourceUncheckedCreateInput>
    /**
     * In case the LearningResource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningResourceUpdateInput, LearningResourceUncheckedUpdateInput>
  }

  /**
   * LearningResource delete
   */
  export type LearningResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
    /**
     * Filter which LearningResource to delete.
     */
    where: LearningResourceWhereUniqueInput
  }

  /**
   * LearningResource deleteMany
   */
  export type LearningResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningResources to delete
     */
    where?: LearningResourceWhereInput
  }

  /**
   * LearningResource without action
   */
  export type LearningResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningResource
     */
    select?: LearningResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningResourceInclude<ExtArgs> | null
  }


  /**
   * Model VirtualClass
   */

  export type AggregateVirtualClass = {
    _count: VirtualClassCountAggregateOutputType | null
    _min: VirtualClassMinAggregateOutputType | null
    _max: VirtualClassMaxAggregateOutputType | null
  }

  export type VirtualClassMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    teacherId: string | null
    subjectId: string | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    meetingUrl: string | null
    recordingUrl: string | null
    status: $Enums.VirtualClassStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VirtualClassMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    teacherId: string | null
    subjectId: string | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    meetingUrl: string | null
    recordingUrl: string | null
    status: $Enums.VirtualClassStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VirtualClassCountAggregateOutputType = {
    id: number
    title: number
    description: number
    teacherId: number
    subjectId: number
    scheduledStart: number
    scheduledEnd: number
    meetingUrl: number
    recordingUrl: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VirtualClassMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    teacherId?: true
    subjectId?: true
    scheduledStart?: true
    scheduledEnd?: true
    meetingUrl?: true
    recordingUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VirtualClassMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    teacherId?: true
    subjectId?: true
    scheduledStart?: true
    scheduledEnd?: true
    meetingUrl?: true
    recordingUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VirtualClassCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    teacherId?: true
    subjectId?: true
    scheduledStart?: true
    scheduledEnd?: true
    meetingUrl?: true
    recordingUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VirtualClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualClass to aggregate.
     */
    where?: VirtualClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClasses to fetch.
     */
    orderBy?: VirtualClassOrderByWithRelationInput | VirtualClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VirtualClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VirtualClasses
    **/
    _count?: true | VirtualClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VirtualClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VirtualClassMaxAggregateInputType
  }

  export type GetVirtualClassAggregateType<T extends VirtualClassAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtualClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtualClass[P]>
      : GetScalarType<T[P], AggregateVirtualClass[P]>
  }




  export type VirtualClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassWhereInput
    orderBy?: VirtualClassOrderByWithAggregationInput | VirtualClassOrderByWithAggregationInput[]
    by: VirtualClassScalarFieldEnum[] | VirtualClassScalarFieldEnum
    having?: VirtualClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VirtualClassCountAggregateInputType | true
    _min?: VirtualClassMinAggregateInputType
    _max?: VirtualClassMaxAggregateInputType
  }

  export type VirtualClassGroupByOutputType = {
    id: string
    title: string
    description: string
    teacherId: string
    subjectId: string
    scheduledStart: Date
    scheduledEnd: Date
    meetingUrl: string
    recordingUrl: string | null
    status: $Enums.VirtualClassStatus
    createdAt: Date
    updatedAt: Date
    _count: VirtualClassCountAggregateOutputType | null
    _min: VirtualClassMinAggregateOutputType | null
    _max: VirtualClassMaxAggregateOutputType | null
  }

  type GetVirtualClassGroupByPayload<T extends VirtualClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VirtualClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VirtualClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VirtualClassGroupByOutputType[P]>
            : GetScalarType<T[P], VirtualClassGroupByOutputType[P]>
        }
      >
    >


  export type VirtualClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    teacherId?: boolean
    subjectId?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    meetingUrl?: boolean
    recordingUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classes?: boolean | VirtualClass$classesArgs<ExtArgs>
    _count?: boolean | VirtualClassCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualClass"]>

  export type VirtualClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    teacherId?: boolean
    subjectId?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    meetingUrl?: boolean
    recordingUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualClass"]>

  export type VirtualClassSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    teacherId?: boolean
    subjectId?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    meetingUrl?: boolean
    recordingUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VirtualClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
    classes?: boolean | VirtualClass$classesArgs<ExtArgs>
    _count?: boolean | VirtualClassCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VirtualClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $VirtualClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VirtualClass"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
      classes: Prisma.$VirtualClassParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      teacherId: string
      subjectId: string
      scheduledStart: Date
      scheduledEnd: Date
      meetingUrl: string
      recordingUrl: string | null
      status: $Enums.VirtualClassStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["virtualClass"]>
    composites: {}
  }

  type VirtualClassGetPayload<S extends boolean | null | undefined | VirtualClassDefaultArgs> = $Result.GetResult<Prisma.$VirtualClassPayload, S>

  type VirtualClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VirtualClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VirtualClassCountAggregateInputType | true
    }

  export interface VirtualClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VirtualClass'], meta: { name: 'VirtualClass' } }
    /**
     * Find zero or one VirtualClass that matches the filter.
     * @param {VirtualClassFindUniqueArgs} args - Arguments to find a VirtualClass
     * @example
     * // Get one VirtualClass
     * const virtualClass = await prisma.virtualClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VirtualClassFindUniqueArgs>(args: SelectSubset<T, VirtualClassFindUniqueArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VirtualClass that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VirtualClassFindUniqueOrThrowArgs} args - Arguments to find a VirtualClass
     * @example
     * // Get one VirtualClass
     * const virtualClass = await prisma.virtualClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VirtualClassFindUniqueOrThrowArgs>(args: SelectSubset<T, VirtualClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VirtualClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassFindFirstArgs} args - Arguments to find a VirtualClass
     * @example
     * // Get one VirtualClass
     * const virtualClass = await prisma.virtualClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VirtualClassFindFirstArgs>(args?: SelectSubset<T, VirtualClassFindFirstArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VirtualClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassFindFirstOrThrowArgs} args - Arguments to find a VirtualClass
     * @example
     * // Get one VirtualClass
     * const virtualClass = await prisma.virtualClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VirtualClassFindFirstOrThrowArgs>(args?: SelectSubset<T, VirtualClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VirtualClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VirtualClasses
     * const virtualClasses = await prisma.virtualClass.findMany()
     * 
     * // Get first 10 VirtualClasses
     * const virtualClasses = await prisma.virtualClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtualClassWithIdOnly = await prisma.virtualClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VirtualClassFindManyArgs>(args?: SelectSubset<T, VirtualClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VirtualClass.
     * @param {VirtualClassCreateArgs} args - Arguments to create a VirtualClass.
     * @example
     * // Create one VirtualClass
     * const VirtualClass = await prisma.virtualClass.create({
     *   data: {
     *     // ... data to create a VirtualClass
     *   }
     * })
     * 
     */
    create<T extends VirtualClassCreateArgs>(args: SelectSubset<T, VirtualClassCreateArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VirtualClasses.
     * @param {VirtualClassCreateManyArgs} args - Arguments to create many VirtualClasses.
     * @example
     * // Create many VirtualClasses
     * const virtualClass = await prisma.virtualClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VirtualClassCreateManyArgs>(args?: SelectSubset<T, VirtualClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VirtualClasses and returns the data saved in the database.
     * @param {VirtualClassCreateManyAndReturnArgs} args - Arguments to create many VirtualClasses.
     * @example
     * // Create many VirtualClasses
     * const virtualClass = await prisma.virtualClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VirtualClasses and only return the `id`
     * const virtualClassWithIdOnly = await prisma.virtualClass.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VirtualClassCreateManyAndReturnArgs>(args?: SelectSubset<T, VirtualClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VirtualClass.
     * @param {VirtualClassDeleteArgs} args - Arguments to delete one VirtualClass.
     * @example
     * // Delete one VirtualClass
     * const VirtualClass = await prisma.virtualClass.delete({
     *   where: {
     *     // ... filter to delete one VirtualClass
     *   }
     * })
     * 
     */
    delete<T extends VirtualClassDeleteArgs>(args: SelectSubset<T, VirtualClassDeleteArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VirtualClass.
     * @param {VirtualClassUpdateArgs} args - Arguments to update one VirtualClass.
     * @example
     * // Update one VirtualClass
     * const virtualClass = await prisma.virtualClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VirtualClassUpdateArgs>(args: SelectSubset<T, VirtualClassUpdateArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VirtualClasses.
     * @param {VirtualClassDeleteManyArgs} args - Arguments to filter VirtualClasses to delete.
     * @example
     * // Delete a few VirtualClasses
     * const { count } = await prisma.virtualClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VirtualClassDeleteManyArgs>(args?: SelectSubset<T, VirtualClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VirtualClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VirtualClasses
     * const virtualClass = await prisma.virtualClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VirtualClassUpdateManyArgs>(args: SelectSubset<T, VirtualClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VirtualClass.
     * @param {VirtualClassUpsertArgs} args - Arguments to update or create a VirtualClass.
     * @example
     * // Update or create a VirtualClass
     * const virtualClass = await prisma.virtualClass.upsert({
     *   create: {
     *     // ... data to create a VirtualClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VirtualClass we want to update
     *   }
     * })
     */
    upsert<T extends VirtualClassUpsertArgs>(args: SelectSubset<T, VirtualClassUpsertArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VirtualClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassCountArgs} args - Arguments to filter VirtualClasses to count.
     * @example
     * // Count the number of VirtualClasses
     * const count = await prisma.virtualClass.count({
     *   where: {
     *     // ... the filter for the VirtualClasses we want to count
     *   }
     * })
    **/
    count<T extends VirtualClassCountArgs>(
      args?: Subset<T, VirtualClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VirtualClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VirtualClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VirtualClassAggregateArgs>(args: Subset<T, VirtualClassAggregateArgs>): Prisma.PrismaPromise<GetVirtualClassAggregateType<T>>

    /**
     * Group by VirtualClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VirtualClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VirtualClassGroupByArgs['orderBy'] }
        : { orderBy?: VirtualClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VirtualClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtualClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VirtualClass model
   */
  readonly fields: VirtualClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VirtualClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VirtualClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    classes<T extends VirtualClass$classesArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClass$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VirtualClass model
   */ 
  interface VirtualClassFieldRefs {
    readonly id: FieldRef<"VirtualClass", 'String'>
    readonly title: FieldRef<"VirtualClass", 'String'>
    readonly description: FieldRef<"VirtualClass", 'String'>
    readonly teacherId: FieldRef<"VirtualClass", 'String'>
    readonly subjectId: FieldRef<"VirtualClass", 'String'>
    readonly scheduledStart: FieldRef<"VirtualClass", 'DateTime'>
    readonly scheduledEnd: FieldRef<"VirtualClass", 'DateTime'>
    readonly meetingUrl: FieldRef<"VirtualClass", 'String'>
    readonly recordingUrl: FieldRef<"VirtualClass", 'String'>
    readonly status: FieldRef<"VirtualClass", 'VirtualClassStatus'>
    readonly createdAt: FieldRef<"VirtualClass", 'DateTime'>
    readonly updatedAt: FieldRef<"VirtualClass", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VirtualClass findUnique
   */
  export type VirtualClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClass to fetch.
     */
    where: VirtualClassWhereUniqueInput
  }

  /**
   * VirtualClass findUniqueOrThrow
   */
  export type VirtualClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClass to fetch.
     */
    where: VirtualClassWhereUniqueInput
  }

  /**
   * VirtualClass findFirst
   */
  export type VirtualClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClass to fetch.
     */
    where?: VirtualClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClasses to fetch.
     */
    orderBy?: VirtualClassOrderByWithRelationInput | VirtualClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualClasses.
     */
    cursor?: VirtualClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualClasses.
     */
    distinct?: VirtualClassScalarFieldEnum | VirtualClassScalarFieldEnum[]
  }

  /**
   * VirtualClass findFirstOrThrow
   */
  export type VirtualClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClass to fetch.
     */
    where?: VirtualClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClasses to fetch.
     */
    orderBy?: VirtualClassOrderByWithRelationInput | VirtualClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualClasses.
     */
    cursor?: VirtualClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualClasses.
     */
    distinct?: VirtualClassScalarFieldEnum | VirtualClassScalarFieldEnum[]
  }

  /**
   * VirtualClass findMany
   */
  export type VirtualClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClasses to fetch.
     */
    where?: VirtualClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClasses to fetch.
     */
    orderBy?: VirtualClassOrderByWithRelationInput | VirtualClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VirtualClasses.
     */
    cursor?: VirtualClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClasses.
     */
    skip?: number
    distinct?: VirtualClassScalarFieldEnum | VirtualClassScalarFieldEnum[]
  }

  /**
   * VirtualClass create
   */
  export type VirtualClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * The data needed to create a VirtualClass.
     */
    data: XOR<VirtualClassCreateInput, VirtualClassUncheckedCreateInput>
  }

  /**
   * VirtualClass createMany
   */
  export type VirtualClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VirtualClasses.
     */
    data: VirtualClassCreateManyInput | VirtualClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VirtualClass createManyAndReturn
   */
  export type VirtualClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VirtualClasses.
     */
    data: VirtualClassCreateManyInput | VirtualClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VirtualClass update
   */
  export type VirtualClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * The data needed to update a VirtualClass.
     */
    data: XOR<VirtualClassUpdateInput, VirtualClassUncheckedUpdateInput>
    /**
     * Choose, which VirtualClass to update.
     */
    where: VirtualClassWhereUniqueInput
  }

  /**
   * VirtualClass updateMany
   */
  export type VirtualClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VirtualClasses.
     */
    data: XOR<VirtualClassUpdateManyMutationInput, VirtualClassUncheckedUpdateManyInput>
    /**
     * Filter which VirtualClasses to update
     */
    where?: VirtualClassWhereInput
  }

  /**
   * VirtualClass upsert
   */
  export type VirtualClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * The filter to search for the VirtualClass to update in case it exists.
     */
    where: VirtualClassWhereUniqueInput
    /**
     * In case the VirtualClass found by the `where` argument doesn't exist, create a new VirtualClass with this data.
     */
    create: XOR<VirtualClassCreateInput, VirtualClassUncheckedCreateInput>
    /**
     * In case the VirtualClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VirtualClassUpdateInput, VirtualClassUncheckedUpdateInput>
  }

  /**
   * VirtualClass delete
   */
  export type VirtualClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
    /**
     * Filter which VirtualClass to delete.
     */
    where: VirtualClassWhereUniqueInput
  }

  /**
   * VirtualClass deleteMany
   */
  export type VirtualClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualClasses to delete
     */
    where?: VirtualClassWhereInput
  }

  /**
   * VirtualClass.classes
   */
  export type VirtualClass$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    where?: VirtualClassParticipantWhereInput
    orderBy?: VirtualClassParticipantOrderByWithRelationInput | VirtualClassParticipantOrderByWithRelationInput[]
    cursor?: VirtualClassParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VirtualClassParticipantScalarFieldEnum | VirtualClassParticipantScalarFieldEnum[]
  }

  /**
   * VirtualClass without action
   */
  export type VirtualClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClass
     */
    select?: VirtualClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassInclude<ExtArgs> | null
  }


  /**
   * Model VirtualClassParticipant
   */

  export type AggregateVirtualClassParticipant = {
    _count: VirtualClassParticipantCountAggregateOutputType | null
    _min: VirtualClassParticipantMinAggregateOutputType | null
    _max: VirtualClassParticipantMaxAggregateOutputType | null
  }

  export type VirtualClassParticipantMinAggregateOutputType = {
    id: string | null
    virtualClassId: string | null
    classId: string | null
  }

  export type VirtualClassParticipantMaxAggregateOutputType = {
    id: string | null
    virtualClassId: string | null
    classId: string | null
  }

  export type VirtualClassParticipantCountAggregateOutputType = {
    id: number
    virtualClassId: number
    classId: number
    _all: number
  }


  export type VirtualClassParticipantMinAggregateInputType = {
    id?: true
    virtualClassId?: true
    classId?: true
  }

  export type VirtualClassParticipantMaxAggregateInputType = {
    id?: true
    virtualClassId?: true
    classId?: true
  }

  export type VirtualClassParticipantCountAggregateInputType = {
    id?: true
    virtualClassId?: true
    classId?: true
    _all?: true
  }

  export type VirtualClassParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualClassParticipant to aggregate.
     */
    where?: VirtualClassParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassParticipants to fetch.
     */
    orderBy?: VirtualClassParticipantOrderByWithRelationInput | VirtualClassParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VirtualClassParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VirtualClassParticipants
    **/
    _count?: true | VirtualClassParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VirtualClassParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VirtualClassParticipantMaxAggregateInputType
  }

  export type GetVirtualClassParticipantAggregateType<T extends VirtualClassParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateVirtualClassParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVirtualClassParticipant[P]>
      : GetScalarType<T[P], AggregateVirtualClassParticipant[P]>
  }




  export type VirtualClassParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VirtualClassParticipantWhereInput
    orderBy?: VirtualClassParticipantOrderByWithAggregationInput | VirtualClassParticipantOrderByWithAggregationInput[]
    by: VirtualClassParticipantScalarFieldEnum[] | VirtualClassParticipantScalarFieldEnum
    having?: VirtualClassParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VirtualClassParticipantCountAggregateInputType | true
    _min?: VirtualClassParticipantMinAggregateInputType
    _max?: VirtualClassParticipantMaxAggregateInputType
  }

  export type VirtualClassParticipantGroupByOutputType = {
    id: string
    virtualClassId: string
    classId: string
    _count: VirtualClassParticipantCountAggregateOutputType | null
    _min: VirtualClassParticipantMinAggregateOutputType | null
    _max: VirtualClassParticipantMaxAggregateOutputType | null
  }

  type GetVirtualClassParticipantGroupByPayload<T extends VirtualClassParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VirtualClassParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VirtualClassParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VirtualClassParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], VirtualClassParticipantGroupByOutputType[P]>
        }
      >
    >


  export type VirtualClassParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    virtualClassId?: boolean
    classId?: boolean
    virtualClass?: boolean | VirtualClassDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualClassParticipant"]>

  export type VirtualClassParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    virtualClassId?: boolean
    classId?: boolean
    virtualClass?: boolean | VirtualClassDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["virtualClassParticipant"]>

  export type VirtualClassParticipantSelectScalar = {
    id?: boolean
    virtualClassId?: boolean
    classId?: boolean
  }

  export type VirtualClassParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualClass?: boolean | VirtualClassDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type VirtualClassParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    virtualClass?: boolean | VirtualClassDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $VirtualClassParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VirtualClassParticipant"
    objects: {
      virtualClass: Prisma.$VirtualClassPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      virtualClassId: string
      classId: string
    }, ExtArgs["result"]["virtualClassParticipant"]>
    composites: {}
  }

  type VirtualClassParticipantGetPayload<S extends boolean | null | undefined | VirtualClassParticipantDefaultArgs> = $Result.GetResult<Prisma.$VirtualClassParticipantPayload, S>

  type VirtualClassParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VirtualClassParticipantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VirtualClassParticipantCountAggregateInputType | true
    }

  export interface VirtualClassParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VirtualClassParticipant'], meta: { name: 'VirtualClassParticipant' } }
    /**
     * Find zero or one VirtualClassParticipant that matches the filter.
     * @param {VirtualClassParticipantFindUniqueArgs} args - Arguments to find a VirtualClassParticipant
     * @example
     * // Get one VirtualClassParticipant
     * const virtualClassParticipant = await prisma.virtualClassParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VirtualClassParticipantFindUniqueArgs>(args: SelectSubset<T, VirtualClassParticipantFindUniqueArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VirtualClassParticipant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VirtualClassParticipantFindUniqueOrThrowArgs} args - Arguments to find a VirtualClassParticipant
     * @example
     * // Get one VirtualClassParticipant
     * const virtualClassParticipant = await prisma.virtualClassParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VirtualClassParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, VirtualClassParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VirtualClassParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassParticipantFindFirstArgs} args - Arguments to find a VirtualClassParticipant
     * @example
     * // Get one VirtualClassParticipant
     * const virtualClassParticipant = await prisma.virtualClassParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VirtualClassParticipantFindFirstArgs>(args?: SelectSubset<T, VirtualClassParticipantFindFirstArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VirtualClassParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassParticipantFindFirstOrThrowArgs} args - Arguments to find a VirtualClassParticipant
     * @example
     * // Get one VirtualClassParticipant
     * const virtualClassParticipant = await prisma.virtualClassParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VirtualClassParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, VirtualClassParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VirtualClassParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VirtualClassParticipants
     * const virtualClassParticipants = await prisma.virtualClassParticipant.findMany()
     * 
     * // Get first 10 VirtualClassParticipants
     * const virtualClassParticipants = await prisma.virtualClassParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const virtualClassParticipantWithIdOnly = await prisma.virtualClassParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VirtualClassParticipantFindManyArgs>(args?: SelectSubset<T, VirtualClassParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VirtualClassParticipant.
     * @param {VirtualClassParticipantCreateArgs} args - Arguments to create a VirtualClassParticipant.
     * @example
     * // Create one VirtualClassParticipant
     * const VirtualClassParticipant = await prisma.virtualClassParticipant.create({
     *   data: {
     *     // ... data to create a VirtualClassParticipant
     *   }
     * })
     * 
     */
    create<T extends VirtualClassParticipantCreateArgs>(args: SelectSubset<T, VirtualClassParticipantCreateArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VirtualClassParticipants.
     * @param {VirtualClassParticipantCreateManyArgs} args - Arguments to create many VirtualClassParticipants.
     * @example
     * // Create many VirtualClassParticipants
     * const virtualClassParticipant = await prisma.virtualClassParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VirtualClassParticipantCreateManyArgs>(args?: SelectSubset<T, VirtualClassParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VirtualClassParticipants and returns the data saved in the database.
     * @param {VirtualClassParticipantCreateManyAndReturnArgs} args - Arguments to create many VirtualClassParticipants.
     * @example
     * // Create many VirtualClassParticipants
     * const virtualClassParticipant = await prisma.virtualClassParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VirtualClassParticipants and only return the `id`
     * const virtualClassParticipantWithIdOnly = await prisma.virtualClassParticipant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VirtualClassParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, VirtualClassParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a VirtualClassParticipant.
     * @param {VirtualClassParticipantDeleteArgs} args - Arguments to delete one VirtualClassParticipant.
     * @example
     * // Delete one VirtualClassParticipant
     * const VirtualClassParticipant = await prisma.virtualClassParticipant.delete({
     *   where: {
     *     // ... filter to delete one VirtualClassParticipant
     *   }
     * })
     * 
     */
    delete<T extends VirtualClassParticipantDeleteArgs>(args: SelectSubset<T, VirtualClassParticipantDeleteArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VirtualClassParticipant.
     * @param {VirtualClassParticipantUpdateArgs} args - Arguments to update one VirtualClassParticipant.
     * @example
     * // Update one VirtualClassParticipant
     * const virtualClassParticipant = await prisma.virtualClassParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VirtualClassParticipantUpdateArgs>(args: SelectSubset<T, VirtualClassParticipantUpdateArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VirtualClassParticipants.
     * @param {VirtualClassParticipantDeleteManyArgs} args - Arguments to filter VirtualClassParticipants to delete.
     * @example
     * // Delete a few VirtualClassParticipants
     * const { count } = await prisma.virtualClassParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VirtualClassParticipantDeleteManyArgs>(args?: SelectSubset<T, VirtualClassParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VirtualClassParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VirtualClassParticipants
     * const virtualClassParticipant = await prisma.virtualClassParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VirtualClassParticipantUpdateManyArgs>(args: SelectSubset<T, VirtualClassParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VirtualClassParticipant.
     * @param {VirtualClassParticipantUpsertArgs} args - Arguments to update or create a VirtualClassParticipant.
     * @example
     * // Update or create a VirtualClassParticipant
     * const virtualClassParticipant = await prisma.virtualClassParticipant.upsert({
     *   create: {
     *     // ... data to create a VirtualClassParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VirtualClassParticipant we want to update
     *   }
     * })
     */
    upsert<T extends VirtualClassParticipantUpsertArgs>(args: SelectSubset<T, VirtualClassParticipantUpsertArgs<ExtArgs>>): Prisma__VirtualClassParticipantClient<$Result.GetResult<Prisma.$VirtualClassParticipantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VirtualClassParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassParticipantCountArgs} args - Arguments to filter VirtualClassParticipants to count.
     * @example
     * // Count the number of VirtualClassParticipants
     * const count = await prisma.virtualClassParticipant.count({
     *   where: {
     *     // ... the filter for the VirtualClassParticipants we want to count
     *   }
     * })
    **/
    count<T extends VirtualClassParticipantCountArgs>(
      args?: Subset<T, VirtualClassParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VirtualClassParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VirtualClassParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VirtualClassParticipantAggregateArgs>(args: Subset<T, VirtualClassParticipantAggregateArgs>): Prisma.PrismaPromise<GetVirtualClassParticipantAggregateType<T>>

    /**
     * Group by VirtualClassParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VirtualClassParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VirtualClassParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VirtualClassParticipantGroupByArgs['orderBy'] }
        : { orderBy?: VirtualClassParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VirtualClassParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVirtualClassParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VirtualClassParticipant model
   */
  readonly fields: VirtualClassParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VirtualClassParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VirtualClassParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    virtualClass<T extends VirtualClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VirtualClassDefaultArgs<ExtArgs>>): Prisma__VirtualClassClient<$Result.GetResult<Prisma.$VirtualClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VirtualClassParticipant model
   */ 
  interface VirtualClassParticipantFieldRefs {
    readonly id: FieldRef<"VirtualClassParticipant", 'String'>
    readonly virtualClassId: FieldRef<"VirtualClassParticipant", 'String'>
    readonly classId: FieldRef<"VirtualClassParticipant", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VirtualClassParticipant findUnique
   */
  export type VirtualClassParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassParticipant to fetch.
     */
    where: VirtualClassParticipantWhereUniqueInput
  }

  /**
   * VirtualClassParticipant findUniqueOrThrow
   */
  export type VirtualClassParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassParticipant to fetch.
     */
    where: VirtualClassParticipantWhereUniqueInput
  }

  /**
   * VirtualClassParticipant findFirst
   */
  export type VirtualClassParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassParticipant to fetch.
     */
    where?: VirtualClassParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassParticipants to fetch.
     */
    orderBy?: VirtualClassParticipantOrderByWithRelationInput | VirtualClassParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualClassParticipants.
     */
    cursor?: VirtualClassParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualClassParticipants.
     */
    distinct?: VirtualClassParticipantScalarFieldEnum | VirtualClassParticipantScalarFieldEnum[]
  }

  /**
   * VirtualClassParticipant findFirstOrThrow
   */
  export type VirtualClassParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassParticipant to fetch.
     */
    where?: VirtualClassParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassParticipants to fetch.
     */
    orderBy?: VirtualClassParticipantOrderByWithRelationInput | VirtualClassParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VirtualClassParticipants.
     */
    cursor?: VirtualClassParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VirtualClassParticipants.
     */
    distinct?: VirtualClassParticipantScalarFieldEnum | VirtualClassParticipantScalarFieldEnum[]
  }

  /**
   * VirtualClassParticipant findMany
   */
  export type VirtualClassParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * Filter, which VirtualClassParticipants to fetch.
     */
    where?: VirtualClassParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VirtualClassParticipants to fetch.
     */
    orderBy?: VirtualClassParticipantOrderByWithRelationInput | VirtualClassParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VirtualClassParticipants.
     */
    cursor?: VirtualClassParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VirtualClassParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VirtualClassParticipants.
     */
    skip?: number
    distinct?: VirtualClassParticipantScalarFieldEnum | VirtualClassParticipantScalarFieldEnum[]
  }

  /**
   * VirtualClassParticipant create
   */
  export type VirtualClassParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a VirtualClassParticipant.
     */
    data: XOR<VirtualClassParticipantCreateInput, VirtualClassParticipantUncheckedCreateInput>
  }

  /**
   * VirtualClassParticipant createMany
   */
  export type VirtualClassParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VirtualClassParticipants.
     */
    data: VirtualClassParticipantCreateManyInput | VirtualClassParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VirtualClassParticipant createManyAndReturn
   */
  export type VirtualClassParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many VirtualClassParticipants.
     */
    data: VirtualClassParticipantCreateManyInput | VirtualClassParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VirtualClassParticipant update
   */
  export type VirtualClassParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a VirtualClassParticipant.
     */
    data: XOR<VirtualClassParticipantUpdateInput, VirtualClassParticipantUncheckedUpdateInput>
    /**
     * Choose, which VirtualClassParticipant to update.
     */
    where: VirtualClassParticipantWhereUniqueInput
  }

  /**
   * VirtualClassParticipant updateMany
   */
  export type VirtualClassParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VirtualClassParticipants.
     */
    data: XOR<VirtualClassParticipantUpdateManyMutationInput, VirtualClassParticipantUncheckedUpdateManyInput>
    /**
     * Filter which VirtualClassParticipants to update
     */
    where?: VirtualClassParticipantWhereInput
  }

  /**
   * VirtualClassParticipant upsert
   */
  export type VirtualClassParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the VirtualClassParticipant to update in case it exists.
     */
    where: VirtualClassParticipantWhereUniqueInput
    /**
     * In case the VirtualClassParticipant found by the `where` argument doesn't exist, create a new VirtualClassParticipant with this data.
     */
    create: XOR<VirtualClassParticipantCreateInput, VirtualClassParticipantUncheckedCreateInput>
    /**
     * In case the VirtualClassParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VirtualClassParticipantUpdateInput, VirtualClassParticipantUncheckedUpdateInput>
  }

  /**
   * VirtualClassParticipant delete
   */
  export type VirtualClassParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
    /**
     * Filter which VirtualClassParticipant to delete.
     */
    where: VirtualClassParticipantWhereUniqueInput
  }

  /**
   * VirtualClassParticipant deleteMany
   */
  export type VirtualClassParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VirtualClassParticipants to delete
     */
    where?: VirtualClassParticipantWhereInput
  }

  /**
   * VirtualClassParticipant without action
   */
  export type VirtualClassParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VirtualClassParticipant
     */
    select?: VirtualClassParticipantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VirtualClassParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: $Enums.AchievementCategory | null
    points: number | null
    rarity: $Enums.Rarity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    icon: string | null
    category: $Enums.AchievementCategory | null
    points: number | null
    rarity: $Enums.Rarity | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    icon: number
    category: number
    points: number
    criteria: number
    rarity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    points?: true
    rarity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    points?: true
    rarity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    icon?: true
    category?: true
    points?: true
    criteria?: true
    rarity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    points: number
    criteria: string[]
    rarity: $Enums.Rarity
    createdAt: Date
    updatedAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    points?: boolean
    criteria?: boolean
    rarity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    students?: boolean | Achievement$studentsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    points?: boolean
    criteria?: boolean
    rarity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    category?: boolean
    points?: boolean
    criteria?: boolean
    rarity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | Achievement$studentsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      students: Prisma.$StudentAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      icon: string
      category: $Enums.AchievementCategory
      points: number
      criteria: string[]
      rarity: $Enums.Rarity
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends Achievement$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly title: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly category: FieldRef<"Achievement", 'AchievementCategory'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly criteria: FieldRef<"Achievement", 'String[]'>
    readonly rarity: FieldRef<"Achievement", 'Rarity'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
    readonly updatedAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement.students
   */
  export type Achievement$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    where?: StudentAchievementWhereInput
    orderBy?: StudentAchievementOrderByWithRelationInput | StudentAchievementOrderByWithRelationInput[]
    cursor?: StudentAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentAchievementScalarFieldEnum | StudentAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model StudentAchievement
   */

  export type AggregateStudentAchievement = {
    _count: StudentAchievementCountAggregateOutputType | null
    _min: StudentAchievementMinAggregateOutputType | null
    _max: StudentAchievementMaxAggregateOutputType | null
  }

  export type StudentAchievementMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    achievementId: string | null
    earnedDate: Date | null
    awardedBy: string | null
    evidence: string | null
  }

  export type StudentAchievementMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    achievementId: string | null
    earnedDate: Date | null
    awardedBy: string | null
    evidence: string | null
  }

  export type StudentAchievementCountAggregateOutputType = {
    id: number
    studentId: number
    achievementId: number
    earnedDate: number
    awardedBy: number
    evidence: number
    _all: number
  }


  export type StudentAchievementMinAggregateInputType = {
    id?: true
    studentId?: true
    achievementId?: true
    earnedDate?: true
    awardedBy?: true
    evidence?: true
  }

  export type StudentAchievementMaxAggregateInputType = {
    id?: true
    studentId?: true
    achievementId?: true
    earnedDate?: true
    awardedBy?: true
    evidence?: true
  }

  export type StudentAchievementCountAggregateInputType = {
    id?: true
    studentId?: true
    achievementId?: true
    earnedDate?: true
    awardedBy?: true
    evidence?: true
    _all?: true
  }

  export type StudentAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAchievement to aggregate.
     */
    where?: StudentAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAchievements to fetch.
     */
    orderBy?: StudentAchievementOrderByWithRelationInput | StudentAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentAchievements
    **/
    _count?: true | StudentAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentAchievementMaxAggregateInputType
  }

  export type GetStudentAchievementAggregateType<T extends StudentAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentAchievement[P]>
      : GetScalarType<T[P], AggregateStudentAchievement[P]>
  }




  export type StudentAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentAchievementWhereInput
    orderBy?: StudentAchievementOrderByWithAggregationInput | StudentAchievementOrderByWithAggregationInput[]
    by: StudentAchievementScalarFieldEnum[] | StudentAchievementScalarFieldEnum
    having?: StudentAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentAchievementCountAggregateInputType | true
    _min?: StudentAchievementMinAggregateInputType
    _max?: StudentAchievementMaxAggregateInputType
  }

  export type StudentAchievementGroupByOutputType = {
    id: string
    studentId: string
    achievementId: string
    earnedDate: Date
    awardedBy: string
    evidence: string | null
    _count: StudentAchievementCountAggregateOutputType | null
    _min: StudentAchievementMinAggregateOutputType | null
    _max: StudentAchievementMaxAggregateOutputType | null
  }

  type GetStudentAchievementGroupByPayload<T extends StudentAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], StudentAchievementGroupByOutputType[P]>
        }
      >
    >


  export type StudentAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    achievementId?: boolean
    earnedDate?: boolean
    awardedBy?: boolean
    evidence?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAchievement"]>

  export type StudentAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    achievementId?: boolean
    earnedDate?: boolean
    awardedBy?: boolean
    evidence?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentAchievement"]>

  export type StudentAchievementSelectScalar = {
    id?: boolean
    studentId?: boolean
    achievementId?: boolean
    earnedDate?: boolean
    awardedBy?: boolean
    evidence?: boolean
  }

  export type StudentAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type StudentAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $StudentAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentAchievement"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      achievementId: string
      earnedDate: Date
      awardedBy: string
      evidence: string | null
    }, ExtArgs["result"]["studentAchievement"]>
    composites: {}
  }

  type StudentAchievementGetPayload<S extends boolean | null | undefined | StudentAchievementDefaultArgs> = $Result.GetResult<Prisma.$StudentAchievementPayload, S>

  type StudentAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentAchievementCountAggregateInputType | true
    }

  export interface StudentAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentAchievement'], meta: { name: 'StudentAchievement' } }
    /**
     * Find zero or one StudentAchievement that matches the filter.
     * @param {StudentAchievementFindUniqueArgs} args - Arguments to find a StudentAchievement
     * @example
     * // Get one StudentAchievement
     * const studentAchievement = await prisma.studentAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentAchievementFindUniqueArgs>(args: SelectSubset<T, StudentAchievementFindUniqueArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentAchievementFindUniqueOrThrowArgs} args - Arguments to find a StudentAchievement
     * @example
     * // Get one StudentAchievement
     * const studentAchievement = await prisma.studentAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAchievementFindFirstArgs} args - Arguments to find a StudentAchievement
     * @example
     * // Get one StudentAchievement
     * const studentAchievement = await prisma.studentAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentAchievementFindFirstArgs>(args?: SelectSubset<T, StudentAchievementFindFirstArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAchievementFindFirstOrThrowArgs} args - Arguments to find a StudentAchievement
     * @example
     * // Get one StudentAchievement
     * const studentAchievement = await prisma.studentAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentAchievements
     * const studentAchievements = await prisma.studentAchievement.findMany()
     * 
     * // Get first 10 StudentAchievements
     * const studentAchievements = await prisma.studentAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentAchievementWithIdOnly = await prisma.studentAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentAchievementFindManyArgs>(args?: SelectSubset<T, StudentAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentAchievement.
     * @param {StudentAchievementCreateArgs} args - Arguments to create a StudentAchievement.
     * @example
     * // Create one StudentAchievement
     * const StudentAchievement = await prisma.studentAchievement.create({
     *   data: {
     *     // ... data to create a StudentAchievement
     *   }
     * })
     * 
     */
    create<T extends StudentAchievementCreateArgs>(args: SelectSubset<T, StudentAchievementCreateArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentAchievements.
     * @param {StudentAchievementCreateManyArgs} args - Arguments to create many StudentAchievements.
     * @example
     * // Create many StudentAchievements
     * const studentAchievement = await prisma.studentAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentAchievementCreateManyArgs>(args?: SelectSubset<T, StudentAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentAchievements and returns the data saved in the database.
     * @param {StudentAchievementCreateManyAndReturnArgs} args - Arguments to create many StudentAchievements.
     * @example
     * // Create many StudentAchievements
     * const studentAchievement = await prisma.studentAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentAchievements and only return the `id`
     * const studentAchievementWithIdOnly = await prisma.studentAchievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentAchievement.
     * @param {StudentAchievementDeleteArgs} args - Arguments to delete one StudentAchievement.
     * @example
     * // Delete one StudentAchievement
     * const StudentAchievement = await prisma.studentAchievement.delete({
     *   where: {
     *     // ... filter to delete one StudentAchievement
     *   }
     * })
     * 
     */
    delete<T extends StudentAchievementDeleteArgs>(args: SelectSubset<T, StudentAchievementDeleteArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentAchievement.
     * @param {StudentAchievementUpdateArgs} args - Arguments to update one StudentAchievement.
     * @example
     * // Update one StudentAchievement
     * const studentAchievement = await prisma.studentAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentAchievementUpdateArgs>(args: SelectSubset<T, StudentAchievementUpdateArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentAchievements.
     * @param {StudentAchievementDeleteManyArgs} args - Arguments to filter StudentAchievements to delete.
     * @example
     * // Delete a few StudentAchievements
     * const { count } = await prisma.studentAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentAchievementDeleteManyArgs>(args?: SelectSubset<T, StudentAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentAchievements
     * const studentAchievement = await prisma.studentAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentAchievementUpdateManyArgs>(args: SelectSubset<T, StudentAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentAchievement.
     * @param {StudentAchievementUpsertArgs} args - Arguments to update or create a StudentAchievement.
     * @example
     * // Update or create a StudentAchievement
     * const studentAchievement = await prisma.studentAchievement.upsert({
     *   create: {
     *     // ... data to create a StudentAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentAchievement we want to update
     *   }
     * })
     */
    upsert<T extends StudentAchievementUpsertArgs>(args: SelectSubset<T, StudentAchievementUpsertArgs<ExtArgs>>): Prisma__StudentAchievementClient<$Result.GetResult<Prisma.$StudentAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAchievementCountArgs} args - Arguments to filter StudentAchievements to count.
     * @example
     * // Count the number of StudentAchievements
     * const count = await prisma.studentAchievement.count({
     *   where: {
     *     // ... the filter for the StudentAchievements we want to count
     *   }
     * })
    **/
    count<T extends StudentAchievementCountArgs>(
      args?: Subset<T, StudentAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAchievementAggregateArgs>(args: Subset<T, StudentAchievementAggregateArgs>): Prisma.PrismaPromise<GetStudentAchievementAggregateType<T>>

    /**
     * Group by StudentAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentAchievementGroupByArgs['orderBy'] }
        : { orderBy?: StudentAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentAchievement model
   */
  readonly fields: StudentAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentAchievement model
   */ 
  interface StudentAchievementFieldRefs {
    readonly id: FieldRef<"StudentAchievement", 'String'>
    readonly studentId: FieldRef<"StudentAchievement", 'String'>
    readonly achievementId: FieldRef<"StudentAchievement", 'String'>
    readonly earnedDate: FieldRef<"StudentAchievement", 'DateTime'>
    readonly awardedBy: FieldRef<"StudentAchievement", 'String'>
    readonly evidence: FieldRef<"StudentAchievement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentAchievement findUnique
   */
  export type StudentAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * Filter, which StudentAchievement to fetch.
     */
    where: StudentAchievementWhereUniqueInput
  }

  /**
   * StudentAchievement findUniqueOrThrow
   */
  export type StudentAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * Filter, which StudentAchievement to fetch.
     */
    where: StudentAchievementWhereUniqueInput
  }

  /**
   * StudentAchievement findFirst
   */
  export type StudentAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * Filter, which StudentAchievement to fetch.
     */
    where?: StudentAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAchievements to fetch.
     */
    orderBy?: StudentAchievementOrderByWithRelationInput | StudentAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAchievements.
     */
    cursor?: StudentAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAchievements.
     */
    distinct?: StudentAchievementScalarFieldEnum | StudentAchievementScalarFieldEnum[]
  }

  /**
   * StudentAchievement findFirstOrThrow
   */
  export type StudentAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * Filter, which StudentAchievement to fetch.
     */
    where?: StudentAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAchievements to fetch.
     */
    orderBy?: StudentAchievementOrderByWithRelationInput | StudentAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentAchievements.
     */
    cursor?: StudentAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentAchievements.
     */
    distinct?: StudentAchievementScalarFieldEnum | StudentAchievementScalarFieldEnum[]
  }

  /**
   * StudentAchievement findMany
   */
  export type StudentAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * Filter, which StudentAchievements to fetch.
     */
    where?: StudentAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentAchievements to fetch.
     */
    orderBy?: StudentAchievementOrderByWithRelationInput | StudentAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentAchievements.
     */
    cursor?: StudentAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentAchievements.
     */
    skip?: number
    distinct?: StudentAchievementScalarFieldEnum | StudentAchievementScalarFieldEnum[]
  }

  /**
   * StudentAchievement create
   */
  export type StudentAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentAchievement.
     */
    data: XOR<StudentAchievementCreateInput, StudentAchievementUncheckedCreateInput>
  }

  /**
   * StudentAchievement createMany
   */
  export type StudentAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentAchievements.
     */
    data: StudentAchievementCreateManyInput | StudentAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentAchievement createManyAndReturn
   */
  export type StudentAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentAchievements.
     */
    data: StudentAchievementCreateManyInput | StudentAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentAchievement update
   */
  export type StudentAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentAchievement.
     */
    data: XOR<StudentAchievementUpdateInput, StudentAchievementUncheckedUpdateInput>
    /**
     * Choose, which StudentAchievement to update.
     */
    where: StudentAchievementWhereUniqueInput
  }

  /**
   * StudentAchievement updateMany
   */
  export type StudentAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentAchievements.
     */
    data: XOR<StudentAchievementUpdateManyMutationInput, StudentAchievementUncheckedUpdateManyInput>
    /**
     * Filter which StudentAchievements to update
     */
    where?: StudentAchievementWhereInput
  }

  /**
   * StudentAchievement upsert
   */
  export type StudentAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentAchievement to update in case it exists.
     */
    where: StudentAchievementWhereUniqueInput
    /**
     * In case the StudentAchievement found by the `where` argument doesn't exist, create a new StudentAchievement with this data.
     */
    create: XOR<StudentAchievementCreateInput, StudentAchievementUncheckedCreateInput>
    /**
     * In case the StudentAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentAchievementUpdateInput, StudentAchievementUncheckedUpdateInput>
  }

  /**
   * StudentAchievement delete
   */
  export type StudentAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
    /**
     * Filter which StudentAchievement to delete.
     */
    where: StudentAchievementWhereUniqueInput
  }

  /**
   * StudentAchievement deleteMany
   */
  export type StudentAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentAchievements to delete
     */
    where?: StudentAchievementWhereInput
  }

  /**
   * StudentAchievement without action
   */
  export type StudentAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentAchievement
     */
    select?: StudentAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentAchievementInclude<ExtArgs> | null
  }


  /**
   * Model BehaviorRecord
   */

  export type AggregateBehaviorRecord = {
    _count: BehaviorRecordCountAggregateOutputType | null
    _min: BehaviorRecordMinAggregateOutputType | null
    _max: BehaviorRecordMaxAggregateOutputType | null
  }

  export type BehaviorRecordMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    teacherId: string | null
    date: Date | null
    type: $Enums.BehaviorType | null
    category: $Enums.BehaviorCategory | null
    description: string | null
    severity: $Enums.Severity | null
    actionTaken: string | null
    parentNotified: boolean | null
    followUpRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BehaviorRecordMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    teacherId: string | null
    date: Date | null
    type: $Enums.BehaviorType | null
    category: $Enums.BehaviorCategory | null
    description: string | null
    severity: $Enums.Severity | null
    actionTaken: string | null
    parentNotified: boolean | null
    followUpRequired: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BehaviorRecordCountAggregateOutputType = {
    id: number
    studentId: number
    teacherId: number
    date: number
    type: number
    category: number
    description: number
    severity: number
    actionTaken: number
    parentNotified: number
    followUpRequired: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BehaviorRecordMinAggregateInputType = {
    id?: true
    studentId?: true
    teacherId?: true
    date?: true
    type?: true
    category?: true
    description?: true
    severity?: true
    actionTaken?: true
    parentNotified?: true
    followUpRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BehaviorRecordMaxAggregateInputType = {
    id?: true
    studentId?: true
    teacherId?: true
    date?: true
    type?: true
    category?: true
    description?: true
    severity?: true
    actionTaken?: true
    parentNotified?: true
    followUpRequired?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BehaviorRecordCountAggregateInputType = {
    id?: true
    studentId?: true
    teacherId?: true
    date?: true
    type?: true
    category?: true
    description?: true
    severity?: true
    actionTaken?: true
    parentNotified?: true
    followUpRequired?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BehaviorRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorRecord to aggregate.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehaviorRecords
    **/
    _count?: true | BehaviorRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehaviorRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehaviorRecordMaxAggregateInputType
  }

  export type GetBehaviorRecordAggregateType<T extends BehaviorRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateBehaviorRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehaviorRecord[P]>
      : GetScalarType<T[P], AggregateBehaviorRecord[P]>
  }




  export type BehaviorRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorRecordWhereInput
    orderBy?: BehaviorRecordOrderByWithAggregationInput | BehaviorRecordOrderByWithAggregationInput[]
    by: BehaviorRecordScalarFieldEnum[] | BehaviorRecordScalarFieldEnum
    having?: BehaviorRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehaviorRecordCountAggregateInputType | true
    _min?: BehaviorRecordMinAggregateInputType
    _max?: BehaviorRecordMaxAggregateInputType
  }

  export type BehaviorRecordGroupByOutputType = {
    id: string
    studentId: string
    teacherId: string
    date: Date
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity: $Enums.Severity | null
    actionTaken: string | null
    parentNotified: boolean
    followUpRequired: boolean
    createdAt: Date
    updatedAt: Date
    _count: BehaviorRecordCountAggregateOutputType | null
    _min: BehaviorRecordMinAggregateOutputType | null
    _max: BehaviorRecordMaxAggregateOutputType | null
  }

  type GetBehaviorRecordGroupByPayload<T extends BehaviorRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehaviorRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehaviorRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehaviorRecordGroupByOutputType[P]>
            : GetScalarType<T[P], BehaviorRecordGroupByOutputType[P]>
        }
      >
    >


  export type BehaviorRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    teacherId?: boolean
    date?: boolean
    type?: boolean
    category?: boolean
    description?: boolean
    severity?: boolean
    actionTaken?: boolean
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorRecord"]>

  export type BehaviorRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    teacherId?: boolean
    date?: boolean
    type?: boolean
    category?: boolean
    description?: boolean
    severity?: boolean
    actionTaken?: boolean
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorRecord"]>

  export type BehaviorRecordSelectScalar = {
    id?: boolean
    studentId?: boolean
    teacherId?: boolean
    date?: boolean
    type?: boolean
    category?: boolean
    description?: boolean
    severity?: boolean
    actionTaken?: boolean
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BehaviorRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }
  export type BehaviorRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
  }

  export type $BehaviorRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehaviorRecord"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      teacher: Prisma.$TeacherPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      teacherId: string
      date: Date
      type: $Enums.BehaviorType
      category: $Enums.BehaviorCategory
      description: string
      severity: $Enums.Severity | null
      actionTaken: string | null
      parentNotified: boolean
      followUpRequired: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["behaviorRecord"]>
    composites: {}
  }

  type BehaviorRecordGetPayload<S extends boolean | null | undefined | BehaviorRecordDefaultArgs> = $Result.GetResult<Prisma.$BehaviorRecordPayload, S>

  type BehaviorRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BehaviorRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BehaviorRecordCountAggregateInputType | true
    }

  export interface BehaviorRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehaviorRecord'], meta: { name: 'BehaviorRecord' } }
    /**
     * Find zero or one BehaviorRecord that matches the filter.
     * @param {BehaviorRecordFindUniqueArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehaviorRecordFindUniqueArgs>(args: SelectSubset<T, BehaviorRecordFindUniqueArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BehaviorRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BehaviorRecordFindUniqueOrThrowArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehaviorRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, BehaviorRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BehaviorRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordFindFirstArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehaviorRecordFindFirstArgs>(args?: SelectSubset<T, BehaviorRecordFindFirstArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BehaviorRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordFindFirstOrThrowArgs} args - Arguments to find a BehaviorRecord
     * @example
     * // Get one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehaviorRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, BehaviorRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BehaviorRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehaviorRecords
     * const behaviorRecords = await prisma.behaviorRecord.findMany()
     * 
     * // Get first 10 BehaviorRecords
     * const behaviorRecords = await prisma.behaviorRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behaviorRecordWithIdOnly = await prisma.behaviorRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehaviorRecordFindManyArgs>(args?: SelectSubset<T, BehaviorRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BehaviorRecord.
     * @param {BehaviorRecordCreateArgs} args - Arguments to create a BehaviorRecord.
     * @example
     * // Create one BehaviorRecord
     * const BehaviorRecord = await prisma.behaviorRecord.create({
     *   data: {
     *     // ... data to create a BehaviorRecord
     *   }
     * })
     * 
     */
    create<T extends BehaviorRecordCreateArgs>(args: SelectSubset<T, BehaviorRecordCreateArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BehaviorRecords.
     * @param {BehaviorRecordCreateManyArgs} args - Arguments to create many BehaviorRecords.
     * @example
     * // Create many BehaviorRecords
     * const behaviorRecord = await prisma.behaviorRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehaviorRecordCreateManyArgs>(args?: SelectSubset<T, BehaviorRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehaviorRecords and returns the data saved in the database.
     * @param {BehaviorRecordCreateManyAndReturnArgs} args - Arguments to create many BehaviorRecords.
     * @example
     * // Create many BehaviorRecords
     * const behaviorRecord = await prisma.behaviorRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehaviorRecords and only return the `id`
     * const behaviorRecordWithIdOnly = await prisma.behaviorRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehaviorRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, BehaviorRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BehaviorRecord.
     * @param {BehaviorRecordDeleteArgs} args - Arguments to delete one BehaviorRecord.
     * @example
     * // Delete one BehaviorRecord
     * const BehaviorRecord = await prisma.behaviorRecord.delete({
     *   where: {
     *     // ... filter to delete one BehaviorRecord
     *   }
     * })
     * 
     */
    delete<T extends BehaviorRecordDeleteArgs>(args: SelectSubset<T, BehaviorRecordDeleteArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BehaviorRecord.
     * @param {BehaviorRecordUpdateArgs} args - Arguments to update one BehaviorRecord.
     * @example
     * // Update one BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehaviorRecordUpdateArgs>(args: SelectSubset<T, BehaviorRecordUpdateArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BehaviorRecords.
     * @param {BehaviorRecordDeleteManyArgs} args - Arguments to filter BehaviorRecords to delete.
     * @example
     * // Delete a few BehaviorRecords
     * const { count } = await prisma.behaviorRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehaviorRecordDeleteManyArgs>(args?: SelectSubset<T, BehaviorRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehaviorRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehaviorRecords
     * const behaviorRecord = await prisma.behaviorRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehaviorRecordUpdateManyArgs>(args: SelectSubset<T, BehaviorRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BehaviorRecord.
     * @param {BehaviorRecordUpsertArgs} args - Arguments to update or create a BehaviorRecord.
     * @example
     * // Update or create a BehaviorRecord
     * const behaviorRecord = await prisma.behaviorRecord.upsert({
     *   create: {
     *     // ... data to create a BehaviorRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehaviorRecord we want to update
     *   }
     * })
     */
    upsert<T extends BehaviorRecordUpsertArgs>(args: SelectSubset<T, BehaviorRecordUpsertArgs<ExtArgs>>): Prisma__BehaviorRecordClient<$Result.GetResult<Prisma.$BehaviorRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BehaviorRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordCountArgs} args - Arguments to filter BehaviorRecords to count.
     * @example
     * // Count the number of BehaviorRecords
     * const count = await prisma.behaviorRecord.count({
     *   where: {
     *     // ... the filter for the BehaviorRecords we want to count
     *   }
     * })
    **/
    count<T extends BehaviorRecordCountArgs>(
      args?: Subset<T, BehaviorRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehaviorRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehaviorRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehaviorRecordAggregateArgs>(args: Subset<T, BehaviorRecordAggregateArgs>): Prisma.PrismaPromise<GetBehaviorRecordAggregateType<T>>

    /**
     * Group by BehaviorRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehaviorRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehaviorRecordGroupByArgs['orderBy'] }
        : { orderBy?: BehaviorRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehaviorRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehaviorRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehaviorRecord model
   */
  readonly fields: BehaviorRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehaviorRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehaviorRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehaviorRecord model
   */ 
  interface BehaviorRecordFieldRefs {
    readonly id: FieldRef<"BehaviorRecord", 'String'>
    readonly studentId: FieldRef<"BehaviorRecord", 'String'>
    readonly teacherId: FieldRef<"BehaviorRecord", 'String'>
    readonly date: FieldRef<"BehaviorRecord", 'DateTime'>
    readonly type: FieldRef<"BehaviorRecord", 'BehaviorType'>
    readonly category: FieldRef<"BehaviorRecord", 'BehaviorCategory'>
    readonly description: FieldRef<"BehaviorRecord", 'String'>
    readonly severity: FieldRef<"BehaviorRecord", 'Severity'>
    readonly actionTaken: FieldRef<"BehaviorRecord", 'String'>
    readonly parentNotified: FieldRef<"BehaviorRecord", 'Boolean'>
    readonly followUpRequired: FieldRef<"BehaviorRecord", 'Boolean'>
    readonly createdAt: FieldRef<"BehaviorRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"BehaviorRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BehaviorRecord findUnique
   */
  export type BehaviorRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord findUniqueOrThrow
   */
  export type BehaviorRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord findFirst
   */
  export type BehaviorRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorRecords.
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorRecords.
     */
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * BehaviorRecord findFirstOrThrow
   */
  export type BehaviorRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecord to fetch.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorRecords.
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorRecords.
     */
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * BehaviorRecord findMany
   */
  export type BehaviorRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorRecords to fetch.
     */
    where?: BehaviorRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorRecords to fetch.
     */
    orderBy?: BehaviorRecordOrderByWithRelationInput | BehaviorRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehaviorRecords.
     */
    cursor?: BehaviorRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorRecords.
     */
    skip?: number
    distinct?: BehaviorRecordScalarFieldEnum | BehaviorRecordScalarFieldEnum[]
  }

  /**
   * BehaviorRecord create
   */
  export type BehaviorRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a BehaviorRecord.
     */
    data: XOR<BehaviorRecordCreateInput, BehaviorRecordUncheckedCreateInput>
  }

  /**
   * BehaviorRecord createMany
   */
  export type BehaviorRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehaviorRecords.
     */
    data: BehaviorRecordCreateManyInput | BehaviorRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehaviorRecord createManyAndReturn
   */
  export type BehaviorRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BehaviorRecords.
     */
    data: BehaviorRecordCreateManyInput | BehaviorRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BehaviorRecord update
   */
  export type BehaviorRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a BehaviorRecord.
     */
    data: XOR<BehaviorRecordUpdateInput, BehaviorRecordUncheckedUpdateInput>
    /**
     * Choose, which BehaviorRecord to update.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord updateMany
   */
  export type BehaviorRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehaviorRecords.
     */
    data: XOR<BehaviorRecordUpdateManyMutationInput, BehaviorRecordUncheckedUpdateManyInput>
    /**
     * Filter which BehaviorRecords to update
     */
    where?: BehaviorRecordWhereInput
  }

  /**
   * BehaviorRecord upsert
   */
  export type BehaviorRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the BehaviorRecord to update in case it exists.
     */
    where: BehaviorRecordWhereUniqueInput
    /**
     * In case the BehaviorRecord found by the `where` argument doesn't exist, create a new BehaviorRecord with this data.
     */
    create: XOR<BehaviorRecordCreateInput, BehaviorRecordUncheckedCreateInput>
    /**
     * In case the BehaviorRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehaviorRecordUpdateInput, BehaviorRecordUncheckedUpdateInput>
  }

  /**
   * BehaviorRecord delete
   */
  export type BehaviorRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
    /**
     * Filter which BehaviorRecord to delete.
     */
    where: BehaviorRecordWhereUniqueInput
  }

  /**
   * BehaviorRecord deleteMany
   */
  export type BehaviorRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorRecords to delete
     */
    where?: BehaviorRecordWhereInput
  }

  /**
   * BehaviorRecord without action
   */
  export type BehaviorRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorRecord
     */
    select?: BehaviorRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorRecordInclude<ExtArgs> | null
  }


  /**
   * Model ReportCard
   */

  export type AggregateReportCard = {
    _count: ReportCardCountAggregateOutputType | null
    _avg: ReportCardAvgAggregateOutputType | null
    _sum: ReportCardSumAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  export type ReportCardAvgAggregateOutputType = {
    overallAverage: number | null
    rank: number | null
    totalStudents: number | null
    totalDays: number | null
    presentDays: number | null
    absentDays: number | null
    lateCount: number | null
  }

  export type ReportCardSumAggregateOutputType = {
    overallAverage: number | null
    rank: number | null
    totalStudents: number | null
    totalDays: number | null
    presentDays: number | null
    absentDays: number | null
    lateCount: number | null
  }

  export type ReportCardMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicYear: string | null
    semester: string | null
    overallAverage: number | null
    rank: number | null
    totalStudents: number | null
    behaviorGrade: $Enums.BehaviorGrade | null
    totalDays: number | null
    presentDays: number | null
    absentDays: number | null
    lateCount: number | null
    principalComment: string | null
    generatedAt: Date | null
    generatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCardMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    academicYear: string | null
    semester: string | null
    overallAverage: number | null
    rank: number | null
    totalStudents: number | null
    behaviorGrade: $Enums.BehaviorGrade | null
    totalDays: number | null
    presentDays: number | null
    absentDays: number | null
    lateCount: number | null
    principalComment: string | null
    generatedAt: Date | null
    generatedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCardCountAggregateOutputType = {
    id: number
    studentId: number
    academicYear: number
    semester: number
    overallAverage: number
    rank: number
    totalStudents: number
    behaviorGrade: number
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment: number
    generatedAt: number
    generatedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportCardAvgAggregateInputType = {
    overallAverage?: true
    rank?: true
    totalStudents?: true
    totalDays?: true
    presentDays?: true
    absentDays?: true
    lateCount?: true
  }

  export type ReportCardSumAggregateInputType = {
    overallAverage?: true
    rank?: true
    totalStudents?: true
    totalDays?: true
    presentDays?: true
    absentDays?: true
    lateCount?: true
  }

  export type ReportCardMinAggregateInputType = {
    id?: true
    studentId?: true
    academicYear?: true
    semester?: true
    overallAverage?: true
    rank?: true
    totalStudents?: true
    behaviorGrade?: true
    totalDays?: true
    presentDays?: true
    absentDays?: true
    lateCount?: true
    principalComment?: true
    generatedAt?: true
    generatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCardMaxAggregateInputType = {
    id?: true
    studentId?: true
    academicYear?: true
    semester?: true
    overallAverage?: true
    rank?: true
    totalStudents?: true
    behaviorGrade?: true
    totalDays?: true
    presentDays?: true
    absentDays?: true
    lateCount?: true
    principalComment?: true
    generatedAt?: true
    generatedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCardCountAggregateInputType = {
    id?: true
    studentId?: true
    academicYear?: true
    semester?: true
    overallAverage?: true
    rank?: true
    totalStudents?: true
    behaviorGrade?: true
    totalDays?: true
    presentDays?: true
    absentDays?: true
    lateCount?: true
    principalComment?: true
    generatedAt?: true
    generatedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportCardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCard to aggregate.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportCards
    **/
    _count?: true | ReportCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportCardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportCardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportCardMaxAggregateInputType
  }

  export type GetReportCardAggregateType<T extends ReportCardAggregateArgs> = {
        [P in keyof T & keyof AggregateReportCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportCard[P]>
      : GetScalarType<T[P], AggregateReportCard[P]>
  }




  export type ReportCardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportCardWhereInput
    orderBy?: ReportCardOrderByWithAggregationInput | ReportCardOrderByWithAggregationInput[]
    by: ReportCardScalarFieldEnum[] | ReportCardScalarFieldEnum
    having?: ReportCardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCardCountAggregateInputType | true
    _avg?: ReportCardAvgAggregateInputType
    _sum?: ReportCardSumAggregateInputType
    _min?: ReportCardMinAggregateInputType
    _max?: ReportCardMaxAggregateInputType
  }

  export type ReportCardGroupByOutputType = {
    id: string
    studentId: string
    academicYear: string
    semester: string
    overallAverage: number
    rank: number | null
    totalStudents: number | null
    behaviorGrade: $Enums.BehaviorGrade
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment: string | null
    generatedAt: Date
    generatedBy: string
    createdAt: Date
    updatedAt: Date
    _count: ReportCardCountAggregateOutputType | null
    _avg: ReportCardAvgAggregateOutputType | null
    _sum: ReportCardSumAggregateOutputType | null
    _min: ReportCardMinAggregateOutputType | null
    _max: ReportCardMaxAggregateOutputType | null
  }

  type GetReportCardGroupByPayload<T extends ReportCardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportCardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportCardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
            : GetScalarType<T[P], ReportCardGroupByOutputType[P]>
        }
      >
    >


  export type ReportCardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicYear?: boolean
    semester?: boolean
    overallAverage?: boolean
    rank?: boolean
    totalStudents?: boolean
    behaviorGrade?: boolean
    totalDays?: boolean
    presentDays?: boolean
    absentDays?: boolean
    lateCount?: boolean
    principalComment?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    academicYear?: boolean
    semester?: boolean
    overallAverage?: boolean
    rank?: boolean
    totalStudents?: boolean
    behaviorGrade?: boolean
    totalDays?: boolean
    presentDays?: boolean
    absentDays?: boolean
    lateCount?: boolean
    principalComment?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportCard"]>

  export type ReportCardSelectScalar = {
    id?: boolean
    studentId?: boolean
    academicYear?: boolean
    semester?: boolean
    overallAverage?: boolean
    rank?: boolean
    totalStudents?: boolean
    behaviorGrade?: boolean
    totalDays?: boolean
    presentDays?: boolean
    absentDays?: boolean
    lateCount?: boolean
    principalComment?: boolean
    generatedAt?: boolean
    generatedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportCardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type ReportCardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $ReportCardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportCard"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      academicYear: string
      semester: string
      overallAverage: number
      rank: number | null
      totalStudents: number | null
      behaviorGrade: $Enums.BehaviorGrade
      totalDays: number
      presentDays: number
      absentDays: number
      lateCount: number
      principalComment: string | null
      generatedAt: Date
      generatedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportCard"]>
    composites: {}
  }

  type ReportCardGetPayload<S extends boolean | null | undefined | ReportCardDefaultArgs> = $Result.GetResult<Prisma.$ReportCardPayload, S>

  type ReportCardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportCardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCardCountAggregateInputType | true
    }

  export interface ReportCardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportCard'], meta: { name: 'ReportCard' } }
    /**
     * Find zero or one ReportCard that matches the filter.
     * @param {ReportCardFindUniqueArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportCardFindUniqueArgs>(args: SelectSubset<T, ReportCardFindUniqueArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReportCard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportCardFindUniqueOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportCardFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportCardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReportCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportCardFindFirstArgs>(args?: SelectSubset<T, ReportCardFindFirstArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReportCard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindFirstOrThrowArgs} args - Arguments to find a ReportCard
     * @example
     * // Get one ReportCard
     * const reportCard = await prisma.reportCard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportCardFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportCardFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReportCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportCards
     * const reportCards = await prisma.reportCard.findMany()
     * 
     * // Get first 10 ReportCards
     * const reportCards = await prisma.reportCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportCardFindManyArgs>(args?: SelectSubset<T, ReportCardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReportCard.
     * @param {ReportCardCreateArgs} args - Arguments to create a ReportCard.
     * @example
     * // Create one ReportCard
     * const ReportCard = await prisma.reportCard.create({
     *   data: {
     *     // ... data to create a ReportCard
     *   }
     * })
     * 
     */
    create<T extends ReportCardCreateArgs>(args: SelectSubset<T, ReportCardCreateArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReportCards.
     * @param {ReportCardCreateManyArgs} args - Arguments to create many ReportCards.
     * @example
     * // Create many ReportCards
     * const reportCard = await prisma.reportCard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCardCreateManyArgs>(args?: SelectSubset<T, ReportCardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportCards and returns the data saved in the database.
     * @param {ReportCardCreateManyAndReturnArgs} args - Arguments to create many ReportCards.
     * @example
     * // Create many ReportCards
     * const reportCard = await prisma.reportCard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportCards and only return the `id`
     * const reportCardWithIdOnly = await prisma.reportCard.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCardCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ReportCard.
     * @param {ReportCardDeleteArgs} args - Arguments to delete one ReportCard.
     * @example
     * // Delete one ReportCard
     * const ReportCard = await prisma.reportCard.delete({
     *   where: {
     *     // ... filter to delete one ReportCard
     *   }
     * })
     * 
     */
    delete<T extends ReportCardDeleteArgs>(args: SelectSubset<T, ReportCardDeleteArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReportCard.
     * @param {ReportCardUpdateArgs} args - Arguments to update one ReportCard.
     * @example
     * // Update one ReportCard
     * const reportCard = await prisma.reportCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportCardUpdateArgs>(args: SelectSubset<T, ReportCardUpdateArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReportCards.
     * @param {ReportCardDeleteManyArgs} args - Arguments to filter ReportCards to delete.
     * @example
     * // Delete a few ReportCards
     * const { count } = await prisma.reportCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportCardDeleteManyArgs>(args?: SelectSubset<T, ReportCardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportCards
     * const reportCard = await prisma.reportCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportCardUpdateManyArgs>(args: SelectSubset<T, ReportCardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportCard.
     * @param {ReportCardUpsertArgs} args - Arguments to update or create a ReportCard.
     * @example
     * // Update or create a ReportCard
     * const reportCard = await prisma.reportCard.upsert({
     *   create: {
     *     // ... data to create a ReportCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportCard we want to update
     *   }
     * })
     */
    upsert<T extends ReportCardUpsertArgs>(args: SelectSubset<T, ReportCardUpsertArgs<ExtArgs>>): Prisma__ReportCardClient<$Result.GetResult<Prisma.$ReportCardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReportCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardCountArgs} args - Arguments to filter ReportCards to count.
     * @example
     * // Count the number of ReportCards
     * const count = await prisma.reportCard.count({
     *   where: {
     *     // ... the filter for the ReportCards we want to count
     *   }
     * })
    **/
    count<T extends ReportCardCountArgs>(
      args?: Subset<T, ReportCardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportCardAggregateArgs>(args: Subset<T, ReportCardAggregateArgs>): Prisma.PrismaPromise<GetReportCardAggregateType<T>>

    /**
     * Group by ReportCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportCardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportCardGroupByArgs['orderBy'] }
        : { orderBy?: ReportCardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportCardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportCard model
   */
  readonly fields: ReportCardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportCardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportCard model
   */ 
  interface ReportCardFieldRefs {
    readonly id: FieldRef<"ReportCard", 'String'>
    readonly studentId: FieldRef<"ReportCard", 'String'>
    readonly academicYear: FieldRef<"ReportCard", 'String'>
    readonly semester: FieldRef<"ReportCard", 'String'>
    readonly overallAverage: FieldRef<"ReportCard", 'Float'>
    readonly rank: FieldRef<"ReportCard", 'Int'>
    readonly totalStudents: FieldRef<"ReportCard", 'Int'>
    readonly behaviorGrade: FieldRef<"ReportCard", 'BehaviorGrade'>
    readonly totalDays: FieldRef<"ReportCard", 'Int'>
    readonly presentDays: FieldRef<"ReportCard", 'Int'>
    readonly absentDays: FieldRef<"ReportCard", 'Int'>
    readonly lateCount: FieldRef<"ReportCard", 'Int'>
    readonly principalComment: FieldRef<"ReportCard", 'String'>
    readonly generatedAt: FieldRef<"ReportCard", 'DateTime'>
    readonly generatedBy: FieldRef<"ReportCard", 'String'>
    readonly createdAt: FieldRef<"ReportCard", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportCard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportCard findUnique
   */
  export type ReportCardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard findUniqueOrThrow
   */
  export type ReportCardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard findFirst
   */
  export type ReportCardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard findFirstOrThrow
   */
  export type ReportCardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCard to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportCards.
     */
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard findMany
   */
  export type ReportCardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter, which ReportCards to fetch.
     */
    where?: ReportCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportCards to fetch.
     */
    orderBy?: ReportCardOrderByWithRelationInput | ReportCardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportCards.
     */
    cursor?: ReportCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportCards.
     */
    skip?: number
    distinct?: ReportCardScalarFieldEnum | ReportCardScalarFieldEnum[]
  }

  /**
   * ReportCard create
   */
  export type ReportCardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportCard.
     */
    data: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
  }

  /**
   * ReportCard createMany
   */
  export type ReportCardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportCards.
     */
    data: ReportCardCreateManyInput | ReportCardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportCard createManyAndReturn
   */
  export type ReportCardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ReportCards.
     */
    data: ReportCardCreateManyInput | ReportCardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportCard update
   */
  export type ReportCardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportCard.
     */
    data: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
    /**
     * Choose, which ReportCard to update.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard updateMany
   */
  export type ReportCardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportCards.
     */
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyInput>
    /**
     * Filter which ReportCards to update
     */
    where?: ReportCardWhereInput
  }

  /**
   * ReportCard upsert
   */
  export type ReportCardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportCard to update in case it exists.
     */
    where: ReportCardWhereUniqueInput
    /**
     * In case the ReportCard found by the `where` argument doesn't exist, create a new ReportCard with this data.
     */
    create: XOR<ReportCardCreateInput, ReportCardUncheckedCreateInput>
    /**
     * In case the ReportCard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportCardUpdateInput, ReportCardUncheckedUpdateInput>
  }

  /**
   * ReportCard delete
   */
  export type ReportCardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
    /**
     * Filter which ReportCard to delete.
     */
    where: ReportCardWhereUniqueInput
  }

  /**
   * ReportCard deleteMany
   */
  export type ReportCardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportCards to delete
     */
    where?: ReportCardWhereInput
  }

  /**
   * ReportCard without action
   */
  export type ReportCardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCard
     */
    select?: ReportCardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportCardInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    recipientId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    category: $Enums.NotificationCategory | null
    read: boolean | null
    actionRequired: boolean | null
    actionUrl: string | null
    scheduledFor: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    recipientId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    category: $Enums.NotificationCategory | null
    read: boolean | null
    actionRequired: boolean | null
    actionUrl: string | null
    scheduledFor: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    recipientId: number
    title: number
    message: number
    type: number
    category: number
    read: number
    actionRequired: number
    actionUrl: number
    scheduledFor: number
    channels: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    recipientId?: true
    title?: true
    message?: true
    type?: true
    category?: true
    read?: true
    actionRequired?: true
    actionUrl?: true
    scheduledFor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    title?: true
    message?: true
    type?: true
    category?: true
    read?: true
    actionRequired?: true
    actionUrl?: true
    scheduledFor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    recipientId?: true
    title?: true
    message?: true
    type?: true
    category?: true
    read?: true
    actionRequired?: true
    actionUrl?: true
    scheduledFor?: true
    channels?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    recipientId: string
    title: string
    message: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    read: boolean
    actionRequired: boolean
    actionUrl: string | null
    scheduledFor: Date | null
    channels: $Enums.NotificationChannel[]
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    category?: boolean
    read?: boolean
    actionRequired?: boolean
    actionUrl?: boolean
    scheduledFor?: boolean
    channels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    category?: boolean
    read?: boolean
    actionRequired?: boolean
    actionUrl?: boolean
    scheduledFor?: boolean
    channels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    category?: boolean
    read?: boolean
    actionRequired?: boolean
    actionUrl?: boolean
    scheduledFor?: boolean
    channels?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipientId: string
      title: string
      message: string
      type: $Enums.NotificationType
      category: $Enums.NotificationCategory
      read: boolean
      actionRequired: boolean
      actionUrl: string | null
      scheduledFor: Date | null
      channels: $Enums.NotificationChannel[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly category: FieldRef<"Notification", 'NotificationCategory'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionRequired: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly scheduledFor: FieldRef<"Notification", 'DateTime'>
    readonly channels: FieldRef<"Notification", 'NotificationChannel[]'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model FileAttachment
   */

  export type AggregateFileAttachment = {
    _count: FileAttachmentCountAggregateOutputType | null
    _avg: FileAttachmentAvgAggregateOutputType | null
    _sum: FileAttachmentSumAggregateOutputType | null
    _min: FileAttachmentMinAggregateOutputType | null
    _max: FileAttachmentMaxAggregateOutputType | null
  }

  export type FileAttachmentAvgAggregateOutputType = {
    size: number | null
  }

  export type FileAttachmentSumAggregateOutputType = {
    size: number | null
  }

  export type FileAttachmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    url: string | null
    type: string | null
    size: number | null
    uploadedBy: string | null
    assignmentId: string | null
    submissionId: string | null
    messageId: string | null
    admissionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileAttachmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    originalName: string | null
    url: string | null
    type: string | null
    size: number | null
    uploadedBy: string | null
    assignmentId: string | null
    submissionId: string | null
    messageId: string | null
    admissionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileAttachmentCountAggregateOutputType = {
    id: number
    name: number
    originalName: number
    url: number
    type: number
    size: number
    uploadedBy: number
    assignmentId: number
    submissionId: number
    messageId: number
    admissionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileAttachmentAvgAggregateInputType = {
    size?: true
  }

  export type FileAttachmentSumAggregateInputType = {
    size?: true
  }

  export type FileAttachmentMinAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    url?: true
    type?: true
    size?: true
    uploadedBy?: true
    assignmentId?: true
    submissionId?: true
    messageId?: true
    admissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileAttachmentMaxAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    url?: true
    type?: true
    size?: true
    uploadedBy?: true
    assignmentId?: true
    submissionId?: true
    messageId?: true
    admissionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileAttachmentCountAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    url?: true
    type?: true
    size?: true
    uploadedBy?: true
    assignmentId?: true
    submissionId?: true
    messageId?: true
    admissionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileAttachment to aggregate.
     */
    where?: FileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAttachments to fetch.
     */
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileAttachments
    **/
    _count?: true | FileAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileAttachmentMaxAggregateInputType
  }

  export type GetFileAttachmentAggregateType<T extends FileAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateFileAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileAttachment[P]>
      : GetScalarType<T[P], AggregateFileAttachment[P]>
  }




  export type FileAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAttachmentWhereInput
    orderBy?: FileAttachmentOrderByWithAggregationInput | FileAttachmentOrderByWithAggregationInput[]
    by: FileAttachmentScalarFieldEnum[] | FileAttachmentScalarFieldEnum
    having?: FileAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileAttachmentCountAggregateInputType | true
    _avg?: FileAttachmentAvgAggregateInputType
    _sum?: FileAttachmentSumAggregateInputType
    _min?: FileAttachmentMinAggregateInputType
    _max?: FileAttachmentMaxAggregateInputType
  }

  export type FileAttachmentGroupByOutputType = {
    id: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId: string | null
    submissionId: string | null
    messageId: string | null
    admissionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: FileAttachmentCountAggregateOutputType | null
    _avg: FileAttachmentAvgAggregateOutputType | null
    _sum: FileAttachmentSumAggregateOutputType | null
    _min: FileAttachmentMinAggregateOutputType | null
    _max: FileAttachmentMaxAggregateOutputType | null
  }

  type GetFileAttachmentGroupByPayload<T extends FileAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], FileAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type FileAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    url?: boolean
    type?: boolean
    size?: boolean
    uploadedBy?: boolean
    assignmentId?: boolean
    submissionId?: boolean
    messageId?: boolean
    admissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignment?: boolean | FileAttachment$assignmentArgs<ExtArgs>
    submission?: boolean | FileAttachment$submissionArgs<ExtArgs>
    message?: boolean | FileAttachment$messageArgs<ExtArgs>
    admission?: boolean | FileAttachment$admissionArgs<ExtArgs>
  }, ExtArgs["result"]["fileAttachment"]>

  export type FileAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    url?: boolean
    type?: boolean
    size?: boolean
    uploadedBy?: boolean
    assignmentId?: boolean
    submissionId?: boolean
    messageId?: boolean
    admissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignment?: boolean | FileAttachment$assignmentArgs<ExtArgs>
    submission?: boolean | FileAttachment$submissionArgs<ExtArgs>
    message?: boolean | FileAttachment$messageArgs<ExtArgs>
    admission?: boolean | FileAttachment$admissionArgs<ExtArgs>
  }, ExtArgs["result"]["fileAttachment"]>

  export type FileAttachmentSelectScalar = {
    id?: boolean
    name?: boolean
    originalName?: boolean
    url?: boolean
    type?: boolean
    size?: boolean
    uploadedBy?: boolean
    assignmentId?: boolean
    submissionId?: boolean
    messageId?: boolean
    admissionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FileAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | FileAttachment$assignmentArgs<ExtArgs>
    submission?: boolean | FileAttachment$submissionArgs<ExtArgs>
    message?: boolean | FileAttachment$messageArgs<ExtArgs>
    admission?: boolean | FileAttachment$admissionArgs<ExtArgs>
  }
  export type FileAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | FileAttachment$assignmentArgs<ExtArgs>
    submission?: boolean | FileAttachment$submissionArgs<ExtArgs>
    message?: boolean | FileAttachment$messageArgs<ExtArgs>
    admission?: boolean | FileAttachment$admissionArgs<ExtArgs>
  }

  export type $FileAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileAttachment"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs> | null
      submission: Prisma.$AssignmentSubmissionPayload<ExtArgs> | null
      message: Prisma.$MessagePayload<ExtArgs> | null
      admission: Prisma.$AdmissionApplicationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      originalName: string
      url: string
      type: string
      size: number
      uploadedBy: string
      assignmentId: string | null
      submissionId: string | null
      messageId: string | null
      admissionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fileAttachment"]>
    composites: {}
  }

  type FileAttachmentGetPayload<S extends boolean | null | undefined | FileAttachmentDefaultArgs> = $Result.GetResult<Prisma.$FileAttachmentPayload, S>

  type FileAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileAttachmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileAttachmentCountAggregateInputType | true
    }

  export interface FileAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileAttachment'], meta: { name: 'FileAttachment' } }
    /**
     * Find zero or one FileAttachment that matches the filter.
     * @param {FileAttachmentFindUniqueArgs} args - Arguments to find a FileAttachment
     * @example
     * // Get one FileAttachment
     * const fileAttachment = await prisma.fileAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileAttachmentFindUniqueArgs>(args: SelectSubset<T, FileAttachmentFindUniqueArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FileAttachment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileAttachmentFindUniqueOrThrowArgs} args - Arguments to find a FileAttachment
     * @example
     * // Get one FileAttachment
     * const fileAttachment = await prisma.fileAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, FileAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FileAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAttachmentFindFirstArgs} args - Arguments to find a FileAttachment
     * @example
     * // Get one FileAttachment
     * const fileAttachment = await prisma.fileAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileAttachmentFindFirstArgs>(args?: SelectSubset<T, FileAttachmentFindFirstArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FileAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAttachmentFindFirstOrThrowArgs} args - Arguments to find a FileAttachment
     * @example
     * // Get one FileAttachment
     * const fileAttachment = await prisma.fileAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, FileAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FileAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileAttachments
     * const fileAttachments = await prisma.fileAttachment.findMany()
     * 
     * // Get first 10 FileAttachments
     * const fileAttachments = await prisma.fileAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileAttachmentWithIdOnly = await prisma.fileAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileAttachmentFindManyArgs>(args?: SelectSubset<T, FileAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FileAttachment.
     * @param {FileAttachmentCreateArgs} args - Arguments to create a FileAttachment.
     * @example
     * // Create one FileAttachment
     * const FileAttachment = await prisma.fileAttachment.create({
     *   data: {
     *     // ... data to create a FileAttachment
     *   }
     * })
     * 
     */
    create<T extends FileAttachmentCreateArgs>(args: SelectSubset<T, FileAttachmentCreateArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FileAttachments.
     * @param {FileAttachmentCreateManyArgs} args - Arguments to create many FileAttachments.
     * @example
     * // Create many FileAttachments
     * const fileAttachment = await prisma.fileAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileAttachmentCreateManyArgs>(args?: SelectSubset<T, FileAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileAttachments and returns the data saved in the database.
     * @param {FileAttachmentCreateManyAndReturnArgs} args - Arguments to create many FileAttachments.
     * @example
     * // Create many FileAttachments
     * const fileAttachment = await prisma.fileAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileAttachments and only return the `id`
     * const fileAttachmentWithIdOnly = await prisma.fileAttachment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, FileAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FileAttachment.
     * @param {FileAttachmentDeleteArgs} args - Arguments to delete one FileAttachment.
     * @example
     * // Delete one FileAttachment
     * const FileAttachment = await prisma.fileAttachment.delete({
     *   where: {
     *     // ... filter to delete one FileAttachment
     *   }
     * })
     * 
     */
    delete<T extends FileAttachmentDeleteArgs>(args: SelectSubset<T, FileAttachmentDeleteArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FileAttachment.
     * @param {FileAttachmentUpdateArgs} args - Arguments to update one FileAttachment.
     * @example
     * // Update one FileAttachment
     * const fileAttachment = await prisma.fileAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileAttachmentUpdateArgs>(args: SelectSubset<T, FileAttachmentUpdateArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FileAttachments.
     * @param {FileAttachmentDeleteManyArgs} args - Arguments to filter FileAttachments to delete.
     * @example
     * // Delete a few FileAttachments
     * const { count } = await prisma.fileAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileAttachmentDeleteManyArgs>(args?: SelectSubset<T, FileAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileAttachments
     * const fileAttachment = await prisma.fileAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileAttachmentUpdateManyArgs>(args: SelectSubset<T, FileAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileAttachment.
     * @param {FileAttachmentUpsertArgs} args - Arguments to update or create a FileAttachment.
     * @example
     * // Update or create a FileAttachment
     * const fileAttachment = await prisma.fileAttachment.upsert({
     *   create: {
     *     // ... data to create a FileAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileAttachment we want to update
     *   }
     * })
     */
    upsert<T extends FileAttachmentUpsertArgs>(args: SelectSubset<T, FileAttachmentUpsertArgs<ExtArgs>>): Prisma__FileAttachmentClient<$Result.GetResult<Prisma.$FileAttachmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FileAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAttachmentCountArgs} args - Arguments to filter FileAttachments to count.
     * @example
     * // Count the number of FileAttachments
     * const count = await prisma.fileAttachment.count({
     *   where: {
     *     // ... the filter for the FileAttachments we want to count
     *   }
     * })
    **/
    count<T extends FileAttachmentCountArgs>(
      args?: Subset<T, FileAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAttachmentAggregateArgs>(args: Subset<T, FileAttachmentAggregateArgs>): Prisma.PrismaPromise<GetFileAttachmentAggregateType<T>>

    /**
     * Group by FileAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: FileAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileAttachment model
   */
  readonly fields: FileAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends FileAttachment$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, FileAttachment$assignmentArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    submission<T extends FileAttachment$submissionArgs<ExtArgs> = {}>(args?: Subset<T, FileAttachment$submissionArgs<ExtArgs>>): Prisma__AssignmentSubmissionClient<$Result.GetResult<Prisma.$AssignmentSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    message<T extends FileAttachment$messageArgs<ExtArgs> = {}>(args?: Subset<T, FileAttachment$messageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    admission<T extends FileAttachment$admissionArgs<ExtArgs> = {}>(args?: Subset<T, FileAttachment$admissionArgs<ExtArgs>>): Prisma__AdmissionApplicationClient<$Result.GetResult<Prisma.$AdmissionApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileAttachment model
   */ 
  interface FileAttachmentFieldRefs {
    readonly id: FieldRef<"FileAttachment", 'String'>
    readonly name: FieldRef<"FileAttachment", 'String'>
    readonly originalName: FieldRef<"FileAttachment", 'String'>
    readonly url: FieldRef<"FileAttachment", 'String'>
    readonly type: FieldRef<"FileAttachment", 'String'>
    readonly size: FieldRef<"FileAttachment", 'Int'>
    readonly uploadedBy: FieldRef<"FileAttachment", 'String'>
    readonly assignmentId: FieldRef<"FileAttachment", 'String'>
    readonly submissionId: FieldRef<"FileAttachment", 'String'>
    readonly messageId: FieldRef<"FileAttachment", 'String'>
    readonly admissionId: FieldRef<"FileAttachment", 'String'>
    readonly createdAt: FieldRef<"FileAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"FileAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileAttachment findUnique
   */
  export type FileAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which FileAttachment to fetch.
     */
    where: FileAttachmentWhereUniqueInput
  }

  /**
   * FileAttachment findUniqueOrThrow
   */
  export type FileAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which FileAttachment to fetch.
     */
    where: FileAttachmentWhereUniqueInput
  }

  /**
   * FileAttachment findFirst
   */
  export type FileAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which FileAttachment to fetch.
     */
    where?: FileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAttachments to fetch.
     */
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileAttachments.
     */
    cursor?: FileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileAttachments.
     */
    distinct?: FileAttachmentScalarFieldEnum | FileAttachmentScalarFieldEnum[]
  }

  /**
   * FileAttachment findFirstOrThrow
   */
  export type FileAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which FileAttachment to fetch.
     */
    where?: FileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAttachments to fetch.
     */
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileAttachments.
     */
    cursor?: FileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileAttachments.
     */
    distinct?: FileAttachmentScalarFieldEnum | FileAttachmentScalarFieldEnum[]
  }

  /**
   * FileAttachment findMany
   */
  export type FileAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which FileAttachments to fetch.
     */
    where?: FileAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAttachments to fetch.
     */
    orderBy?: FileAttachmentOrderByWithRelationInput | FileAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileAttachments.
     */
    cursor?: FileAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAttachments.
     */
    skip?: number
    distinct?: FileAttachmentScalarFieldEnum | FileAttachmentScalarFieldEnum[]
  }

  /**
   * FileAttachment create
   */
  export type FileAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a FileAttachment.
     */
    data: XOR<FileAttachmentCreateInput, FileAttachmentUncheckedCreateInput>
  }

  /**
   * FileAttachment createMany
   */
  export type FileAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileAttachments.
     */
    data: FileAttachmentCreateManyInput | FileAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileAttachment createManyAndReturn
   */
  export type FileAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FileAttachments.
     */
    data: FileAttachmentCreateManyInput | FileAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileAttachment update
   */
  export type FileAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a FileAttachment.
     */
    data: XOR<FileAttachmentUpdateInput, FileAttachmentUncheckedUpdateInput>
    /**
     * Choose, which FileAttachment to update.
     */
    where: FileAttachmentWhereUniqueInput
  }

  /**
   * FileAttachment updateMany
   */
  export type FileAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileAttachments.
     */
    data: XOR<FileAttachmentUpdateManyMutationInput, FileAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which FileAttachments to update
     */
    where?: FileAttachmentWhereInput
  }

  /**
   * FileAttachment upsert
   */
  export type FileAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the FileAttachment to update in case it exists.
     */
    where: FileAttachmentWhereUniqueInput
    /**
     * In case the FileAttachment found by the `where` argument doesn't exist, create a new FileAttachment with this data.
     */
    create: XOR<FileAttachmentCreateInput, FileAttachmentUncheckedCreateInput>
    /**
     * In case the FileAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileAttachmentUpdateInput, FileAttachmentUncheckedUpdateInput>
  }

  /**
   * FileAttachment delete
   */
  export type FileAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
    /**
     * Filter which FileAttachment to delete.
     */
    where: FileAttachmentWhereUniqueInput
  }

  /**
   * FileAttachment deleteMany
   */
  export type FileAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileAttachments to delete
     */
    where?: FileAttachmentWhereInput
  }

  /**
   * FileAttachment.assignment
   */
  export type FileAttachment$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assignment
     */
    select?: AssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentInclude<ExtArgs> | null
    where?: AssignmentWhereInput
  }

  /**
   * FileAttachment.submission
   */
  export type FileAttachment$submissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentSubmission
     */
    select?: AssignmentSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentSubmissionInclude<ExtArgs> | null
    where?: AssignmentSubmissionWhereInput
  }

  /**
   * FileAttachment.message
   */
  export type FileAttachment$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * FileAttachment.admission
   */
  export type FileAttachment$admissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionApplication
     */
    select?: AdmissionApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionApplicationInclude<ExtArgs> | null
    where?: AdmissionApplicationWhereInput
  }

  /**
   * FileAttachment without action
   */
  export type FileAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAttachment
     */
    select?: FileAttachmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    deviceInfo: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    deviceInfo: number
    ipAddress: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    deviceInfo?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    deviceInfo: string | null
    ipAddress: string | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      deviceInfo: string | null
      ipAddress: string | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */ 
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly deviceInfo: FieldRef<"UserSession", 'String'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model TeacherSubject
   */

  export type AggregateTeacherSubject = {
    _count: TeacherSubjectCountAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  export type TeacherSubjectMinAggregateOutputType = {
    teacherId: string | null
    subjectId: string | null
  }

  export type TeacherSubjectMaxAggregateOutputType = {
    teacherId: string | null
    subjectId: string | null
  }

  export type TeacherSubjectCountAggregateOutputType = {
    teacherId: number
    subjectId: number
    _all: number
  }


  export type TeacherSubjectMinAggregateInputType = {
    teacherId?: true
    subjectId?: true
  }

  export type TeacherSubjectMaxAggregateInputType = {
    teacherId?: true
    subjectId?: true
  }

  export type TeacherSubjectCountAggregateInputType = {
    teacherId?: true
    subjectId?: true
    _all?: true
  }

  export type TeacherSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubject to aggregate.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherSubjects
    **/
    _count?: true | TeacherSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type GetTeacherSubjectAggregateType<T extends TeacherSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherSubject[P]>
      : GetScalarType<T[P], AggregateTeacherSubject[P]>
  }




  export type TeacherSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherSubjectWhereInput
    orderBy?: TeacherSubjectOrderByWithAggregationInput | TeacherSubjectOrderByWithAggregationInput[]
    by: TeacherSubjectScalarFieldEnum[] | TeacherSubjectScalarFieldEnum
    having?: TeacherSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherSubjectCountAggregateInputType | true
    _min?: TeacherSubjectMinAggregateInputType
    _max?: TeacherSubjectMaxAggregateInputType
  }

  export type TeacherSubjectGroupByOutputType = {
    teacherId: string
    subjectId: string
    _count: TeacherSubjectCountAggregateOutputType | null
    _min: TeacherSubjectMinAggregateOutputType | null
    _max: TeacherSubjectMaxAggregateOutputType | null
  }

  type GetTeacherSubjectGroupByPayload<T extends TeacherSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherSubjectGroupByOutputType[P]>
        }
      >
    >


  export type TeacherSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacherId?: boolean
    subjectId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacherId?: boolean
    subjectId?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherSubject"]>

  export type TeacherSubjectSelectScalar = {
    teacherId?: boolean
    subjectId?: boolean
  }

  export type TeacherSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type TeacherSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $TeacherSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherSubject"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      teacherId: string
      subjectId: string
    }, ExtArgs["result"]["teacherSubject"]>
    composites: {}
  }

  type TeacherSubjectGetPayload<S extends boolean | null | undefined | TeacherSubjectDefaultArgs> = $Result.GetResult<Prisma.$TeacherSubjectPayload, S>

  type TeacherSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherSubjectCountAggregateInputType | true
    }

  export interface TeacherSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherSubject'], meta: { name: 'TeacherSubject' } }
    /**
     * Find zero or one TeacherSubject that matches the filter.
     * @param {TeacherSubjectFindUniqueArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherSubjectFindUniqueArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherSubjectFindUniqueOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherSubjectFindFirstArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindFirstOrThrowArgs} args - Arguments to find a TeacherSubject
     * @example
     * // Get one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany()
     * 
     * // Get first 10 TeacherSubjects
     * const teacherSubjects = await prisma.teacherSubject.findMany({ take: 10 })
     * 
     * // Only select the `teacherId`
     * const teacherSubjectWithTeacherIdOnly = await prisma.teacherSubject.findMany({ select: { teacherId: true } })
     * 
     */
    findMany<T extends TeacherSubjectFindManyArgs>(args?: SelectSubset<T, TeacherSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherSubject.
     * @param {TeacherSubjectCreateArgs} args - Arguments to create a TeacherSubject.
     * @example
     * // Create one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.create({
     *   data: {
     *     // ... data to create a TeacherSubject
     *   }
     * })
     * 
     */
    create<T extends TeacherSubjectCreateArgs>(args: SelectSubset<T, TeacherSubjectCreateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherSubjects.
     * @param {TeacherSubjectCreateManyArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherSubjectCreateManyArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherSubjects and returns the data saved in the database.
     * @param {TeacherSubjectCreateManyAndReturnArgs} args - Arguments to create many TeacherSubjects.
     * @example
     * // Create many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherSubjects and only return the `teacherId`
     * const teacherSubjectWithTeacherIdOnly = await prisma.teacherSubject.createManyAndReturn({ 
     *   select: { teacherId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherSubject.
     * @param {TeacherSubjectDeleteArgs} args - Arguments to delete one TeacherSubject.
     * @example
     * // Delete one TeacherSubject
     * const TeacherSubject = await prisma.teacherSubject.delete({
     *   where: {
     *     // ... filter to delete one TeacherSubject
     *   }
     * })
     * 
     */
    delete<T extends TeacherSubjectDeleteArgs>(args: SelectSubset<T, TeacherSubjectDeleteArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherSubject.
     * @param {TeacherSubjectUpdateArgs} args - Arguments to update one TeacherSubject.
     * @example
     * // Update one TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherSubjectUpdateArgs>(args: SelectSubset<T, TeacherSubjectUpdateArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherSubjects.
     * @param {TeacherSubjectDeleteManyArgs} args - Arguments to filter TeacherSubjects to delete.
     * @example
     * // Delete a few TeacherSubjects
     * const { count } = await prisma.teacherSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherSubjectDeleteManyArgs>(args?: SelectSubset<T, TeacherSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherSubjects
     * const teacherSubject = await prisma.teacherSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherSubjectUpdateManyArgs>(args: SelectSubset<T, TeacherSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherSubject.
     * @param {TeacherSubjectUpsertArgs} args - Arguments to update or create a TeacherSubject.
     * @example
     * // Update or create a TeacherSubject
     * const teacherSubject = await prisma.teacherSubject.upsert({
     *   create: {
     *     // ... data to create a TeacherSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherSubject we want to update
     *   }
     * })
     */
    upsert<T extends TeacherSubjectUpsertArgs>(args: SelectSubset<T, TeacherSubjectUpsertArgs<ExtArgs>>): Prisma__TeacherSubjectClient<$Result.GetResult<Prisma.$TeacherSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectCountArgs} args - Arguments to filter TeacherSubjects to count.
     * @example
     * // Count the number of TeacherSubjects
     * const count = await prisma.teacherSubject.count({
     *   where: {
     *     // ... the filter for the TeacherSubjects we want to count
     *   }
     * })
    **/
    count<T extends TeacherSubjectCountArgs>(
      args?: Subset<T, TeacherSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherSubjectAggregateArgs>(args: Subset<T, TeacherSubjectAggregateArgs>): Prisma.PrismaPromise<GetTeacherSubjectAggregateType<T>>

    /**
     * Group by TeacherSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherSubjectGroupByArgs['orderBy'] }
        : { orderBy?: TeacherSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherSubject model
   */
  readonly fields: TeacherSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherSubject model
   */ 
  interface TeacherSubjectFieldRefs {
    readonly teacherId: FieldRef<"TeacherSubject", 'String'>
    readonly subjectId: FieldRef<"TeacherSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherSubject findUnique
   */
  export type TeacherSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findUniqueOrThrow
   */
  export type TeacherSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject findFirst
   */
  export type TeacherSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findFirstOrThrow
   */
  export type TeacherSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubject to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherSubjects.
     */
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject findMany
   */
  export type TeacherSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter, which TeacherSubjects to fetch.
     */
    where?: TeacherSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherSubjects to fetch.
     */
    orderBy?: TeacherSubjectOrderByWithRelationInput | TeacherSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherSubjects.
     */
    cursor?: TeacherSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherSubjects.
     */
    skip?: number
    distinct?: TeacherSubjectScalarFieldEnum | TeacherSubjectScalarFieldEnum[]
  }

  /**
   * TeacherSubject create
   */
  export type TeacherSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherSubject.
     */
    data: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
  }

  /**
   * TeacherSubject createMany
   */
  export type TeacherSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherSubject createManyAndReturn
   */
  export type TeacherSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherSubjects.
     */
    data: TeacherSubjectCreateManyInput | TeacherSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherSubject update
   */
  export type TeacherSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherSubject.
     */
    data: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
    /**
     * Choose, which TeacherSubject to update.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject updateMany
   */
  export type TeacherSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherSubjects.
     */
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyInput>
    /**
     * Filter which TeacherSubjects to update
     */
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherSubject upsert
   */
  export type TeacherSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherSubject to update in case it exists.
     */
    where: TeacherSubjectWhereUniqueInput
    /**
     * In case the TeacherSubject found by the `where` argument doesn't exist, create a new TeacherSubject with this data.
     */
    create: XOR<TeacherSubjectCreateInput, TeacherSubjectUncheckedCreateInput>
    /**
     * In case the TeacherSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherSubjectUpdateInput, TeacherSubjectUncheckedUpdateInput>
  }

  /**
   * TeacherSubject delete
   */
  export type TeacherSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
    /**
     * Filter which TeacherSubject to delete.
     */
    where: TeacherSubjectWhereUniqueInput
  }

  /**
   * TeacherSubject deleteMany
   */
  export type TeacherSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherSubjects to delete
     */
    where?: TeacherSubjectWhereInput
  }

  /**
   * TeacherSubject without action
   */
  export type TeacherSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherSubject
     */
    select?: TeacherSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherSubjectInclude<ExtArgs> | null
  }


  /**
   * Model TeacherClass
   */

  export type AggregateTeacherClass = {
    _count: TeacherClassCountAggregateOutputType | null
    _min: TeacherClassMinAggregateOutputType | null
    _max: TeacherClassMaxAggregateOutputType | null
  }

  export type TeacherClassMinAggregateOutputType = {
    teacherId: string | null
    classId: string | null
    isMainTeacher: boolean | null
  }

  export type TeacherClassMaxAggregateOutputType = {
    teacherId: string | null
    classId: string | null
    isMainTeacher: boolean | null
  }

  export type TeacherClassCountAggregateOutputType = {
    teacherId: number
    classId: number
    isMainTeacher: number
    _all: number
  }


  export type TeacherClassMinAggregateInputType = {
    teacherId?: true
    classId?: true
    isMainTeacher?: true
  }

  export type TeacherClassMaxAggregateInputType = {
    teacherId?: true
    classId?: true
    isMainTeacher?: true
  }

  export type TeacherClassCountAggregateInputType = {
    teacherId?: true
    classId?: true
    isMainTeacher?: true
    _all?: true
  }

  export type TeacherClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherClass to aggregate.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherClasses
    **/
    _count?: true | TeacherClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherClassMaxAggregateInputType
  }

  export type GetTeacherClassAggregateType<T extends TeacherClassAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherClass[P]>
      : GetScalarType<T[P], AggregateTeacherClass[P]>
  }




  export type TeacherClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherClassWhereInput
    orderBy?: TeacherClassOrderByWithAggregationInput | TeacherClassOrderByWithAggregationInput[]
    by: TeacherClassScalarFieldEnum[] | TeacherClassScalarFieldEnum
    having?: TeacherClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherClassCountAggregateInputType | true
    _min?: TeacherClassMinAggregateInputType
    _max?: TeacherClassMaxAggregateInputType
  }

  export type TeacherClassGroupByOutputType = {
    teacherId: string
    classId: string
    isMainTeacher: boolean
    _count: TeacherClassCountAggregateOutputType | null
    _min: TeacherClassMinAggregateOutputType | null
    _max: TeacherClassMaxAggregateOutputType | null
  }

  type GetTeacherClassGroupByPayload<T extends TeacherClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherClassGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherClassGroupByOutputType[P]>
        }
      >
    >


  export type TeacherClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacherId?: boolean
    classId?: boolean
    isMainTeacher?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherClass"]>

  export type TeacherClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teacherId?: boolean
    classId?: boolean
    isMainTeacher?: boolean
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherClass"]>

  export type TeacherClassSelectScalar = {
    teacherId?: boolean
    classId?: boolean
    isMainTeacher?: boolean
  }

  export type TeacherClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type TeacherClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $TeacherClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherClass"
    objects: {
      teacher: Prisma.$TeacherPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      teacherId: string
      classId: string
      isMainTeacher: boolean
    }, ExtArgs["result"]["teacherClass"]>
    composites: {}
  }

  type TeacherClassGetPayload<S extends boolean | null | undefined | TeacherClassDefaultArgs> = $Result.GetResult<Prisma.$TeacherClassPayload, S>

  type TeacherClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeacherClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeacherClassCountAggregateInputType | true
    }

  export interface TeacherClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherClass'], meta: { name: 'TeacherClass' } }
    /**
     * Find zero or one TeacherClass that matches the filter.
     * @param {TeacherClassFindUniqueArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherClassFindUniqueArgs>(args: SelectSubset<T, TeacherClassFindUniqueArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeacherClass that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeacherClassFindUniqueOrThrowArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherClassFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeacherClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassFindFirstArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherClassFindFirstArgs>(args?: SelectSubset<T, TeacherClassFindFirstArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeacherClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassFindFirstOrThrowArgs} args - Arguments to find a TeacherClass
     * @example
     * // Get one TeacherClass
     * const teacherClass = await prisma.teacherClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherClassFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeacherClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherClasses
     * const teacherClasses = await prisma.teacherClass.findMany()
     * 
     * // Get first 10 TeacherClasses
     * const teacherClasses = await prisma.teacherClass.findMany({ take: 10 })
     * 
     * // Only select the `teacherId`
     * const teacherClassWithTeacherIdOnly = await prisma.teacherClass.findMany({ select: { teacherId: true } })
     * 
     */
    findMany<T extends TeacherClassFindManyArgs>(args?: SelectSubset<T, TeacherClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeacherClass.
     * @param {TeacherClassCreateArgs} args - Arguments to create a TeacherClass.
     * @example
     * // Create one TeacherClass
     * const TeacherClass = await prisma.teacherClass.create({
     *   data: {
     *     // ... data to create a TeacherClass
     *   }
     * })
     * 
     */
    create<T extends TeacherClassCreateArgs>(args: SelectSubset<T, TeacherClassCreateArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeacherClasses.
     * @param {TeacherClassCreateManyArgs} args - Arguments to create many TeacherClasses.
     * @example
     * // Create many TeacherClasses
     * const teacherClass = await prisma.teacherClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherClassCreateManyArgs>(args?: SelectSubset<T, TeacherClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherClasses and returns the data saved in the database.
     * @param {TeacherClassCreateManyAndReturnArgs} args - Arguments to create many TeacherClasses.
     * @example
     * // Create many TeacherClasses
     * const teacherClass = await prisma.teacherClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherClasses and only return the `teacherId`
     * const teacherClassWithTeacherIdOnly = await prisma.teacherClass.createManyAndReturn({ 
     *   select: { teacherId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherClassCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TeacherClass.
     * @param {TeacherClassDeleteArgs} args - Arguments to delete one TeacherClass.
     * @example
     * // Delete one TeacherClass
     * const TeacherClass = await prisma.teacherClass.delete({
     *   where: {
     *     // ... filter to delete one TeacherClass
     *   }
     * })
     * 
     */
    delete<T extends TeacherClassDeleteArgs>(args: SelectSubset<T, TeacherClassDeleteArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeacherClass.
     * @param {TeacherClassUpdateArgs} args - Arguments to update one TeacherClass.
     * @example
     * // Update one TeacherClass
     * const teacherClass = await prisma.teacherClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherClassUpdateArgs>(args: SelectSubset<T, TeacherClassUpdateArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeacherClasses.
     * @param {TeacherClassDeleteManyArgs} args - Arguments to filter TeacherClasses to delete.
     * @example
     * // Delete a few TeacherClasses
     * const { count } = await prisma.teacherClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherClassDeleteManyArgs>(args?: SelectSubset<T, TeacherClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherClasses
     * const teacherClass = await prisma.teacherClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherClassUpdateManyArgs>(args: SelectSubset<T, TeacherClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeacherClass.
     * @param {TeacherClassUpsertArgs} args - Arguments to update or create a TeacherClass.
     * @example
     * // Update or create a TeacherClass
     * const teacherClass = await prisma.teacherClass.upsert({
     *   create: {
     *     // ... data to create a TeacherClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherClass we want to update
     *   }
     * })
     */
    upsert<T extends TeacherClassUpsertArgs>(args: SelectSubset<T, TeacherClassUpsertArgs<ExtArgs>>): Prisma__TeacherClassClient<$Result.GetResult<Prisma.$TeacherClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeacherClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassCountArgs} args - Arguments to filter TeacherClasses to count.
     * @example
     * // Count the number of TeacherClasses
     * const count = await prisma.teacherClass.count({
     *   where: {
     *     // ... the filter for the TeacherClasses we want to count
     *   }
     * })
    **/
    count<T extends TeacherClassCountArgs>(
      args?: Subset<T, TeacherClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherClassAggregateArgs>(args: Subset<T, TeacherClassAggregateArgs>): Prisma.PrismaPromise<GetTeacherClassAggregateType<T>>

    /**
     * Group by TeacherClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherClassGroupByArgs['orderBy'] }
        : { orderBy?: TeacherClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherClass model
   */
  readonly fields: TeacherClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherDefaultArgs<ExtArgs>>): Prisma__TeacherClient<$Result.GetResult<Prisma.$TeacherPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherClass model
   */ 
  interface TeacherClassFieldRefs {
    readonly teacherId: FieldRef<"TeacherClass", 'String'>
    readonly classId: FieldRef<"TeacherClass", 'String'>
    readonly isMainTeacher: FieldRef<"TeacherClass", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TeacherClass findUnique
   */
  export type TeacherClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass findUniqueOrThrow
   */
  export type TeacherClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass findFirst
   */
  export type TeacherClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherClasses.
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherClasses.
     */
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * TeacherClass findFirstOrThrow
   */
  export type TeacherClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClass to fetch.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherClasses.
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherClasses.
     */
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * TeacherClass findMany
   */
  export type TeacherClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter, which TeacherClasses to fetch.
     */
    where?: TeacherClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherClasses to fetch.
     */
    orderBy?: TeacherClassOrderByWithRelationInput | TeacherClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherClasses.
     */
    cursor?: TeacherClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeacherClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherClasses.
     */
    skip?: number
    distinct?: TeacherClassScalarFieldEnum | TeacherClassScalarFieldEnum[]
  }

  /**
   * TeacherClass create
   */
  export type TeacherClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherClass.
     */
    data: XOR<TeacherClassCreateInput, TeacherClassUncheckedCreateInput>
  }

  /**
   * TeacherClass createMany
   */
  export type TeacherClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherClasses.
     */
    data: TeacherClassCreateManyInput | TeacherClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherClass createManyAndReturn
   */
  export type TeacherClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TeacherClasses.
     */
    data: TeacherClassCreateManyInput | TeacherClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherClass update
   */
  export type TeacherClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherClass.
     */
    data: XOR<TeacherClassUpdateInput, TeacherClassUncheckedUpdateInput>
    /**
     * Choose, which TeacherClass to update.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass updateMany
   */
  export type TeacherClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherClasses.
     */
    data: XOR<TeacherClassUpdateManyMutationInput, TeacherClassUncheckedUpdateManyInput>
    /**
     * Filter which TeacherClasses to update
     */
    where?: TeacherClassWhereInput
  }

  /**
   * TeacherClass upsert
   */
  export type TeacherClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherClass to update in case it exists.
     */
    where: TeacherClassWhereUniqueInput
    /**
     * In case the TeacherClass found by the `where` argument doesn't exist, create a new TeacherClass with this data.
     */
    create: XOR<TeacherClassCreateInput, TeacherClassUncheckedCreateInput>
    /**
     * In case the TeacherClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherClassUpdateInput, TeacherClassUncheckedUpdateInput>
  }

  /**
   * TeacherClass delete
   */
  export type TeacherClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
    /**
     * Filter which TeacherClass to delete.
     */
    where: TeacherClassWhereUniqueInput
  }

  /**
   * TeacherClass deleteMany
   */
  export type TeacherClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherClasses to delete
     */
    where?: TeacherClassWhereInput
  }

  /**
   * TeacherClass without action
   */
  export type TeacherClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherClass
     */
    select?: TeacherClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherClassInclude<ExtArgs> | null
  }


  /**
   * Model ClassSubject
   */

  export type AggregateClassSubject = {
    _count: ClassSubjectCountAggregateOutputType | null
    _min: ClassSubjectMinAggregateOutputType | null
    _max: ClassSubjectMaxAggregateOutputType | null
  }

  export type ClassSubjectMinAggregateOutputType = {
    classId: string | null
    subjectId: string | null
  }

  export type ClassSubjectMaxAggregateOutputType = {
    classId: string | null
    subjectId: string | null
  }

  export type ClassSubjectCountAggregateOutputType = {
    classId: number
    subjectId: number
    _all: number
  }


  export type ClassSubjectMinAggregateInputType = {
    classId?: true
    subjectId?: true
  }

  export type ClassSubjectMaxAggregateInputType = {
    classId?: true
    subjectId?: true
  }

  export type ClassSubjectCountAggregateInputType = {
    classId?: true
    subjectId?: true
    _all?: true
  }

  export type ClassSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSubject to aggregate.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassSubjects
    **/
    _count?: true | ClassSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassSubjectMaxAggregateInputType
  }

  export type GetClassSubjectAggregateType<T extends ClassSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateClassSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassSubject[P]>
      : GetScalarType<T[P], AggregateClassSubject[P]>
  }




  export type ClassSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassSubjectWhereInput
    orderBy?: ClassSubjectOrderByWithAggregationInput | ClassSubjectOrderByWithAggregationInput[]
    by: ClassSubjectScalarFieldEnum[] | ClassSubjectScalarFieldEnum
    having?: ClassSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassSubjectCountAggregateInputType | true
    _min?: ClassSubjectMinAggregateInputType
    _max?: ClassSubjectMaxAggregateInputType
  }

  export type ClassSubjectGroupByOutputType = {
    classId: string
    subjectId: string
    _count: ClassSubjectCountAggregateOutputType | null
    _min: ClassSubjectMinAggregateOutputType | null
    _max: ClassSubjectMaxAggregateOutputType | null
  }

  type GetClassSubjectGroupByPayload<T extends ClassSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], ClassSubjectGroupByOutputType[P]>
        }
      >
    >


  export type ClassSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    subjectId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSubject"]>

  export type ClassSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    classId?: boolean
    subjectId?: boolean
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classSubject"]>

  export type ClassSubjectSelectScalar = {
    classId?: boolean
    subjectId?: boolean
  }

  export type ClassSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ClassSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    class?: boolean | ClassDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $ClassSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassSubject"
    objects: {
      class: Prisma.$ClassPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      classId: string
      subjectId: string
    }, ExtArgs["result"]["classSubject"]>
    composites: {}
  }

  type ClassSubjectGetPayload<S extends boolean | null | undefined | ClassSubjectDefaultArgs> = $Result.GetResult<Prisma.$ClassSubjectPayload, S>

  type ClassSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClassSubjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClassSubjectCountAggregateInputType | true
    }

  export interface ClassSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassSubject'], meta: { name: 'ClassSubject' } }
    /**
     * Find zero or one ClassSubject that matches the filter.
     * @param {ClassSubjectFindUniqueArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassSubjectFindUniqueArgs>(args: SelectSubset<T, ClassSubjectFindUniqueArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClassSubject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClassSubjectFindUniqueOrThrowArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClassSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindFirstArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassSubjectFindFirstArgs>(args?: SelectSubset<T, ClassSubjectFindFirstArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClassSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindFirstOrThrowArgs} args - Arguments to find a ClassSubject
     * @example
     * // Get one ClassSubject
     * const classSubject = await prisma.classSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClassSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassSubjects
     * const classSubjects = await prisma.classSubject.findMany()
     * 
     * // Get first 10 ClassSubjects
     * const classSubjects = await prisma.classSubject.findMany({ take: 10 })
     * 
     * // Only select the `classId`
     * const classSubjectWithClassIdOnly = await prisma.classSubject.findMany({ select: { classId: true } })
     * 
     */
    findMany<T extends ClassSubjectFindManyArgs>(args?: SelectSubset<T, ClassSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClassSubject.
     * @param {ClassSubjectCreateArgs} args - Arguments to create a ClassSubject.
     * @example
     * // Create one ClassSubject
     * const ClassSubject = await prisma.classSubject.create({
     *   data: {
     *     // ... data to create a ClassSubject
     *   }
     * })
     * 
     */
    create<T extends ClassSubjectCreateArgs>(args: SelectSubset<T, ClassSubjectCreateArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClassSubjects.
     * @param {ClassSubjectCreateManyArgs} args - Arguments to create many ClassSubjects.
     * @example
     * // Create many ClassSubjects
     * const classSubject = await prisma.classSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassSubjectCreateManyArgs>(args?: SelectSubset<T, ClassSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassSubjects and returns the data saved in the database.
     * @param {ClassSubjectCreateManyAndReturnArgs} args - Arguments to create many ClassSubjects.
     * @example
     * // Create many ClassSubjects
     * const classSubject = await prisma.classSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassSubjects and only return the `classId`
     * const classSubjectWithClassIdOnly = await prisma.classSubject.createManyAndReturn({ 
     *   select: { classId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClassSubject.
     * @param {ClassSubjectDeleteArgs} args - Arguments to delete one ClassSubject.
     * @example
     * // Delete one ClassSubject
     * const ClassSubject = await prisma.classSubject.delete({
     *   where: {
     *     // ... filter to delete one ClassSubject
     *   }
     * })
     * 
     */
    delete<T extends ClassSubjectDeleteArgs>(args: SelectSubset<T, ClassSubjectDeleteArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClassSubject.
     * @param {ClassSubjectUpdateArgs} args - Arguments to update one ClassSubject.
     * @example
     * // Update one ClassSubject
     * const classSubject = await prisma.classSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassSubjectUpdateArgs>(args: SelectSubset<T, ClassSubjectUpdateArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClassSubjects.
     * @param {ClassSubjectDeleteManyArgs} args - Arguments to filter ClassSubjects to delete.
     * @example
     * // Delete a few ClassSubjects
     * const { count } = await prisma.classSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassSubjectDeleteManyArgs>(args?: SelectSubset<T, ClassSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassSubjects
     * const classSubject = await prisma.classSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassSubjectUpdateManyArgs>(args: SelectSubset<T, ClassSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClassSubject.
     * @param {ClassSubjectUpsertArgs} args - Arguments to update or create a ClassSubject.
     * @example
     * // Update or create a ClassSubject
     * const classSubject = await prisma.classSubject.upsert({
     *   create: {
     *     // ... data to create a ClassSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassSubject we want to update
     *   }
     * })
     */
    upsert<T extends ClassSubjectUpsertArgs>(args: SelectSubset<T, ClassSubjectUpsertArgs<ExtArgs>>): Prisma__ClassSubjectClient<$Result.GetResult<Prisma.$ClassSubjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClassSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectCountArgs} args - Arguments to filter ClassSubjects to count.
     * @example
     * // Count the number of ClassSubjects
     * const count = await prisma.classSubject.count({
     *   where: {
     *     // ... the filter for the ClassSubjects we want to count
     *   }
     * })
    **/
    count<T extends ClassSubjectCountArgs>(
      args?: Subset<T, ClassSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassSubjectAggregateArgs>(args: Subset<T, ClassSubjectAggregateArgs>): Prisma.PrismaPromise<GetClassSubjectAggregateType<T>>

    /**
     * Group by ClassSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassSubjectGroupByArgs['orderBy'] }
        : { orderBy?: ClassSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassSubject model
   */
  readonly fields: ClassSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassSubject model
   */ 
  interface ClassSubjectFieldRefs {
    readonly classId: FieldRef<"ClassSubject", 'String'>
    readonly subjectId: FieldRef<"ClassSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ClassSubject findUnique
   */
  export type ClassSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject findUniqueOrThrow
   */
  export type ClassSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject findFirst
   */
  export type ClassSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSubjects.
     */
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject findFirstOrThrow
   */
  export type ClassSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubject to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassSubjects.
     */
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject findMany
   */
  export type ClassSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter, which ClassSubjects to fetch.
     */
    where?: ClassSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassSubjects to fetch.
     */
    orderBy?: ClassSubjectOrderByWithRelationInput | ClassSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassSubjects.
     */
    cursor?: ClassSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassSubjects.
     */
    skip?: number
    distinct?: ClassSubjectScalarFieldEnum | ClassSubjectScalarFieldEnum[]
  }

  /**
   * ClassSubject create
   */
  export type ClassSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassSubject.
     */
    data: XOR<ClassSubjectCreateInput, ClassSubjectUncheckedCreateInput>
  }

  /**
   * ClassSubject createMany
   */
  export type ClassSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassSubjects.
     */
    data: ClassSubjectCreateManyInput | ClassSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassSubject createManyAndReturn
   */
  export type ClassSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClassSubjects.
     */
    data: ClassSubjectCreateManyInput | ClassSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClassSubject update
   */
  export type ClassSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassSubject.
     */
    data: XOR<ClassSubjectUpdateInput, ClassSubjectUncheckedUpdateInput>
    /**
     * Choose, which ClassSubject to update.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject updateMany
   */
  export type ClassSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassSubjects.
     */
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyInput>
    /**
     * Filter which ClassSubjects to update
     */
    where?: ClassSubjectWhereInput
  }

  /**
   * ClassSubject upsert
   */
  export type ClassSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassSubject to update in case it exists.
     */
    where: ClassSubjectWhereUniqueInput
    /**
     * In case the ClassSubject found by the `where` argument doesn't exist, create a new ClassSubject with this data.
     */
    create: XOR<ClassSubjectCreateInput, ClassSubjectUncheckedCreateInput>
    /**
     * In case the ClassSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassSubjectUpdateInput, ClassSubjectUncheckedUpdateInput>
  }

  /**
   * ClassSubject delete
   */
  export type ClassSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
    /**
     * Filter which ClassSubject to delete.
     */
    where: ClassSubjectWhereUniqueInput
  }

  /**
   * ClassSubject deleteMany
   */
  export type ClassSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassSubjects to delete
     */
    where?: ClassSubjectWhereInput
  }

  /**
   * ClassSubject without action
   */
  export type ClassSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassSubject
     */
    select?: ClassSubjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassSubjectInclude<ExtArgs> | null
  }


  /**
   * Model AssignmentClass
   */

  export type AggregateAssignmentClass = {
    _count: AssignmentClassCountAggregateOutputType | null
    _min: AssignmentClassMinAggregateOutputType | null
    _max: AssignmentClassMaxAggregateOutputType | null
  }

  export type AssignmentClassMinAggregateOutputType = {
    assignmentId: string | null
    classId: string | null
  }

  export type AssignmentClassMaxAggregateOutputType = {
    assignmentId: string | null
    classId: string | null
  }

  export type AssignmentClassCountAggregateOutputType = {
    assignmentId: number
    classId: number
    _all: number
  }


  export type AssignmentClassMinAggregateInputType = {
    assignmentId?: true
    classId?: true
  }

  export type AssignmentClassMaxAggregateInputType = {
    assignmentId?: true
    classId?: true
  }

  export type AssignmentClassCountAggregateInputType = {
    assignmentId?: true
    classId?: true
    _all?: true
  }

  export type AssignmentClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentClass to aggregate.
     */
    where?: AssignmentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentClasses to fetch.
     */
    orderBy?: AssignmentClassOrderByWithRelationInput | AssignmentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssignmentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AssignmentClasses
    **/
    _count?: true | AssignmentClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentClassMaxAggregateInputType
  }

  export type GetAssignmentClassAggregateType<T extends AssignmentClassAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignmentClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignmentClass[P]>
      : GetScalarType<T[P], AggregateAssignmentClass[P]>
  }




  export type AssignmentClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssignmentClassWhereInput
    orderBy?: AssignmentClassOrderByWithAggregationInput | AssignmentClassOrderByWithAggregationInput[]
    by: AssignmentClassScalarFieldEnum[] | AssignmentClassScalarFieldEnum
    having?: AssignmentClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentClassCountAggregateInputType | true
    _min?: AssignmentClassMinAggregateInputType
    _max?: AssignmentClassMaxAggregateInputType
  }

  export type AssignmentClassGroupByOutputType = {
    assignmentId: string
    classId: string
    _count: AssignmentClassCountAggregateOutputType | null
    _min: AssignmentClassMinAggregateOutputType | null
    _max: AssignmentClassMaxAggregateOutputType | null
  }

  type GetAssignmentClassGroupByPayload<T extends AssignmentClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentClassGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentClassGroupByOutputType[P]>
        }
      >
    >


  export type AssignmentClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignmentId?: boolean
    classId?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentClass"]>

  export type AssignmentClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    assignmentId?: boolean
    classId?: boolean
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assignmentClass"]>

  export type AssignmentClassSelectScalar = {
    assignmentId?: boolean
    classId?: boolean
  }

  export type AssignmentClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }
  export type AssignmentClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignment?: boolean | AssignmentDefaultArgs<ExtArgs>
    class?: boolean | ClassDefaultArgs<ExtArgs>
  }

  export type $AssignmentClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssignmentClass"
    objects: {
      assignment: Prisma.$AssignmentPayload<ExtArgs>
      class: Prisma.$ClassPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      assignmentId: string
      classId: string
    }, ExtArgs["result"]["assignmentClass"]>
    composites: {}
  }

  type AssignmentClassGetPayload<S extends boolean | null | undefined | AssignmentClassDefaultArgs> = $Result.GetResult<Prisma.$AssignmentClassPayload, S>

  type AssignmentClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AssignmentClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AssignmentClassCountAggregateInputType | true
    }

  export interface AssignmentClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssignmentClass'], meta: { name: 'AssignmentClass' } }
    /**
     * Find zero or one AssignmentClass that matches the filter.
     * @param {AssignmentClassFindUniqueArgs} args - Arguments to find a AssignmentClass
     * @example
     * // Get one AssignmentClass
     * const assignmentClass = await prisma.assignmentClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssignmentClassFindUniqueArgs>(args: SelectSubset<T, AssignmentClassFindUniqueArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AssignmentClass that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AssignmentClassFindUniqueOrThrowArgs} args - Arguments to find a AssignmentClass
     * @example
     * // Get one AssignmentClass
     * const assignmentClass = await prisma.assignmentClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssignmentClassFindUniqueOrThrowArgs>(args: SelectSubset<T, AssignmentClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AssignmentClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentClassFindFirstArgs} args - Arguments to find a AssignmentClass
     * @example
     * // Get one AssignmentClass
     * const assignmentClass = await prisma.assignmentClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssignmentClassFindFirstArgs>(args?: SelectSubset<T, AssignmentClassFindFirstArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AssignmentClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentClassFindFirstOrThrowArgs} args - Arguments to find a AssignmentClass
     * @example
     * // Get one AssignmentClass
     * const assignmentClass = await prisma.assignmentClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssignmentClassFindFirstOrThrowArgs>(args?: SelectSubset<T, AssignmentClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AssignmentClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssignmentClasses
     * const assignmentClasses = await prisma.assignmentClass.findMany()
     * 
     * // Get first 10 AssignmentClasses
     * const assignmentClasses = await prisma.assignmentClass.findMany({ take: 10 })
     * 
     * // Only select the `assignmentId`
     * const assignmentClassWithAssignmentIdOnly = await prisma.assignmentClass.findMany({ select: { assignmentId: true } })
     * 
     */
    findMany<T extends AssignmentClassFindManyArgs>(args?: SelectSubset<T, AssignmentClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AssignmentClass.
     * @param {AssignmentClassCreateArgs} args - Arguments to create a AssignmentClass.
     * @example
     * // Create one AssignmentClass
     * const AssignmentClass = await prisma.assignmentClass.create({
     *   data: {
     *     // ... data to create a AssignmentClass
     *   }
     * })
     * 
     */
    create<T extends AssignmentClassCreateArgs>(args: SelectSubset<T, AssignmentClassCreateArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AssignmentClasses.
     * @param {AssignmentClassCreateManyArgs} args - Arguments to create many AssignmentClasses.
     * @example
     * // Create many AssignmentClasses
     * const assignmentClass = await prisma.assignmentClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssignmentClassCreateManyArgs>(args?: SelectSubset<T, AssignmentClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssignmentClasses and returns the data saved in the database.
     * @param {AssignmentClassCreateManyAndReturnArgs} args - Arguments to create many AssignmentClasses.
     * @example
     * // Create many AssignmentClasses
     * const assignmentClass = await prisma.assignmentClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AssignmentClasses and only return the `assignmentId`
     * const assignmentClassWithAssignmentIdOnly = await prisma.assignmentClass.createManyAndReturn({ 
     *   select: { assignmentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssignmentClassCreateManyAndReturnArgs>(args?: SelectSubset<T, AssignmentClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AssignmentClass.
     * @param {AssignmentClassDeleteArgs} args - Arguments to delete one AssignmentClass.
     * @example
     * // Delete one AssignmentClass
     * const AssignmentClass = await prisma.assignmentClass.delete({
     *   where: {
     *     // ... filter to delete one AssignmentClass
     *   }
     * })
     * 
     */
    delete<T extends AssignmentClassDeleteArgs>(args: SelectSubset<T, AssignmentClassDeleteArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AssignmentClass.
     * @param {AssignmentClassUpdateArgs} args - Arguments to update one AssignmentClass.
     * @example
     * // Update one AssignmentClass
     * const assignmentClass = await prisma.assignmentClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssignmentClassUpdateArgs>(args: SelectSubset<T, AssignmentClassUpdateArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AssignmentClasses.
     * @param {AssignmentClassDeleteManyArgs} args - Arguments to filter AssignmentClasses to delete.
     * @example
     * // Delete a few AssignmentClasses
     * const { count } = await prisma.assignmentClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssignmentClassDeleteManyArgs>(args?: SelectSubset<T, AssignmentClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssignmentClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssignmentClasses
     * const assignmentClass = await prisma.assignmentClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssignmentClassUpdateManyArgs>(args: SelectSubset<T, AssignmentClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AssignmentClass.
     * @param {AssignmentClassUpsertArgs} args - Arguments to update or create a AssignmentClass.
     * @example
     * // Update or create a AssignmentClass
     * const assignmentClass = await prisma.assignmentClass.upsert({
     *   create: {
     *     // ... data to create a AssignmentClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssignmentClass we want to update
     *   }
     * })
     */
    upsert<T extends AssignmentClassUpsertArgs>(args: SelectSubset<T, AssignmentClassUpsertArgs<ExtArgs>>): Prisma__AssignmentClassClient<$Result.GetResult<Prisma.$AssignmentClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AssignmentClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentClassCountArgs} args - Arguments to filter AssignmentClasses to count.
     * @example
     * // Count the number of AssignmentClasses
     * const count = await prisma.assignmentClass.count({
     *   where: {
     *     // ... the filter for the AssignmentClasses we want to count
     *   }
     * })
    **/
    count<T extends AssignmentClassCountArgs>(
      args?: Subset<T, AssignmentClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssignmentClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentClassAggregateArgs>(args: Subset<T, AssignmentClassAggregateArgs>): Prisma.PrismaPromise<GetAssignmentClassAggregateType<T>>

    /**
     * Group by AssignmentClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssignmentClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssignmentClassGroupByArgs['orderBy'] }
        : { orderBy?: AssignmentClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssignmentClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssignmentClass model
   */
  readonly fields: AssignmentClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssignmentClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssignmentClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignment<T extends AssignmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssignmentDefaultArgs<ExtArgs>>): Prisma__AssignmentClient<$Result.GetResult<Prisma.$AssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    class<T extends ClassDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassDefaultArgs<ExtArgs>>): Prisma__ClassClient<$Result.GetResult<Prisma.$ClassPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssignmentClass model
   */ 
  interface AssignmentClassFieldRefs {
    readonly assignmentId: FieldRef<"AssignmentClass", 'String'>
    readonly classId: FieldRef<"AssignmentClass", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AssignmentClass findUnique
   */
  export type AssignmentClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentClass to fetch.
     */
    where: AssignmentClassWhereUniqueInput
  }

  /**
   * AssignmentClass findUniqueOrThrow
   */
  export type AssignmentClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentClass to fetch.
     */
    where: AssignmentClassWhereUniqueInput
  }

  /**
   * AssignmentClass findFirst
   */
  export type AssignmentClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentClass to fetch.
     */
    where?: AssignmentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentClasses to fetch.
     */
    orderBy?: AssignmentClassOrderByWithRelationInput | AssignmentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentClasses.
     */
    cursor?: AssignmentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentClasses.
     */
    distinct?: AssignmentClassScalarFieldEnum | AssignmentClassScalarFieldEnum[]
  }

  /**
   * AssignmentClass findFirstOrThrow
   */
  export type AssignmentClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentClass to fetch.
     */
    where?: AssignmentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentClasses to fetch.
     */
    orderBy?: AssignmentClassOrderByWithRelationInput | AssignmentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AssignmentClasses.
     */
    cursor?: AssignmentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AssignmentClasses.
     */
    distinct?: AssignmentClassScalarFieldEnum | AssignmentClassScalarFieldEnum[]
  }

  /**
   * AssignmentClass findMany
   */
  export type AssignmentClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * Filter, which AssignmentClasses to fetch.
     */
    where?: AssignmentClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AssignmentClasses to fetch.
     */
    orderBy?: AssignmentClassOrderByWithRelationInput | AssignmentClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AssignmentClasses.
     */
    cursor?: AssignmentClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AssignmentClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AssignmentClasses.
     */
    skip?: number
    distinct?: AssignmentClassScalarFieldEnum | AssignmentClassScalarFieldEnum[]
  }

  /**
   * AssignmentClass create
   */
  export type AssignmentClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * The data needed to create a AssignmentClass.
     */
    data: XOR<AssignmentClassCreateInput, AssignmentClassUncheckedCreateInput>
  }

  /**
   * AssignmentClass createMany
   */
  export type AssignmentClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssignmentClasses.
     */
    data: AssignmentClassCreateManyInput | AssignmentClassCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssignmentClass createManyAndReturn
   */
  export type AssignmentClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AssignmentClasses.
     */
    data: AssignmentClassCreateManyInput | AssignmentClassCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssignmentClass update
   */
  export type AssignmentClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * The data needed to update a AssignmentClass.
     */
    data: XOR<AssignmentClassUpdateInput, AssignmentClassUncheckedUpdateInput>
    /**
     * Choose, which AssignmentClass to update.
     */
    where: AssignmentClassWhereUniqueInput
  }

  /**
   * AssignmentClass updateMany
   */
  export type AssignmentClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssignmentClasses.
     */
    data: XOR<AssignmentClassUpdateManyMutationInput, AssignmentClassUncheckedUpdateManyInput>
    /**
     * Filter which AssignmentClasses to update
     */
    where?: AssignmentClassWhereInput
  }

  /**
   * AssignmentClass upsert
   */
  export type AssignmentClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * The filter to search for the AssignmentClass to update in case it exists.
     */
    where: AssignmentClassWhereUniqueInput
    /**
     * In case the AssignmentClass found by the `where` argument doesn't exist, create a new AssignmentClass with this data.
     */
    create: XOR<AssignmentClassCreateInput, AssignmentClassUncheckedCreateInput>
    /**
     * In case the AssignmentClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssignmentClassUpdateInput, AssignmentClassUncheckedUpdateInput>
  }

  /**
   * AssignmentClass delete
   */
  export type AssignmentClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
    /**
     * Filter which AssignmentClass to delete.
     */
    where: AssignmentClassWhereUniqueInput
  }

  /**
   * AssignmentClass deleteMany
   */
  export type AssignmentClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssignmentClasses to delete
     */
    where?: AssignmentClassWhereInput
  }

  /**
   * AssignmentClass without action
   */
  export type AssignmentClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssignmentClass
     */
    select?: AssignmentClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssignmentClassInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    avatar: 'avatar',
    phone: 'phone',
    address: 'address',
    dateOfBirth: 'dateOfBirth',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    emailVerifiedAt: 'emailVerifiedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    userId: 'userId',
    classId: 'classId',
    parentIds: 'parentIds',
    admissionDate: 'admissionDate',
    academicYear: 'academicYear',
    allergies: 'allergies',
    medications: 'medications',
    emergencyMedicalContact: 'emergencyMedicalContact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const TeacherScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    userId: 'userId',
    department: 'department',
    qualifications: 'qualifications',
    hireDate: 'hireDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeacherScalarFieldEnum = (typeof TeacherScalarFieldEnum)[keyof typeof TeacherScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    occupation: 'occupation',
    preferredContactMethod: 'preferredContactMethod',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ClassScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    academicYear: 'academicYear',
    room: 'room',
    maxStudents: 'maxStudents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClassScalarFieldEnum = (typeof ClassScalarFieldEnum)[keyof typeof ClassScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    description: 'description',
    department: 'department',
    credits: 'credits',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    subjectId: 'subjectId',
    teacherId: 'teacherId',
    value: 'value',
    maxValue: 'maxValue',
    type: 'type',
    comment: 'comment',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const AssignmentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    instructions: 'instructions',
    type: 'type',
    priority: 'priority',
    maxGrade: 'maxGrade',
    dueDate: 'dueDate',
    submissionFormat: 'submissionFormat',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssignmentScalarFieldEnum = (typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum]


  export const AssignmentSubmissionScalarFieldEnum: {
    id: 'id',
    assignmentId: 'assignmentId',
    studentId: 'studentId',
    content: 'content',
    submittedAt: 'submittedAt',
    grade: 'grade',
    feedback: 'feedback',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AssignmentSubmissionScalarFieldEnum = (typeof AssignmentSubmissionScalarFieldEnum)[keyof typeof AssignmentSubmissionScalarFieldEnum]


  export const AttendanceRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    classId: 'classId',
    teacherId: 'teacherId',
    date: 'date',
    status: 'status',
    period: 'period',
    reason: 'reason',
    notifiedParents: 'notifiedParents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AttendanceRecordScalarFieldEnum = (typeof AttendanceRecordScalarFieldEnum)[keyof typeof AttendanceRecordScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    classId: 'classId',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    room: 'room',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    academicYear: 'academicYear',
    semester: 'semester',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    senderId: 'senderId',
    recipientIds: 'recipientIds',
    subject: 'subject',
    content: 'content',
    type: 'type',
    priority: 'priority',
    read: 'read',
    parentMessageId: 'parentMessageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const FinancialRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    dueDate: 'dueDate',
    paidDate: 'paidDate',
    status: 'status',
    description: 'description',
    paymentMethod: 'paymentMethod',
    invoiceNumber: 'invoiceNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FinancialRecordScalarFieldEnum = (typeof FinancialRecordScalarFieldEnum)[keyof typeof FinancialRecordScalarFieldEnum]


  export const AdmissionApplicationScalarFieldEnum: {
    id: 'id',
    applicationNumber: 'applicationNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    nationality: 'nationality',
    previousSchool: 'previousSchool',
    desiredClass: 'desiredClass',
    academicYear: 'academicYear',
    specialNeeds: 'specialNeeds',
    parentId: 'parentId',
    fatherName: 'fatherName',
    fatherEmail: 'fatherEmail',
    fatherPhone: 'fatherPhone',
    fatherOccupation: 'fatherOccupation',
    motherName: 'motherName',
    motherEmail: 'motherEmail',
    motherPhone: 'motherPhone',
    motherOccupation: 'motherOccupation',
    guardianName: 'guardianName',
    guardianEmail: 'guardianEmail',
    guardianPhone: 'guardianPhone',
    familyAddress: 'familyAddress',
    status: 'status',
    submittedAt: 'submittedAt',
    reviewedAt: 'reviewedAt',
    reviewedBy: 'reviewedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionApplicationScalarFieldEnum = (typeof AdmissionApplicationScalarFieldEnum)[keyof typeof AdmissionApplicationScalarFieldEnum]


  export const AdmissionStepProgressScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    stepName: 'stepName',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    assignedTo: 'assignedTo',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdmissionStepProgressScalarFieldEnum = (typeof AdmissionStepProgressScalarFieldEnum)[keyof typeof AdmissionStepProgressScalarFieldEnum]


  export const LearningResourceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    subjectId: 'subjectId',
    level: 'level',
    url: 'url',
    thumbnail: 'thumbnail',
    duration: 'duration',
    tags: 'tags',
    createdById: 'createdById',
    accessLevel: 'accessLevel',
    downloadable: 'downloadable',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LearningResourceScalarFieldEnum = (typeof LearningResourceScalarFieldEnum)[keyof typeof LearningResourceScalarFieldEnum]


  export const VirtualClassScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    teacherId: 'teacherId',
    subjectId: 'subjectId',
    scheduledStart: 'scheduledStart',
    scheduledEnd: 'scheduledEnd',
    meetingUrl: 'meetingUrl',
    recordingUrl: 'recordingUrl',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VirtualClassScalarFieldEnum = (typeof VirtualClassScalarFieldEnum)[keyof typeof VirtualClassScalarFieldEnum]


  export const VirtualClassParticipantScalarFieldEnum: {
    id: 'id',
    virtualClassId: 'virtualClassId',
    classId: 'classId'
  };

  export type VirtualClassParticipantScalarFieldEnum = (typeof VirtualClassParticipantScalarFieldEnum)[keyof typeof VirtualClassParticipantScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    icon: 'icon',
    category: 'category',
    points: 'points',
    criteria: 'criteria',
    rarity: 'rarity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const StudentAchievementScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    achievementId: 'achievementId',
    earnedDate: 'earnedDate',
    awardedBy: 'awardedBy',
    evidence: 'evidence'
  };

  export type StudentAchievementScalarFieldEnum = (typeof StudentAchievementScalarFieldEnum)[keyof typeof StudentAchievementScalarFieldEnum]


  export const BehaviorRecordScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    teacherId: 'teacherId',
    date: 'date',
    type: 'type',
    category: 'category',
    description: 'description',
    severity: 'severity',
    actionTaken: 'actionTaken',
    parentNotified: 'parentNotified',
    followUpRequired: 'followUpRequired',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BehaviorRecordScalarFieldEnum = (typeof BehaviorRecordScalarFieldEnum)[keyof typeof BehaviorRecordScalarFieldEnum]


  export const ReportCardScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    academicYear: 'academicYear',
    semester: 'semester',
    overallAverage: 'overallAverage',
    rank: 'rank',
    totalStudents: 'totalStudents',
    behaviorGrade: 'behaviorGrade',
    totalDays: 'totalDays',
    presentDays: 'presentDays',
    absentDays: 'absentDays',
    lateCount: 'lateCount',
    principalComment: 'principalComment',
    generatedAt: 'generatedAt',
    generatedBy: 'generatedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportCardScalarFieldEnum = (typeof ReportCardScalarFieldEnum)[keyof typeof ReportCardScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    title: 'title',
    message: 'message',
    type: 'type',
    category: 'category',
    read: 'read',
    actionRequired: 'actionRequired',
    actionUrl: 'actionUrl',
    scheduledFor: 'scheduledFor',
    channels: 'channels',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FileAttachmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    originalName: 'originalName',
    url: 'url',
    type: 'type',
    size: 'size',
    uploadedBy: 'uploadedBy',
    assignmentId: 'assignmentId',
    submissionId: 'submissionId',
    messageId: 'messageId',
    admissionId: 'admissionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileAttachmentScalarFieldEnum = (typeof FileAttachmentScalarFieldEnum)[keyof typeof FileAttachmentScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const TeacherSubjectScalarFieldEnum: {
    teacherId: 'teacherId',
    subjectId: 'subjectId'
  };

  export type TeacherSubjectScalarFieldEnum = (typeof TeacherSubjectScalarFieldEnum)[keyof typeof TeacherSubjectScalarFieldEnum]


  export const TeacherClassScalarFieldEnum: {
    teacherId: 'teacherId',
    classId: 'classId',
    isMainTeacher: 'isMainTeacher'
  };

  export type TeacherClassScalarFieldEnum = (typeof TeacherClassScalarFieldEnum)[keyof typeof TeacherClassScalarFieldEnum]


  export const ClassSubjectScalarFieldEnum: {
    classId: 'classId',
    subjectId: 'subjectId'
  };

  export type ClassSubjectScalarFieldEnum = (typeof ClassSubjectScalarFieldEnum)[keyof typeof ClassSubjectScalarFieldEnum]


  export const AssignmentClassScalarFieldEnum: {
    assignmentId: 'assignmentId',
    classId: 'classId'
  };

  export type AssignmentClassScalarFieldEnum = (typeof AssignmentClassScalarFieldEnum)[keyof typeof AssignmentClassScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ContactMethod'
   */
  export type EnumContactMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactMethod'>
    


  /**
   * Reference to a field of type 'ContactMethod[]'
   */
  export type ListEnumContactMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactMethod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'GradeType'
   */
  export type EnumGradeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GradeType'>
    


  /**
   * Reference to a field of type 'GradeType[]'
   */
  export type ListEnumGradeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GradeType[]'>
    


  /**
   * Reference to a field of type 'AssignmentType'
   */
  export type EnumAssignmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentType'>
    


  /**
   * Reference to a field of type 'AssignmentType[]'
   */
  export type ListEnumAssignmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssignmentType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'SubmissionFormat'
   */
  export type EnumSubmissionFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionFormat'>
    


  /**
   * Reference to a field of type 'SubmissionFormat[]'
   */
  export type ListEnumSubmissionFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionFormat[]'>
    


  /**
   * Reference to a field of type 'SubmissionStatus'
   */
  export type EnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus'>
    


  /**
   * Reference to a field of type 'SubmissionStatus[]'
   */
  export type ListEnumSubmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubmissionStatus[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'FinancialType'
   */
  export type EnumFinancialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialType'>
    


  /**
   * Reference to a field of type 'FinancialType[]'
   */
  export type ListEnumFinancialTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FinancialType[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'AdmissionStatus'
   */
  export type EnumAdmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmissionStatus'>
    


  /**
   * Reference to a field of type 'AdmissionStatus[]'
   */
  export type ListEnumAdmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmissionStatus[]'>
    


  /**
   * Reference to a field of type 'StepStatus'
   */
  export type EnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus'>
    


  /**
   * Reference to a field of type 'StepStatus[]'
   */
  export type ListEnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus[]'>
    


  /**
   * Reference to a field of type 'ResourceType'
   */
  export type EnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType'>
    


  /**
   * Reference to a field of type 'ResourceType[]'
   */
  export type ListEnumResourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResourceType[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'VirtualClassStatus'
   */
  export type EnumVirtualClassStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VirtualClassStatus'>
    


  /**
   * Reference to a field of type 'VirtualClassStatus[]'
   */
  export type ListEnumVirtualClassStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VirtualClassStatus[]'>
    


  /**
   * Reference to a field of type 'AchievementCategory'
   */
  export type EnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory'>
    


  /**
   * Reference to a field of type 'AchievementCategory[]'
   */
  export type ListEnumAchievementCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementCategory[]'>
    


  /**
   * Reference to a field of type 'Rarity'
   */
  export type EnumRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rarity'>
    


  /**
   * Reference to a field of type 'Rarity[]'
   */
  export type ListEnumRarityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rarity[]'>
    


  /**
   * Reference to a field of type 'BehaviorType'
   */
  export type EnumBehaviorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorType'>
    


  /**
   * Reference to a field of type 'BehaviorType[]'
   */
  export type ListEnumBehaviorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorType[]'>
    


  /**
   * Reference to a field of type 'BehaviorCategory'
   */
  export type EnumBehaviorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorCategory'>
    


  /**
   * Reference to a field of type 'BehaviorCategory[]'
   */
  export type ListEnumBehaviorCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorCategory[]'>
    


  /**
   * Reference to a field of type 'Severity'
   */
  export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


  /**
   * Reference to a field of type 'Severity[]'
   */
  export type ListEnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity[]'>
    


  /**
   * Reference to a field of type 'BehaviorGrade'
   */
  export type EnumBehaviorGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorGrade'>
    


  /**
   * Reference to a field of type 'BehaviorGrade[]'
   */
  export type ListEnumBehaviorGradeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehaviorGrade[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationCategory'
   */
  export type EnumNotificationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationCategory'>
    


  /**
   * Reference to a field of type 'NotificationCategory[]'
   */
  export type ListEnumNotificationCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationCategory[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel[]'
   */
  export type ListEnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel[]'>
    


  /**
   * Reference to a field of type 'NotificationChannel'
   */
  export type EnumNotificationChannelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationChannel'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
    parent?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    sessions?: UserSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    teacher?: XOR<TeacherNullableRelationFilter, TeacherWhereInput> | null
    parent?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
    admin?: XOR<AdminNullableRelationFilter, AdminWhereInput> | null
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    notifications?: NotificationListRelationFilter
    sessions?: UserSessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    classId?: StringNullableFilter<"Student"> | string | null
    parentIds?: StringNullableListFilter<"Student">
    admissionDate?: DateTimeFilter<"Student"> | Date | string
    academicYear?: StringFilter<"Student"> | string
    allergies?: StringNullableListFilter<"Student">
    medications?: StringNullableListFilter<"Student">
    emergencyMedicalContact?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    parents?: ParentListRelationFilter
    grades?: GradeListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    assignments?: AssignmentSubmissionListRelationFilter
    achievements?: StudentAchievementListRelationFilter
    behaviorRecords?: BehaviorRecordListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    reportCards?: ReportCardListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    classId?: SortOrderInput | SortOrder
    parentIds?: SortOrder
    admissionDate?: SortOrder
    academicYear?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    emergencyMedicalContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    parents?: ParentOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    assignments?: AssignmentSubmissionOrderByRelationAggregateInput
    achievements?: StudentAchievementOrderByRelationAggregateInput
    behaviorRecords?: BehaviorRecordOrderByRelationAggregateInput
    financialRecords?: FinancialRecordOrderByRelationAggregateInput
    reportCards?: ReportCardOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    userId?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    classId?: StringNullableFilter<"Student"> | string | null
    parentIds?: StringNullableListFilter<"Student">
    admissionDate?: DateTimeFilter<"Student"> | Date | string
    academicYear?: StringFilter<"Student"> | string
    allergies?: StringNullableListFilter<"Student">
    medications?: StringNullableListFilter<"Student">
    emergencyMedicalContact?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    parents?: ParentListRelationFilter
    grades?: GradeListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    assignments?: AssignmentSubmissionListRelationFilter
    achievements?: StudentAchievementListRelationFilter
    behaviorRecords?: BehaviorRecordListRelationFilter
    financialRecords?: FinancialRecordListRelationFilter
    reportCards?: ReportCardListRelationFilter
  }, "id" | "studentId" | "userId">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    classId?: SortOrderInput | SortOrder
    parentIds?: SortOrder
    admissionDate?: SortOrder
    academicYear?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    emergencyMedicalContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    studentId?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    classId?: StringNullableWithAggregatesFilter<"Student"> | string | null
    parentIds?: StringNullableListFilter<"Student">
    admissionDate?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    academicYear?: StringWithAggregatesFilter<"Student"> | string
    allergies?: StringNullableListFilter<"Student">
    medications?: StringNullableListFilter<"Student">
    emergencyMedicalContact?: StringNullableWithAggregatesFilter<"Student"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type TeacherWhereInput = {
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    id?: StringFilter<"Teacher"> | string
    employeeId?: StringFilter<"Teacher"> | string
    userId?: StringFilter<"Teacher"> | string
    department?: StringFilter<"Teacher"> | string
    qualifications?: StringNullableListFilter<"Teacher">
    hireDate?: DateTimeFilter<"Teacher"> | Date | string
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subjects?: TeacherSubjectListRelationFilter
    classes?: TeacherClassListRelationFilter
    grades?: GradeListRelationFilter
    assignments?: AssignmentListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    schedules?: ScheduleListRelationFilter
    virtualClasses?: VirtualClassListRelationFilter
    resources?: LearningResourceListRelationFilter
    behaviorRecords?: BehaviorRecordListRelationFilter
  }

  export type TeacherOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    qualifications?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    subjects?: TeacherSubjectOrderByRelationAggregateInput
    classes?: TeacherClassOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
    virtualClasses?: VirtualClassOrderByRelationAggregateInput
    resources?: LearningResourceOrderByRelationAggregateInput
    behaviorRecords?: BehaviorRecordOrderByRelationAggregateInput
  }

  export type TeacherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId?: string
    userId?: string
    AND?: TeacherWhereInput | TeacherWhereInput[]
    OR?: TeacherWhereInput[]
    NOT?: TeacherWhereInput | TeacherWhereInput[]
    department?: StringFilter<"Teacher"> | string
    qualifications?: StringNullableListFilter<"Teacher">
    hireDate?: DateTimeFilter<"Teacher"> | Date | string
    createdAt?: DateTimeFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeFilter<"Teacher"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    subjects?: TeacherSubjectListRelationFilter
    classes?: TeacherClassListRelationFilter
    grades?: GradeListRelationFilter
    assignments?: AssignmentListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    schedules?: ScheduleListRelationFilter
    virtualClasses?: VirtualClassListRelationFilter
    resources?: LearningResourceListRelationFilter
    behaviorRecords?: BehaviorRecordListRelationFilter
  }, "id" | "employeeId" | "userId">

  export type TeacherOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    qualifications?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeacherCountOrderByAggregateInput
    _max?: TeacherMaxOrderByAggregateInput
    _min?: TeacherMinOrderByAggregateInput
  }

  export type TeacherScalarWhereWithAggregatesInput = {
    AND?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    OR?: TeacherScalarWhereWithAggregatesInput[]
    NOT?: TeacherScalarWhereWithAggregatesInput | TeacherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Teacher"> | string
    employeeId?: StringWithAggregatesFilter<"Teacher"> | string
    userId?: StringWithAggregatesFilter<"Teacher"> | string
    department?: StringWithAggregatesFilter<"Teacher"> | string
    qualifications?: StringNullableListFilter<"Teacher">
    hireDate?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Teacher"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    userId?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    preferredContactMethod?: EnumContactMethodFilter<"Parent"> | $Enums.ContactMethod
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    children?: StudentListRelationFilter
    admissionApplications?: AdmissionApplicationListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrderInput | SortOrder
    preferredContactMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    children?: StudentOrderByRelationAggregateInput
    admissionApplications?: AdmissionApplicationOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    occupation?: StringNullableFilter<"Parent"> | string | null
    preferredContactMethod?: EnumContactMethodFilter<"Parent"> | $Enums.ContactMethod
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    children?: StudentListRelationFilter
    admissionApplications?: AdmissionApplicationListRelationFilter
  }, "id" | "userId">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrderInput | SortOrder
    preferredContactMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    userId?: StringWithAggregatesFilter<"Parent"> | string
    occupation?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    preferredContactMethod?: EnumContactMethodWithAggregatesFilter<"Parent"> | $Enums.ContactMethod
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type ClassWhereInput = {
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    id?: StringFilter<"Class"> | string
    name?: StringFilter<"Class"> | string
    level?: StringFilter<"Class"> | string
    academicYear?: StringFilter<"Class"> | string
    room?: StringNullableFilter<"Class"> | string | null
    maxStudents?: IntFilter<"Class"> | number
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    students?: StudentListRelationFilter
    teachers?: TeacherClassListRelationFilter
    subjects?: ClassSubjectListRelationFilter
    schedules?: ScheduleListRelationFilter
    assignments?: AssignmentClassListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    virtualClasses?: VirtualClassParticipantListRelationFilter
  }

  export type ClassOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    academicYear?: SortOrder
    room?: SortOrderInput | SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    students?: StudentOrderByRelationAggregateInput
    teachers?: TeacherClassOrderByRelationAggregateInput
    subjects?: ClassSubjectOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
    assignments?: AssignmentClassOrderByRelationAggregateInput
    attendanceRecords?: AttendanceRecordOrderByRelationAggregateInput
    virtualClasses?: VirtualClassParticipantOrderByRelationAggregateInput
  }

  export type ClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassWhereInput | ClassWhereInput[]
    OR?: ClassWhereInput[]
    NOT?: ClassWhereInput | ClassWhereInput[]
    name?: StringFilter<"Class"> | string
    level?: StringFilter<"Class"> | string
    academicYear?: StringFilter<"Class"> | string
    room?: StringNullableFilter<"Class"> | string | null
    maxStudents?: IntFilter<"Class"> | number
    createdAt?: DateTimeFilter<"Class"> | Date | string
    updatedAt?: DateTimeFilter<"Class"> | Date | string
    students?: StudentListRelationFilter
    teachers?: TeacherClassListRelationFilter
    subjects?: ClassSubjectListRelationFilter
    schedules?: ScheduleListRelationFilter
    assignments?: AssignmentClassListRelationFilter
    attendanceRecords?: AttendanceRecordListRelationFilter
    virtualClasses?: VirtualClassParticipantListRelationFilter
  }, "id">

  export type ClassOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    academicYear?: SortOrder
    room?: SortOrderInput | SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClassCountOrderByAggregateInput
    _avg?: ClassAvgOrderByAggregateInput
    _max?: ClassMaxOrderByAggregateInput
    _min?: ClassMinOrderByAggregateInput
    _sum?: ClassSumOrderByAggregateInput
  }

  export type ClassScalarWhereWithAggregatesInput = {
    AND?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    OR?: ClassScalarWhereWithAggregatesInput[]
    NOT?: ClassScalarWhereWithAggregatesInput | ClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Class"> | string
    name?: StringWithAggregatesFilter<"Class"> | string
    level?: StringWithAggregatesFilter<"Class"> | string
    academicYear?: StringWithAggregatesFilter<"Class"> | string
    room?: StringNullableWithAggregatesFilter<"Class"> | string | null
    maxStudents?: IntWithAggregatesFilter<"Class"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Class"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    code?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    department?: StringFilter<"Subject"> | string
    credits?: IntFilter<"Subject"> | number
    color?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    teachers?: TeacherSubjectListRelationFilter
    classes?: ClassSubjectListRelationFilter
    grades?: GradeListRelationFilter
    assignments?: AssignmentListRelationFilter
    schedules?: ScheduleListRelationFilter
    resources?: LearningResourceListRelationFilter
    virtualClasses?: VirtualClassListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    department?: SortOrder
    credits?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teachers?: TeacherSubjectOrderByRelationAggregateInput
    classes?: ClassSubjectOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
    assignments?: AssignmentOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
    resources?: LearningResourceOrderByRelationAggregateInput
    virtualClasses?: VirtualClassOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    department?: StringFilter<"Subject"> | string
    credits?: IntFilter<"Subject"> | number
    color?: StringFilter<"Subject"> | string
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    teachers?: TeacherSubjectListRelationFilter
    classes?: ClassSubjectListRelationFilter
    grades?: GradeListRelationFilter
    assignments?: AssignmentListRelationFilter
    schedules?: ScheduleListRelationFilter
    resources?: LearningResourceListRelationFilter
    virtualClasses?: VirtualClassListRelationFilter
  }, "id" | "code">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    department?: SortOrder
    credits?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    code?: StringWithAggregatesFilter<"Subject"> | string
    description?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    department?: StringWithAggregatesFilter<"Subject"> | string
    credits?: IntWithAggregatesFilter<"Subject"> | number
    color?: StringWithAggregatesFilter<"Subject"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    studentId?: StringFilter<"Grade"> | string
    subjectId?: StringFilter<"Grade"> | string
    teacherId?: StringFilter<"Grade"> | string
    value?: FloatFilter<"Grade"> | number
    maxValue?: FloatFilter<"Grade"> | number
    type?: EnumGradeTypeFilter<"Grade"> | $Enums.GradeType
    comment?: StringNullableFilter<"Grade"> | string | null
    date?: DateTimeFilter<"Grade"> | Date | string
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    type?: SortOrder
    comment?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    studentId?: StringFilter<"Grade"> | string
    subjectId?: StringFilter<"Grade"> | string
    teacherId?: StringFilter<"Grade"> | string
    value?: FloatFilter<"Grade"> | number
    maxValue?: FloatFilter<"Grade"> | number
    type?: EnumGradeTypeFilter<"Grade"> | $Enums.GradeType
    comment?: StringNullableFilter<"Grade"> | string | null
    date?: DateTimeFilter<"Grade"> | Date | string
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    type?: SortOrder
    comment?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    studentId?: StringWithAggregatesFilter<"Grade"> | string
    subjectId?: StringWithAggregatesFilter<"Grade"> | string
    teacherId?: StringWithAggregatesFilter<"Grade"> | string
    value?: FloatWithAggregatesFilter<"Grade"> | number
    maxValue?: FloatWithAggregatesFilter<"Grade"> | number
    type?: EnumGradeTypeWithAggregatesFilter<"Grade"> | $Enums.GradeType
    comment?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    date?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
  }

  export type AssignmentWhereInput = {
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    id?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringFilter<"Assignment"> | string
    instructions?: StringFilter<"Assignment"> | string
    type?: EnumAssignmentTypeFilter<"Assignment"> | $Enums.AssignmentType
    priority?: EnumPriorityFilter<"Assignment"> | $Enums.Priority
    maxGrade?: FloatFilter<"Assignment"> | number
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    submissionFormat?: EnumSubmissionFormatFilter<"Assignment"> | $Enums.SubmissionFormat
    teacherId?: StringFilter<"Assignment"> | string
    subjectId?: StringFilter<"Assignment"> | string
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    classes?: AssignmentClassListRelationFilter
    submissions?: AssignmentSubmissionListRelationFilter
    attachments?: FileAttachmentListRelationFilter
  }

  export type AssignmentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    maxGrade?: SortOrder
    dueDate?: SortOrder
    submissionFormat?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    classes?: AssignmentClassOrderByRelationAggregateInput
    submissions?: AssignmentSubmissionOrderByRelationAggregateInput
    attachments?: FileAttachmentOrderByRelationAggregateInput
  }

  export type AssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssignmentWhereInput | AssignmentWhereInput[]
    OR?: AssignmentWhereInput[]
    NOT?: AssignmentWhereInput | AssignmentWhereInput[]
    title?: StringFilter<"Assignment"> | string
    description?: StringFilter<"Assignment"> | string
    instructions?: StringFilter<"Assignment"> | string
    type?: EnumAssignmentTypeFilter<"Assignment"> | $Enums.AssignmentType
    priority?: EnumPriorityFilter<"Assignment"> | $Enums.Priority
    maxGrade?: FloatFilter<"Assignment"> | number
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    submissionFormat?: EnumSubmissionFormatFilter<"Assignment"> | $Enums.SubmissionFormat
    teacherId?: StringFilter<"Assignment"> | string
    subjectId?: StringFilter<"Assignment"> | string
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    classes?: AssignmentClassListRelationFilter
    submissions?: AssignmentSubmissionListRelationFilter
    attachments?: FileAttachmentListRelationFilter
  }, "id">

  export type AssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    maxGrade?: SortOrder
    dueDate?: SortOrder
    submissionFormat?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssignmentCountOrderByAggregateInput
    _avg?: AssignmentAvgOrderByAggregateInput
    _max?: AssignmentMaxOrderByAggregateInput
    _min?: AssignmentMinOrderByAggregateInput
    _sum?: AssignmentSumOrderByAggregateInput
  }

  export type AssignmentScalarWhereWithAggregatesInput = {
    AND?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    OR?: AssignmentScalarWhereWithAggregatesInput[]
    NOT?: AssignmentScalarWhereWithAggregatesInput | AssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Assignment"> | string
    title?: StringWithAggregatesFilter<"Assignment"> | string
    description?: StringWithAggregatesFilter<"Assignment"> | string
    instructions?: StringWithAggregatesFilter<"Assignment"> | string
    type?: EnumAssignmentTypeWithAggregatesFilter<"Assignment"> | $Enums.AssignmentType
    priority?: EnumPriorityWithAggregatesFilter<"Assignment"> | $Enums.Priority
    maxGrade?: FloatWithAggregatesFilter<"Assignment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    submissionFormat?: EnumSubmissionFormatWithAggregatesFilter<"Assignment"> | $Enums.SubmissionFormat
    teacherId?: StringWithAggregatesFilter<"Assignment"> | string
    subjectId?: StringWithAggregatesFilter<"Assignment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Assignment"> | Date | string
  }

  export type AssignmentSubmissionWhereInput = {
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    submittedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    grade?: FloatNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    status?: EnumSubmissionStatusFilter<"AssignmentSubmission"> | $Enums.SubmissionStatus
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    attachments?: FileAttachmentListRelationFilter
  }

  export type AssignmentSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    attachments?: FileAttachmentOrderByRelationAggregateInput
  }

  export type AssignmentSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    assignmentId_studentId?: AssignmentSubmissionAssignmentIdStudentIdCompoundUniqueInput
    AND?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    OR?: AssignmentSubmissionWhereInput[]
    NOT?: AssignmentSubmissionWhereInput | AssignmentSubmissionWhereInput[]
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    submittedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    grade?: FloatNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    status?: EnumSubmissionStatusFilter<"AssignmentSubmission"> | $Enums.SubmissionStatus
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    attachments?: FileAttachmentListRelationFilter
  }, "id" | "assignmentId_studentId">

  export type AssignmentSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    grade?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AssignmentSubmissionCountOrderByAggregateInput
    _avg?: AssignmentSubmissionAvgOrderByAggregateInput
    _max?: AssignmentSubmissionMaxOrderByAggregateInput
    _min?: AssignmentSubmissionMinOrderByAggregateInput
    _sum?: AssignmentSubmissionSumOrderByAggregateInput
  }

  export type AssignmentSubmissionScalarWhereWithAggregatesInput = {
    AND?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    OR?: AssignmentSubmissionScalarWhereWithAggregatesInput[]
    NOT?: AssignmentSubmissionScalarWhereWithAggregatesInput | AssignmentSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    assignmentId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    studentId?: StringWithAggregatesFilter<"AssignmentSubmission"> | string
    content?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"AssignmentSubmission"> | Date | string | null
    grade?: FloatNullableWithAggregatesFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"AssignmentSubmission"> | string | null
    status?: EnumSubmissionStatusWithAggregatesFilter<"AssignmentSubmission"> | $Enums.SubmissionStatus
    createdAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssignmentSubmission"> | Date | string
  }

  export type AttendanceRecordWhereInput = {
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    studentId?: StringFilter<"AttendanceRecord"> | string
    classId?: StringNullableFilter<"AttendanceRecord"> | string | null
    teacherId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    period?: StringNullableFilter<"AttendanceRecord"> | string | null
    reason?: StringNullableFilter<"AttendanceRecord"> | string | null
    notifiedParents?: BoolFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type AttendanceRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrderInput | SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    period?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    notifiedParents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type AttendanceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    OR?: AttendanceRecordWhereInput[]
    NOT?: AttendanceRecordWhereInput | AttendanceRecordWhereInput[]
    studentId?: StringFilter<"AttendanceRecord"> | string
    classId?: StringNullableFilter<"AttendanceRecord"> | string | null
    teacherId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    period?: StringNullableFilter<"AttendanceRecord"> | string | null
    reason?: StringNullableFilter<"AttendanceRecord"> | string | null
    notifiedParents?: BoolFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    class?: XOR<ClassNullableRelationFilter, ClassWhereInput> | null
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type AttendanceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrderInput | SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    period?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    notifiedParents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AttendanceRecordCountOrderByAggregateInput
    _max?: AttendanceRecordMaxOrderByAggregateInput
    _min?: AttendanceRecordMinOrderByAggregateInput
  }

  export type AttendanceRecordScalarWhereWithAggregatesInput = {
    AND?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    OR?: AttendanceRecordScalarWhereWithAggregatesInput[]
    NOT?: AttendanceRecordScalarWhereWithAggregatesInput | AttendanceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    studentId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    classId?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    teacherId?: StringWithAggregatesFilter<"AttendanceRecord"> | string
    date?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    period?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    reason?: StringNullableWithAggregatesFilter<"AttendanceRecord"> | string | null
    notifiedParents?: BoolWithAggregatesFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AttendanceRecord"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    classId?: StringFilter<"Schedule"> | string
    teacherId?: StringFilter<"Schedule"> | string
    subjectId?: StringFilter<"Schedule"> | string
    room?: StringFilter<"Schedule"> | string
    dayOfWeek?: IntFilter<"Schedule"> | number
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    duration?: IntFilter<"Schedule"> | number
    academicYear?: StringFilter<"Schedule"> | string
    semester?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    room?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    class?: ClassOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    classId?: StringFilter<"Schedule"> | string
    teacherId?: StringFilter<"Schedule"> | string
    subjectId?: StringFilter<"Schedule"> | string
    room?: StringFilter<"Schedule"> | string
    dayOfWeek?: IntFilter<"Schedule"> | number
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    duration?: IntFilter<"Schedule"> | number
    academicYear?: StringFilter<"Schedule"> | string
    semester?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    room?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    classId?: StringWithAggregatesFilter<"Schedule"> | string
    teacherId?: StringWithAggregatesFilter<"Schedule"> | string
    subjectId?: StringWithAggregatesFilter<"Schedule"> | string
    room?: StringWithAggregatesFilter<"Schedule"> | string
    dayOfWeek?: IntWithAggregatesFilter<"Schedule"> | number
    startTime?: StringWithAggregatesFilter<"Schedule"> | string
    endTime?: StringWithAggregatesFilter<"Schedule"> | string
    duration?: IntWithAggregatesFilter<"Schedule"> | number
    academicYear?: StringWithAggregatesFilter<"Schedule"> | string
    semester?: StringWithAggregatesFilter<"Schedule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientIds?: StringNullableListFilter<"Message">
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    priority?: EnumPriorityFilter<"Message"> | $Enums.Priority
    read?: BoolFilter<"Message"> | boolean
    parentMessageId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    recipients?: UserListRelationFilter
    parentMessage?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    attachments?: FileAttachmentListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientIds?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    recipients?: UserOrderByRelationAggregateInput
    parentMessage?: MessageOrderByWithRelationInput
    replies?: MessageOrderByRelationAggregateInput
    attachments?: FileAttachmentOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    senderId?: StringFilter<"Message"> | string
    recipientIds?: StringNullableListFilter<"Message">
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    priority?: EnumPriorityFilter<"Message"> | $Enums.Priority
    read?: BoolFilter<"Message"> | boolean
    parentMessageId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    recipients?: UserListRelationFilter
    parentMessage?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    replies?: MessageListRelationFilter
    attachments?: FileAttachmentListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientIds?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    parentMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    recipientIds?: StringNullableListFilter<"Message">
    subject?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    priority?: EnumPriorityWithAggregatesFilter<"Message"> | $Enums.Priority
    read?: BoolWithAggregatesFilter<"Message"> | boolean
    parentMessageId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type FinancialRecordWhereInput = {
    AND?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    OR?: FinancialRecordWhereInput[]
    NOT?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    id?: StringFilter<"FinancialRecord"> | string
    studentId?: StringFilter<"FinancialRecord"> | string
    type?: EnumFinancialTypeFilter<"FinancialRecord"> | $Enums.FinancialType
    amount?: FloatFilter<"FinancialRecord"> | number
    currency?: StringFilter<"FinancialRecord"> | string
    dueDate?: DateTimeFilter<"FinancialRecord"> | Date | string
    paidDate?: DateTimeNullableFilter<"FinancialRecord"> | Date | string | null
    status?: EnumPaymentStatusFilter<"FinancialRecord"> | $Enums.PaymentStatus
    description?: StringFilter<"FinancialRecord"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"FinancialRecord"> | $Enums.PaymentMethod | null
    invoiceNumber?: StringFilter<"FinancialRecord"> | string
    createdAt?: DateTimeFilter<"FinancialRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type FinancialRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type FinancialRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    OR?: FinancialRecordWhereInput[]
    NOT?: FinancialRecordWhereInput | FinancialRecordWhereInput[]
    studentId?: StringFilter<"FinancialRecord"> | string
    type?: EnumFinancialTypeFilter<"FinancialRecord"> | $Enums.FinancialType
    amount?: FloatFilter<"FinancialRecord"> | number
    currency?: StringFilter<"FinancialRecord"> | string
    dueDate?: DateTimeFilter<"FinancialRecord"> | Date | string
    paidDate?: DateTimeNullableFilter<"FinancialRecord"> | Date | string | null
    status?: EnumPaymentStatusFilter<"FinancialRecord"> | $Enums.PaymentStatus
    description?: StringFilter<"FinancialRecord"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"FinancialRecord"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"FinancialRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "invoiceNumber">

  export type FinancialRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FinancialRecordCountOrderByAggregateInput
    _avg?: FinancialRecordAvgOrderByAggregateInput
    _max?: FinancialRecordMaxOrderByAggregateInput
    _min?: FinancialRecordMinOrderByAggregateInput
    _sum?: FinancialRecordSumOrderByAggregateInput
  }

  export type FinancialRecordScalarWhereWithAggregatesInput = {
    AND?: FinancialRecordScalarWhereWithAggregatesInput | FinancialRecordScalarWhereWithAggregatesInput[]
    OR?: FinancialRecordScalarWhereWithAggregatesInput[]
    NOT?: FinancialRecordScalarWhereWithAggregatesInput | FinancialRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FinancialRecord"> | string
    studentId?: StringWithAggregatesFilter<"FinancialRecord"> | string
    type?: EnumFinancialTypeWithAggregatesFilter<"FinancialRecord"> | $Enums.FinancialType
    amount?: FloatWithAggregatesFilter<"FinancialRecord"> | number
    currency?: StringWithAggregatesFilter<"FinancialRecord"> | string
    dueDate?: DateTimeWithAggregatesFilter<"FinancialRecord"> | Date | string
    paidDate?: DateTimeNullableWithAggregatesFilter<"FinancialRecord"> | Date | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"FinancialRecord"> | $Enums.PaymentStatus
    description?: StringWithAggregatesFilter<"FinancialRecord"> | string
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"FinancialRecord"> | $Enums.PaymentMethod | null
    invoiceNumber?: StringWithAggregatesFilter<"FinancialRecord"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FinancialRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FinancialRecord"> | Date | string
  }

  export type AdmissionApplicationWhereInput = {
    AND?: AdmissionApplicationWhereInput | AdmissionApplicationWhereInput[]
    OR?: AdmissionApplicationWhereInput[]
    NOT?: AdmissionApplicationWhereInput | AdmissionApplicationWhereInput[]
    id?: StringFilter<"AdmissionApplication"> | string
    applicationNumber?: StringFilter<"AdmissionApplication"> | string
    firstName?: StringFilter<"AdmissionApplication"> | string
    lastName?: StringFilter<"AdmissionApplication"> | string
    dateOfBirth?: DateTimeFilter<"AdmissionApplication"> | Date | string
    gender?: EnumGenderFilter<"AdmissionApplication"> | $Enums.Gender
    nationality?: StringFilter<"AdmissionApplication"> | string
    previousSchool?: StringNullableFilter<"AdmissionApplication"> | string | null
    desiredClass?: StringFilter<"AdmissionApplication"> | string
    academicYear?: StringFilter<"AdmissionApplication"> | string
    specialNeeds?: StringNullableFilter<"AdmissionApplication"> | string | null
    parentId?: StringNullableFilter<"AdmissionApplication"> | string | null
    fatherName?: StringFilter<"AdmissionApplication"> | string
    fatherEmail?: StringFilter<"AdmissionApplication"> | string
    fatherPhone?: StringFilter<"AdmissionApplication"> | string
    fatherOccupation?: StringNullableFilter<"AdmissionApplication"> | string | null
    motherName?: StringFilter<"AdmissionApplication"> | string
    motherEmail?: StringFilter<"AdmissionApplication"> | string
    motherPhone?: StringFilter<"AdmissionApplication"> | string
    motherOccupation?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianName?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianEmail?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianPhone?: StringNullableFilter<"AdmissionApplication"> | string | null
    familyAddress?: StringFilter<"AdmissionApplication"> | string
    status?: EnumAdmissionStatusFilter<"AdmissionApplication"> | $Enums.AdmissionStatus
    submittedAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"AdmissionApplication"> | Date | string | null
    reviewedBy?: StringNullableFilter<"AdmissionApplication"> | string | null
    notes?: StringNullableFilter<"AdmissionApplication"> | string | null
    createdAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    parent?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
    documents?: FileAttachmentListRelationFilter
    stepProgress?: AdmissionStepProgressListRelationFilter
  }

  export type AdmissionApplicationOrderByWithRelationInput = {
    id?: SortOrder
    applicationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    previousSchool?: SortOrderInput | SortOrder
    desiredClass?: SortOrder
    academicYear?: SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    fatherName?: SortOrder
    fatherEmail?: SortOrder
    fatherPhone?: SortOrder
    fatherOccupation?: SortOrderInput | SortOrder
    motherName?: SortOrder
    motherEmail?: SortOrder
    motherPhone?: SortOrder
    motherOccupation?: SortOrderInput | SortOrder
    guardianName?: SortOrderInput | SortOrder
    guardianEmail?: SortOrderInput | SortOrder
    guardianPhone?: SortOrderInput | SortOrder
    familyAddress?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: ParentOrderByWithRelationInput
    documents?: FileAttachmentOrderByRelationAggregateInput
    stepProgress?: AdmissionStepProgressOrderByRelationAggregateInput
  }

  export type AdmissionApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicationNumber?: string
    AND?: AdmissionApplicationWhereInput | AdmissionApplicationWhereInput[]
    OR?: AdmissionApplicationWhereInput[]
    NOT?: AdmissionApplicationWhereInput | AdmissionApplicationWhereInput[]
    firstName?: StringFilter<"AdmissionApplication"> | string
    lastName?: StringFilter<"AdmissionApplication"> | string
    dateOfBirth?: DateTimeFilter<"AdmissionApplication"> | Date | string
    gender?: EnumGenderFilter<"AdmissionApplication"> | $Enums.Gender
    nationality?: StringFilter<"AdmissionApplication"> | string
    previousSchool?: StringNullableFilter<"AdmissionApplication"> | string | null
    desiredClass?: StringFilter<"AdmissionApplication"> | string
    academicYear?: StringFilter<"AdmissionApplication"> | string
    specialNeeds?: StringNullableFilter<"AdmissionApplication"> | string | null
    parentId?: StringNullableFilter<"AdmissionApplication"> | string | null
    fatherName?: StringFilter<"AdmissionApplication"> | string
    fatherEmail?: StringFilter<"AdmissionApplication"> | string
    fatherPhone?: StringFilter<"AdmissionApplication"> | string
    fatherOccupation?: StringNullableFilter<"AdmissionApplication"> | string | null
    motherName?: StringFilter<"AdmissionApplication"> | string
    motherEmail?: StringFilter<"AdmissionApplication"> | string
    motherPhone?: StringFilter<"AdmissionApplication"> | string
    motherOccupation?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianName?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianEmail?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianPhone?: StringNullableFilter<"AdmissionApplication"> | string | null
    familyAddress?: StringFilter<"AdmissionApplication"> | string
    status?: EnumAdmissionStatusFilter<"AdmissionApplication"> | $Enums.AdmissionStatus
    submittedAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"AdmissionApplication"> | Date | string | null
    reviewedBy?: StringNullableFilter<"AdmissionApplication"> | string | null
    notes?: StringNullableFilter<"AdmissionApplication"> | string | null
    createdAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    parent?: XOR<ParentNullableRelationFilter, ParentWhereInput> | null
    documents?: FileAttachmentListRelationFilter
    stepProgress?: AdmissionStepProgressListRelationFilter
  }, "id" | "applicationNumber">

  export type AdmissionApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    applicationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    previousSchool?: SortOrderInput | SortOrder
    desiredClass?: SortOrder
    academicYear?: SortOrder
    specialNeeds?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    fatherName?: SortOrder
    fatherEmail?: SortOrder
    fatherPhone?: SortOrder
    fatherOccupation?: SortOrderInput | SortOrder
    motherName?: SortOrder
    motherEmail?: SortOrder
    motherPhone?: SortOrder
    motherOccupation?: SortOrderInput | SortOrder
    guardianName?: SortOrderInput | SortOrder
    guardianEmail?: SortOrderInput | SortOrder
    guardianPhone?: SortOrderInput | SortOrder
    familyAddress?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionApplicationCountOrderByAggregateInput
    _max?: AdmissionApplicationMaxOrderByAggregateInput
    _min?: AdmissionApplicationMinOrderByAggregateInput
  }

  export type AdmissionApplicationScalarWhereWithAggregatesInput = {
    AND?: AdmissionApplicationScalarWhereWithAggregatesInput | AdmissionApplicationScalarWhereWithAggregatesInput[]
    OR?: AdmissionApplicationScalarWhereWithAggregatesInput[]
    NOT?: AdmissionApplicationScalarWhereWithAggregatesInput | AdmissionApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    applicationNumber?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    firstName?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    lastName?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"AdmissionApplication"> | Date | string
    gender?: EnumGenderWithAggregatesFilter<"AdmissionApplication"> | $Enums.Gender
    nationality?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    previousSchool?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    desiredClass?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    academicYear?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    specialNeeds?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    fatherName?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    fatherEmail?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    fatherPhone?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    fatherOccupation?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    motherName?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    motherEmail?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    motherPhone?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    motherOccupation?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    guardianName?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    guardianEmail?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    guardianPhone?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    familyAddress?: StringWithAggregatesFilter<"AdmissionApplication"> | string
    status?: EnumAdmissionStatusWithAggregatesFilter<"AdmissionApplication"> | $Enums.AdmissionStatus
    submittedAt?: DateTimeWithAggregatesFilter<"AdmissionApplication"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"AdmissionApplication"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AdmissionApplication"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdmissionApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdmissionApplication"> | Date | string
  }

  export type AdmissionStepProgressWhereInput = {
    AND?: AdmissionStepProgressWhereInput | AdmissionStepProgressWhereInput[]
    OR?: AdmissionStepProgressWhereInput[]
    NOT?: AdmissionStepProgressWhereInput | AdmissionStepProgressWhereInput[]
    id?: StringFilter<"AdmissionStepProgress"> | string
    applicationId?: StringFilter<"AdmissionStepProgress"> | string
    stepName?: StringFilter<"AdmissionStepProgress"> | string
    status?: EnumStepStatusFilter<"AdmissionStepProgress"> | $Enums.StepStatus
    startedAt?: DateTimeNullableFilter<"AdmissionStepProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AdmissionStepProgress"> | Date | string | null
    assignedTo?: StringNullableFilter<"AdmissionStepProgress"> | string | null
    notes?: StringNullableFilter<"AdmissionStepProgress"> | string | null
    createdAt?: DateTimeFilter<"AdmissionStepProgress"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionStepProgress"> | Date | string
    application?: XOR<AdmissionApplicationRelationFilter, AdmissionApplicationWhereInput>
  }

  export type AdmissionStepProgressOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    stepName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    application?: AdmissionApplicationOrderByWithRelationInput
  }

  export type AdmissionStepProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicationId_stepName?: AdmissionStepProgressApplicationIdStepNameCompoundUniqueInput
    AND?: AdmissionStepProgressWhereInput | AdmissionStepProgressWhereInput[]
    OR?: AdmissionStepProgressWhereInput[]
    NOT?: AdmissionStepProgressWhereInput | AdmissionStepProgressWhereInput[]
    applicationId?: StringFilter<"AdmissionStepProgress"> | string
    stepName?: StringFilter<"AdmissionStepProgress"> | string
    status?: EnumStepStatusFilter<"AdmissionStepProgress"> | $Enums.StepStatus
    startedAt?: DateTimeNullableFilter<"AdmissionStepProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AdmissionStepProgress"> | Date | string | null
    assignedTo?: StringNullableFilter<"AdmissionStepProgress"> | string | null
    notes?: StringNullableFilter<"AdmissionStepProgress"> | string | null
    createdAt?: DateTimeFilter<"AdmissionStepProgress"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionStepProgress"> | Date | string
    application?: XOR<AdmissionApplicationRelationFilter, AdmissionApplicationWhereInput>
  }, "id" | "applicationId_stepName">

  export type AdmissionStepProgressOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    stepName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdmissionStepProgressCountOrderByAggregateInput
    _max?: AdmissionStepProgressMaxOrderByAggregateInput
    _min?: AdmissionStepProgressMinOrderByAggregateInput
  }

  export type AdmissionStepProgressScalarWhereWithAggregatesInput = {
    AND?: AdmissionStepProgressScalarWhereWithAggregatesInput | AdmissionStepProgressScalarWhereWithAggregatesInput[]
    OR?: AdmissionStepProgressScalarWhereWithAggregatesInput[]
    NOT?: AdmissionStepProgressScalarWhereWithAggregatesInput | AdmissionStepProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmissionStepProgress"> | string
    applicationId?: StringWithAggregatesFilter<"AdmissionStepProgress"> | string
    stepName?: StringWithAggregatesFilter<"AdmissionStepProgress"> | string
    status?: EnumStepStatusWithAggregatesFilter<"AdmissionStepProgress"> | $Enums.StepStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"AdmissionStepProgress"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"AdmissionStepProgress"> | Date | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"AdmissionStepProgress"> | string | null
    notes?: StringNullableWithAggregatesFilter<"AdmissionStepProgress"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdmissionStepProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdmissionStepProgress"> | Date | string
  }

  export type LearningResourceWhereInput = {
    AND?: LearningResourceWhereInput | LearningResourceWhereInput[]
    OR?: LearningResourceWhereInput[]
    NOT?: LearningResourceWhereInput | LearningResourceWhereInput[]
    id?: StringFilter<"LearningResource"> | string
    title?: StringFilter<"LearningResource"> | string
    description?: StringFilter<"LearningResource"> | string
    type?: EnumResourceTypeFilter<"LearningResource"> | $Enums.ResourceType
    subjectId?: StringFilter<"LearningResource"> | string
    level?: StringFilter<"LearningResource"> | string
    url?: StringFilter<"LearningResource"> | string
    thumbnail?: StringNullableFilter<"LearningResource"> | string | null
    duration?: IntNullableFilter<"LearningResource"> | number | null
    tags?: StringNullableListFilter<"LearningResource">
    createdById?: StringFilter<"LearningResource"> | string
    accessLevel?: EnumAccessLevelFilter<"LearningResource"> | $Enums.AccessLevel
    downloadable?: BoolFilter<"LearningResource"> | boolean
    createdAt?: DateTimeFilter<"LearningResource"> | Date | string
    updatedAt?: DateTimeFilter<"LearningResource"> | Date | string
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    createdBy?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type LearningResourceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subjectId?: SortOrder
    level?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdById?: SortOrder
    accessLevel?: SortOrder
    downloadable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
    createdBy?: TeacherOrderByWithRelationInput
  }

  export type LearningResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningResourceWhereInput | LearningResourceWhereInput[]
    OR?: LearningResourceWhereInput[]
    NOT?: LearningResourceWhereInput | LearningResourceWhereInput[]
    title?: StringFilter<"LearningResource"> | string
    description?: StringFilter<"LearningResource"> | string
    type?: EnumResourceTypeFilter<"LearningResource"> | $Enums.ResourceType
    subjectId?: StringFilter<"LearningResource"> | string
    level?: StringFilter<"LearningResource"> | string
    url?: StringFilter<"LearningResource"> | string
    thumbnail?: StringNullableFilter<"LearningResource"> | string | null
    duration?: IntNullableFilter<"LearningResource"> | number | null
    tags?: StringNullableListFilter<"LearningResource">
    createdById?: StringFilter<"LearningResource"> | string
    accessLevel?: EnumAccessLevelFilter<"LearningResource"> | $Enums.AccessLevel
    downloadable?: BoolFilter<"LearningResource"> | boolean
    createdAt?: DateTimeFilter<"LearningResource"> | Date | string
    updatedAt?: DateTimeFilter<"LearningResource"> | Date | string
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    createdBy?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type LearningResourceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subjectId?: SortOrder
    level?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    tags?: SortOrder
    createdById?: SortOrder
    accessLevel?: SortOrder
    downloadable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LearningResourceCountOrderByAggregateInput
    _avg?: LearningResourceAvgOrderByAggregateInput
    _max?: LearningResourceMaxOrderByAggregateInput
    _min?: LearningResourceMinOrderByAggregateInput
    _sum?: LearningResourceSumOrderByAggregateInput
  }

  export type LearningResourceScalarWhereWithAggregatesInput = {
    AND?: LearningResourceScalarWhereWithAggregatesInput | LearningResourceScalarWhereWithAggregatesInput[]
    OR?: LearningResourceScalarWhereWithAggregatesInput[]
    NOT?: LearningResourceScalarWhereWithAggregatesInput | LearningResourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningResource"> | string
    title?: StringWithAggregatesFilter<"LearningResource"> | string
    description?: StringWithAggregatesFilter<"LearningResource"> | string
    type?: EnumResourceTypeWithAggregatesFilter<"LearningResource"> | $Enums.ResourceType
    subjectId?: StringWithAggregatesFilter<"LearningResource"> | string
    level?: StringWithAggregatesFilter<"LearningResource"> | string
    url?: StringWithAggregatesFilter<"LearningResource"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"LearningResource"> | string | null
    duration?: IntNullableWithAggregatesFilter<"LearningResource"> | number | null
    tags?: StringNullableListFilter<"LearningResource">
    createdById?: StringWithAggregatesFilter<"LearningResource"> | string
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"LearningResource"> | $Enums.AccessLevel
    downloadable?: BoolWithAggregatesFilter<"LearningResource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LearningResource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LearningResource"> | Date | string
  }

  export type VirtualClassWhereInput = {
    AND?: VirtualClassWhereInput | VirtualClassWhereInput[]
    OR?: VirtualClassWhereInput[]
    NOT?: VirtualClassWhereInput | VirtualClassWhereInput[]
    id?: StringFilter<"VirtualClass"> | string
    title?: StringFilter<"VirtualClass"> | string
    description?: StringFilter<"VirtualClass"> | string
    teacherId?: StringFilter<"VirtualClass"> | string
    subjectId?: StringFilter<"VirtualClass"> | string
    scheduledStart?: DateTimeFilter<"VirtualClass"> | Date | string
    scheduledEnd?: DateTimeFilter<"VirtualClass"> | Date | string
    meetingUrl?: StringFilter<"VirtualClass"> | string
    recordingUrl?: StringNullableFilter<"VirtualClass"> | string | null
    status?: EnumVirtualClassStatusFilter<"VirtualClass"> | $Enums.VirtualClassStatus
    createdAt?: DateTimeFilter<"VirtualClass"> | Date | string
    updatedAt?: DateTimeFilter<"VirtualClass"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    classes?: VirtualClassParticipantListRelationFilter
  }

  export type VirtualClassOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    meetingUrl?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
    classes?: VirtualClassParticipantOrderByRelationAggregateInput
  }

  export type VirtualClassWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VirtualClassWhereInput | VirtualClassWhereInput[]
    OR?: VirtualClassWhereInput[]
    NOT?: VirtualClassWhereInput | VirtualClassWhereInput[]
    title?: StringFilter<"VirtualClass"> | string
    description?: StringFilter<"VirtualClass"> | string
    teacherId?: StringFilter<"VirtualClass"> | string
    subjectId?: StringFilter<"VirtualClass"> | string
    scheduledStart?: DateTimeFilter<"VirtualClass"> | Date | string
    scheduledEnd?: DateTimeFilter<"VirtualClass"> | Date | string
    meetingUrl?: StringFilter<"VirtualClass"> | string
    recordingUrl?: StringNullableFilter<"VirtualClass"> | string | null
    status?: EnumVirtualClassStatusFilter<"VirtualClass"> | $Enums.VirtualClassStatus
    createdAt?: DateTimeFilter<"VirtualClass"> | Date | string
    updatedAt?: DateTimeFilter<"VirtualClass"> | Date | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
    classes?: VirtualClassParticipantListRelationFilter
  }, "id">

  export type VirtualClassOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    meetingUrl?: SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VirtualClassCountOrderByAggregateInput
    _max?: VirtualClassMaxOrderByAggregateInput
    _min?: VirtualClassMinOrderByAggregateInput
  }

  export type VirtualClassScalarWhereWithAggregatesInput = {
    AND?: VirtualClassScalarWhereWithAggregatesInput | VirtualClassScalarWhereWithAggregatesInput[]
    OR?: VirtualClassScalarWhereWithAggregatesInput[]
    NOT?: VirtualClassScalarWhereWithAggregatesInput | VirtualClassScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VirtualClass"> | string
    title?: StringWithAggregatesFilter<"VirtualClass"> | string
    description?: StringWithAggregatesFilter<"VirtualClass"> | string
    teacherId?: StringWithAggregatesFilter<"VirtualClass"> | string
    subjectId?: StringWithAggregatesFilter<"VirtualClass"> | string
    scheduledStart?: DateTimeWithAggregatesFilter<"VirtualClass"> | Date | string
    scheduledEnd?: DateTimeWithAggregatesFilter<"VirtualClass"> | Date | string
    meetingUrl?: StringWithAggregatesFilter<"VirtualClass"> | string
    recordingUrl?: StringNullableWithAggregatesFilter<"VirtualClass"> | string | null
    status?: EnumVirtualClassStatusWithAggregatesFilter<"VirtualClass"> | $Enums.VirtualClassStatus
    createdAt?: DateTimeWithAggregatesFilter<"VirtualClass"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VirtualClass"> | Date | string
  }

  export type VirtualClassParticipantWhereInput = {
    AND?: VirtualClassParticipantWhereInput | VirtualClassParticipantWhereInput[]
    OR?: VirtualClassParticipantWhereInput[]
    NOT?: VirtualClassParticipantWhereInput | VirtualClassParticipantWhereInput[]
    id?: StringFilter<"VirtualClassParticipant"> | string
    virtualClassId?: StringFilter<"VirtualClassParticipant"> | string
    classId?: StringFilter<"VirtualClassParticipant"> | string
    virtualClass?: XOR<VirtualClassRelationFilter, VirtualClassWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type VirtualClassParticipantOrderByWithRelationInput = {
    id?: SortOrder
    virtualClassId?: SortOrder
    classId?: SortOrder
    virtualClass?: VirtualClassOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type VirtualClassParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    virtualClassId_classId?: VirtualClassParticipantVirtualClassIdClassIdCompoundUniqueInput
    AND?: VirtualClassParticipantWhereInput | VirtualClassParticipantWhereInput[]
    OR?: VirtualClassParticipantWhereInput[]
    NOT?: VirtualClassParticipantWhereInput | VirtualClassParticipantWhereInput[]
    virtualClassId?: StringFilter<"VirtualClassParticipant"> | string
    classId?: StringFilter<"VirtualClassParticipant"> | string
    virtualClass?: XOR<VirtualClassRelationFilter, VirtualClassWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "id" | "virtualClassId_classId">

  export type VirtualClassParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    virtualClassId?: SortOrder
    classId?: SortOrder
    _count?: VirtualClassParticipantCountOrderByAggregateInput
    _max?: VirtualClassParticipantMaxOrderByAggregateInput
    _min?: VirtualClassParticipantMinOrderByAggregateInput
  }

  export type VirtualClassParticipantScalarWhereWithAggregatesInput = {
    AND?: VirtualClassParticipantScalarWhereWithAggregatesInput | VirtualClassParticipantScalarWhereWithAggregatesInput[]
    OR?: VirtualClassParticipantScalarWhereWithAggregatesInput[]
    NOT?: VirtualClassParticipantScalarWhereWithAggregatesInput | VirtualClassParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VirtualClassParticipant"> | string
    virtualClassId?: StringWithAggregatesFilter<"VirtualClassParticipant"> | string
    classId?: StringWithAggregatesFilter<"VirtualClassParticipant"> | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    points?: IntFilter<"Achievement"> | number
    criteria?: StringNullableListFilter<"Achievement">
    rarity?: EnumRarityFilter<"Achievement"> | $Enums.Rarity
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    students?: StudentAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    criteria?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    students?: StudentAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    title?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    category?: EnumAchievementCategoryFilter<"Achievement"> | $Enums.AchievementCategory
    points?: IntFilter<"Achievement"> | number
    criteria?: StringNullableListFilter<"Achievement">
    rarity?: EnumRarityFilter<"Achievement"> | $Enums.Rarity
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeFilter<"Achievement"> | Date | string
    students?: StudentAchievementListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    criteria?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    title?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    icon?: StringWithAggregatesFilter<"Achievement"> | string
    category?: EnumAchievementCategoryWithAggregatesFilter<"Achievement"> | $Enums.AchievementCategory
    points?: IntWithAggregatesFilter<"Achievement"> | number
    criteria?: StringNullableListFilter<"Achievement">
    rarity?: EnumRarityWithAggregatesFilter<"Achievement"> | $Enums.Rarity
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type StudentAchievementWhereInput = {
    AND?: StudentAchievementWhereInput | StudentAchievementWhereInput[]
    OR?: StudentAchievementWhereInput[]
    NOT?: StudentAchievementWhereInput | StudentAchievementWhereInput[]
    id?: StringFilter<"StudentAchievement"> | string
    studentId?: StringFilter<"StudentAchievement"> | string
    achievementId?: StringFilter<"StudentAchievement"> | string
    earnedDate?: DateTimeFilter<"StudentAchievement"> | Date | string
    awardedBy?: StringFilter<"StudentAchievement"> | string
    evidence?: StringNullableFilter<"StudentAchievement"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }

  export type StudentAchievementOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
    awardedBy?: SortOrder
    evidence?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type StudentAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_achievementId?: StudentAchievementStudentIdAchievementIdCompoundUniqueInput
    AND?: StudentAchievementWhereInput | StudentAchievementWhereInput[]
    OR?: StudentAchievementWhereInput[]
    NOT?: StudentAchievementWhereInput | StudentAchievementWhereInput[]
    studentId?: StringFilter<"StudentAchievement"> | string
    achievementId?: StringFilter<"StudentAchievement"> | string
    earnedDate?: DateTimeFilter<"StudentAchievement"> | Date | string
    awardedBy?: StringFilter<"StudentAchievement"> | string
    evidence?: StringNullableFilter<"StudentAchievement"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    achievement?: XOR<AchievementRelationFilter, AchievementWhereInput>
  }, "id" | "studentId_achievementId">

  export type StudentAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
    awardedBy?: SortOrder
    evidence?: SortOrderInput | SortOrder
    _count?: StudentAchievementCountOrderByAggregateInput
    _max?: StudentAchievementMaxOrderByAggregateInput
    _min?: StudentAchievementMinOrderByAggregateInput
  }

  export type StudentAchievementScalarWhereWithAggregatesInput = {
    AND?: StudentAchievementScalarWhereWithAggregatesInput | StudentAchievementScalarWhereWithAggregatesInput[]
    OR?: StudentAchievementScalarWhereWithAggregatesInput[]
    NOT?: StudentAchievementScalarWhereWithAggregatesInput | StudentAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentAchievement"> | string
    studentId?: StringWithAggregatesFilter<"StudentAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"StudentAchievement"> | string
    earnedDate?: DateTimeWithAggregatesFilter<"StudentAchievement"> | Date | string
    awardedBy?: StringWithAggregatesFilter<"StudentAchievement"> | string
    evidence?: StringNullableWithAggregatesFilter<"StudentAchievement"> | string | null
  }

  export type BehaviorRecordWhereInput = {
    AND?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    OR?: BehaviorRecordWhereInput[]
    NOT?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    id?: StringFilter<"BehaviorRecord"> | string
    studentId?: StringFilter<"BehaviorRecord"> | string
    teacherId?: StringFilter<"BehaviorRecord"> | string
    date?: DateTimeFilter<"BehaviorRecord"> | Date | string
    type?: EnumBehaviorTypeFilter<"BehaviorRecord"> | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFilter<"BehaviorRecord"> | $Enums.BehaviorCategory
    description?: StringFilter<"BehaviorRecord"> | string
    severity?: EnumSeverityNullableFilter<"BehaviorRecord"> | $Enums.Severity | null
    actionTaken?: StringNullableFilter<"BehaviorRecord"> | string | null
    parentNotified?: BoolFilter<"BehaviorRecord"> | boolean
    followUpRequired?: BoolFilter<"BehaviorRecord"> | boolean
    createdAt?: DateTimeFilter<"BehaviorRecord"> | Date | string
    updatedAt?: DateTimeFilter<"BehaviorRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }

  export type BehaviorRecordOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    severity?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    parentNotified?: SortOrder
    followUpRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    teacher?: TeacherOrderByWithRelationInput
  }

  export type BehaviorRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    OR?: BehaviorRecordWhereInput[]
    NOT?: BehaviorRecordWhereInput | BehaviorRecordWhereInput[]
    studentId?: StringFilter<"BehaviorRecord"> | string
    teacherId?: StringFilter<"BehaviorRecord"> | string
    date?: DateTimeFilter<"BehaviorRecord"> | Date | string
    type?: EnumBehaviorTypeFilter<"BehaviorRecord"> | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFilter<"BehaviorRecord"> | $Enums.BehaviorCategory
    description?: StringFilter<"BehaviorRecord"> | string
    severity?: EnumSeverityNullableFilter<"BehaviorRecord"> | $Enums.Severity | null
    actionTaken?: StringNullableFilter<"BehaviorRecord"> | string | null
    parentNotified?: BoolFilter<"BehaviorRecord"> | boolean
    followUpRequired?: BoolFilter<"BehaviorRecord"> | boolean
    createdAt?: DateTimeFilter<"BehaviorRecord"> | Date | string
    updatedAt?: DateTimeFilter<"BehaviorRecord"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
  }, "id">

  export type BehaviorRecordOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    severity?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    parentNotified?: SortOrder
    followUpRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BehaviorRecordCountOrderByAggregateInput
    _max?: BehaviorRecordMaxOrderByAggregateInput
    _min?: BehaviorRecordMinOrderByAggregateInput
  }

  export type BehaviorRecordScalarWhereWithAggregatesInput = {
    AND?: BehaviorRecordScalarWhereWithAggregatesInput | BehaviorRecordScalarWhereWithAggregatesInput[]
    OR?: BehaviorRecordScalarWhereWithAggregatesInput[]
    NOT?: BehaviorRecordScalarWhereWithAggregatesInput | BehaviorRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BehaviorRecord"> | string
    studentId?: StringWithAggregatesFilter<"BehaviorRecord"> | string
    teacherId?: StringWithAggregatesFilter<"BehaviorRecord"> | string
    date?: DateTimeWithAggregatesFilter<"BehaviorRecord"> | Date | string
    type?: EnumBehaviorTypeWithAggregatesFilter<"BehaviorRecord"> | $Enums.BehaviorType
    category?: EnumBehaviorCategoryWithAggregatesFilter<"BehaviorRecord"> | $Enums.BehaviorCategory
    description?: StringWithAggregatesFilter<"BehaviorRecord"> | string
    severity?: EnumSeverityNullableWithAggregatesFilter<"BehaviorRecord"> | $Enums.Severity | null
    actionTaken?: StringNullableWithAggregatesFilter<"BehaviorRecord"> | string | null
    parentNotified?: BoolWithAggregatesFilter<"BehaviorRecord"> | boolean
    followUpRequired?: BoolWithAggregatesFilter<"BehaviorRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BehaviorRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BehaviorRecord"> | Date | string
  }

  export type ReportCardWhereInput = {
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    id?: StringFilter<"ReportCard"> | string
    studentId?: StringFilter<"ReportCard"> | string
    academicYear?: StringFilter<"ReportCard"> | string
    semester?: StringFilter<"ReportCard"> | string
    overallAverage?: FloatFilter<"ReportCard"> | number
    rank?: IntNullableFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableFilter<"ReportCard"> | number | null
    behaviorGrade?: EnumBehaviorGradeFilter<"ReportCard"> | $Enums.BehaviorGrade
    totalDays?: IntFilter<"ReportCard"> | number
    presentDays?: IntFilter<"ReportCard"> | number
    absentDays?: IntFilter<"ReportCard"> | number
    lateCount?: IntFilter<"ReportCard"> | number
    principalComment?: StringNullableFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    generatedBy?: StringFilter<"ReportCard"> | string
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type ReportCardOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    overallAverage?: SortOrder
    rank?: SortOrderInput | SortOrder
    totalStudents?: SortOrderInput | SortOrder
    behaviorGrade?: SortOrder
    totalDays?: SortOrder
    presentDays?: SortOrder
    absentDays?: SortOrder
    lateCount?: SortOrder
    principalComment?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type ReportCardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_academicYear_semester?: ReportCardStudentIdAcademicYearSemesterCompoundUniqueInput
    AND?: ReportCardWhereInput | ReportCardWhereInput[]
    OR?: ReportCardWhereInput[]
    NOT?: ReportCardWhereInput | ReportCardWhereInput[]
    studentId?: StringFilter<"ReportCard"> | string
    academicYear?: StringFilter<"ReportCard"> | string
    semester?: StringFilter<"ReportCard"> | string
    overallAverage?: FloatFilter<"ReportCard"> | number
    rank?: IntNullableFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableFilter<"ReportCard"> | number | null
    behaviorGrade?: EnumBehaviorGradeFilter<"ReportCard"> | $Enums.BehaviorGrade
    totalDays?: IntFilter<"ReportCard"> | number
    presentDays?: IntFilter<"ReportCard"> | number
    absentDays?: IntFilter<"ReportCard"> | number
    lateCount?: IntFilter<"ReportCard"> | number
    principalComment?: StringNullableFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    generatedBy?: StringFilter<"ReportCard"> | string
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "studentId_academicYear_semester">

  export type ReportCardOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    overallAverage?: SortOrder
    rank?: SortOrderInput | SortOrder
    totalStudents?: SortOrderInput | SortOrder
    behaviorGrade?: SortOrder
    totalDays?: SortOrder
    presentDays?: SortOrder
    absentDays?: SortOrder
    lateCount?: SortOrder
    principalComment?: SortOrderInput | SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCardCountOrderByAggregateInput
    _avg?: ReportCardAvgOrderByAggregateInput
    _max?: ReportCardMaxOrderByAggregateInput
    _min?: ReportCardMinOrderByAggregateInput
    _sum?: ReportCardSumOrderByAggregateInput
  }

  export type ReportCardScalarWhereWithAggregatesInput = {
    AND?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    OR?: ReportCardScalarWhereWithAggregatesInput[]
    NOT?: ReportCardScalarWhereWithAggregatesInput | ReportCardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportCard"> | string
    studentId?: StringWithAggregatesFilter<"ReportCard"> | string
    academicYear?: StringWithAggregatesFilter<"ReportCard"> | string
    semester?: StringWithAggregatesFilter<"ReportCard"> | string
    overallAverage?: FloatWithAggregatesFilter<"ReportCard"> | number
    rank?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableWithAggregatesFilter<"ReportCard"> | number | null
    behaviorGrade?: EnumBehaviorGradeWithAggregatesFilter<"ReportCard"> | $Enums.BehaviorGrade
    totalDays?: IntWithAggregatesFilter<"ReportCard"> | number
    presentDays?: IntWithAggregatesFilter<"ReportCard"> | number
    absentDays?: IntWithAggregatesFilter<"ReportCard"> | number
    lateCount?: IntWithAggregatesFilter<"ReportCard"> | number
    principalComment?: StringNullableWithAggregatesFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
    generatedBy?: StringWithAggregatesFilter<"ReportCard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportCard"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"Notification"> | $Enums.NotificationCategory
    read?: BoolFilter<"Notification"> | boolean
    actionRequired?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    read?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    channels?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    recipientId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"Notification"> | $Enums.NotificationCategory
    read?: BoolFilter<"Notification"> | boolean
    actionRequired?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    read?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    scheduledFor?: SortOrderInput | SortOrder
    channels?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryWithAggregatesFilter<"Notification"> | $Enums.NotificationCategory
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionRequired?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    scheduledFor?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type FileAttachmentWhereInput = {
    AND?: FileAttachmentWhereInput | FileAttachmentWhereInput[]
    OR?: FileAttachmentWhereInput[]
    NOT?: FileAttachmentWhereInput | FileAttachmentWhereInput[]
    id?: StringFilter<"FileAttachment"> | string
    name?: StringFilter<"FileAttachment"> | string
    originalName?: StringFilter<"FileAttachment"> | string
    url?: StringFilter<"FileAttachment"> | string
    type?: StringFilter<"FileAttachment"> | string
    size?: IntFilter<"FileAttachment"> | number
    uploadedBy?: StringFilter<"FileAttachment"> | string
    assignmentId?: StringNullableFilter<"FileAttachment"> | string | null
    submissionId?: StringNullableFilter<"FileAttachment"> | string | null
    messageId?: StringNullableFilter<"FileAttachment"> | string | null
    admissionId?: StringNullableFilter<"FileAttachment"> | string | null
    createdAt?: DateTimeFilter<"FileAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"FileAttachment"> | Date | string
    assignment?: XOR<AssignmentNullableRelationFilter, AssignmentWhereInput> | null
    submission?: XOR<AssignmentSubmissionNullableRelationFilter, AssignmentSubmissionWhereInput> | null
    message?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    admission?: XOR<AdmissionApplicationNullableRelationFilter, AdmissionApplicationWhereInput> | null
  }

  export type FileAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    submissionId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    submission?: AssignmentSubmissionOrderByWithRelationInput
    message?: MessageOrderByWithRelationInput
    admission?: AdmissionApplicationOrderByWithRelationInput
  }

  export type FileAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileAttachmentWhereInput | FileAttachmentWhereInput[]
    OR?: FileAttachmentWhereInput[]
    NOT?: FileAttachmentWhereInput | FileAttachmentWhereInput[]
    name?: StringFilter<"FileAttachment"> | string
    originalName?: StringFilter<"FileAttachment"> | string
    url?: StringFilter<"FileAttachment"> | string
    type?: StringFilter<"FileAttachment"> | string
    size?: IntFilter<"FileAttachment"> | number
    uploadedBy?: StringFilter<"FileAttachment"> | string
    assignmentId?: StringNullableFilter<"FileAttachment"> | string | null
    submissionId?: StringNullableFilter<"FileAttachment"> | string | null
    messageId?: StringNullableFilter<"FileAttachment"> | string | null
    admissionId?: StringNullableFilter<"FileAttachment"> | string | null
    createdAt?: DateTimeFilter<"FileAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"FileAttachment"> | Date | string
    assignment?: XOR<AssignmentNullableRelationFilter, AssignmentWhereInput> | null
    submission?: XOR<AssignmentSubmissionNullableRelationFilter, AssignmentSubmissionWhereInput> | null
    message?: XOR<MessageNullableRelationFilter, MessageWhereInput> | null
    admission?: XOR<AdmissionApplicationNullableRelationFilter, AdmissionApplicationWhereInput> | null
  }, "id">

  export type FileAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    submissionId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileAttachmentCountOrderByAggregateInput
    _avg?: FileAttachmentAvgOrderByAggregateInput
    _max?: FileAttachmentMaxOrderByAggregateInput
    _min?: FileAttachmentMinOrderByAggregateInput
    _sum?: FileAttachmentSumOrderByAggregateInput
  }

  export type FileAttachmentScalarWhereWithAggregatesInput = {
    AND?: FileAttachmentScalarWhereWithAggregatesInput | FileAttachmentScalarWhereWithAggregatesInput[]
    OR?: FileAttachmentScalarWhereWithAggregatesInput[]
    NOT?: FileAttachmentScalarWhereWithAggregatesInput | FileAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileAttachment"> | string
    name?: StringWithAggregatesFilter<"FileAttachment"> | string
    originalName?: StringWithAggregatesFilter<"FileAttachment"> | string
    url?: StringWithAggregatesFilter<"FileAttachment"> | string
    type?: StringWithAggregatesFilter<"FileAttachment"> | string
    size?: IntWithAggregatesFilter<"FileAttachment"> | number
    uploadedBy?: StringWithAggregatesFilter<"FileAttachment"> | string
    assignmentId?: StringNullableWithAggregatesFilter<"FileAttachment"> | string | null
    submissionId?: StringNullableWithAggregatesFilter<"FileAttachment"> | string | null
    messageId?: StringNullableWithAggregatesFilter<"FileAttachment"> | string | null
    admissionId?: StringNullableWithAggregatesFilter<"FileAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FileAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileAttachment"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    deviceInfo?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type TeacherSubjectWhereInput = {
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }

  export type TeacherSubjectOrderByWithRelationInput = {
    teacherId?: SortOrder
    subjectId?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type TeacherSubjectWhereUniqueInput = Prisma.AtLeast<{
    teacherId_subjectId?: TeacherSubjectTeacherIdSubjectIdCompoundUniqueInput
    AND?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    OR?: TeacherSubjectWhereInput[]
    NOT?: TeacherSubjectWhereInput | TeacherSubjectWhereInput[]
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }, "teacherId_subjectId">

  export type TeacherSubjectOrderByWithAggregationInput = {
    teacherId?: SortOrder
    subjectId?: SortOrder
    _count?: TeacherSubjectCountOrderByAggregateInput
    _max?: TeacherSubjectMaxOrderByAggregateInput
    _min?: TeacherSubjectMinOrderByAggregateInput
  }

  export type TeacherSubjectScalarWhereWithAggregatesInput = {
    AND?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    OR?: TeacherSubjectScalarWhereWithAggregatesInput[]
    NOT?: TeacherSubjectScalarWhereWithAggregatesInput | TeacherSubjectScalarWhereWithAggregatesInput[]
    teacherId?: StringWithAggregatesFilter<"TeacherSubject"> | string
    subjectId?: StringWithAggregatesFilter<"TeacherSubject"> | string
  }

  export type TeacherClassWhereInput = {
    AND?: TeacherClassWhereInput | TeacherClassWhereInput[]
    OR?: TeacherClassWhereInput[]
    NOT?: TeacherClassWhereInput | TeacherClassWhereInput[]
    teacherId?: StringFilter<"TeacherClass"> | string
    classId?: StringFilter<"TeacherClass"> | string
    isMainTeacher?: BoolFilter<"TeacherClass"> | boolean
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type TeacherClassOrderByWithRelationInput = {
    teacherId?: SortOrder
    classId?: SortOrder
    isMainTeacher?: SortOrder
    teacher?: TeacherOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type TeacherClassWhereUniqueInput = Prisma.AtLeast<{
    teacherId_classId?: TeacherClassTeacherIdClassIdCompoundUniqueInput
    AND?: TeacherClassWhereInput | TeacherClassWhereInput[]
    OR?: TeacherClassWhereInput[]
    NOT?: TeacherClassWhereInput | TeacherClassWhereInput[]
    teacherId?: StringFilter<"TeacherClass"> | string
    classId?: StringFilter<"TeacherClass"> | string
    isMainTeacher?: BoolFilter<"TeacherClass"> | boolean
    teacher?: XOR<TeacherRelationFilter, TeacherWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "teacherId_classId">

  export type TeacherClassOrderByWithAggregationInput = {
    teacherId?: SortOrder
    classId?: SortOrder
    isMainTeacher?: SortOrder
    _count?: TeacherClassCountOrderByAggregateInput
    _max?: TeacherClassMaxOrderByAggregateInput
    _min?: TeacherClassMinOrderByAggregateInput
  }

  export type TeacherClassScalarWhereWithAggregatesInput = {
    AND?: TeacherClassScalarWhereWithAggregatesInput | TeacherClassScalarWhereWithAggregatesInput[]
    OR?: TeacherClassScalarWhereWithAggregatesInput[]
    NOT?: TeacherClassScalarWhereWithAggregatesInput | TeacherClassScalarWhereWithAggregatesInput[]
    teacherId?: StringWithAggregatesFilter<"TeacherClass"> | string
    classId?: StringWithAggregatesFilter<"TeacherClass"> | string
    isMainTeacher?: BoolWithAggregatesFilter<"TeacherClass"> | boolean
  }

  export type ClassSubjectWhereInput = {
    AND?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    OR?: ClassSubjectWhereInput[]
    NOT?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }

  export type ClassSubjectOrderByWithRelationInput = {
    classId?: SortOrder
    subjectId?: SortOrder
    class?: ClassOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type ClassSubjectWhereUniqueInput = Prisma.AtLeast<{
    classId_subjectId?: ClassSubjectClassIdSubjectIdCompoundUniqueInput
    AND?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    OR?: ClassSubjectWhereInput[]
    NOT?: ClassSubjectWhereInput | ClassSubjectWhereInput[]
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
    class?: XOR<ClassRelationFilter, ClassWhereInput>
    subject?: XOR<SubjectRelationFilter, SubjectWhereInput>
  }, "classId_subjectId">

  export type ClassSubjectOrderByWithAggregationInput = {
    classId?: SortOrder
    subjectId?: SortOrder
    _count?: ClassSubjectCountOrderByAggregateInput
    _max?: ClassSubjectMaxOrderByAggregateInput
    _min?: ClassSubjectMinOrderByAggregateInput
  }

  export type ClassSubjectScalarWhereWithAggregatesInput = {
    AND?: ClassSubjectScalarWhereWithAggregatesInput | ClassSubjectScalarWhereWithAggregatesInput[]
    OR?: ClassSubjectScalarWhereWithAggregatesInput[]
    NOT?: ClassSubjectScalarWhereWithAggregatesInput | ClassSubjectScalarWhereWithAggregatesInput[]
    classId?: StringWithAggregatesFilter<"ClassSubject"> | string
    subjectId?: StringWithAggregatesFilter<"ClassSubject"> | string
  }

  export type AssignmentClassWhereInput = {
    AND?: AssignmentClassWhereInput | AssignmentClassWhereInput[]
    OR?: AssignmentClassWhereInput[]
    NOT?: AssignmentClassWhereInput | AssignmentClassWhereInput[]
    assignmentId?: StringFilter<"AssignmentClass"> | string
    classId?: StringFilter<"AssignmentClass"> | string
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }

  export type AssignmentClassOrderByWithRelationInput = {
    assignmentId?: SortOrder
    classId?: SortOrder
    assignment?: AssignmentOrderByWithRelationInput
    class?: ClassOrderByWithRelationInput
  }

  export type AssignmentClassWhereUniqueInput = Prisma.AtLeast<{
    assignmentId_classId?: AssignmentClassAssignmentIdClassIdCompoundUniqueInput
    AND?: AssignmentClassWhereInput | AssignmentClassWhereInput[]
    OR?: AssignmentClassWhereInput[]
    NOT?: AssignmentClassWhereInput | AssignmentClassWhereInput[]
    assignmentId?: StringFilter<"AssignmentClass"> | string
    classId?: StringFilter<"AssignmentClass"> | string
    assignment?: XOR<AssignmentRelationFilter, AssignmentWhereInput>
    class?: XOR<ClassRelationFilter, ClassWhereInput>
  }, "assignmentId_classId">

  export type AssignmentClassOrderByWithAggregationInput = {
    assignmentId?: SortOrder
    classId?: SortOrder
    _count?: AssignmentClassCountOrderByAggregateInput
    _max?: AssignmentClassMaxOrderByAggregateInput
    _min?: AssignmentClassMinOrderByAggregateInput
  }

  export type AssignmentClassScalarWhereWithAggregatesInput = {
    AND?: AssignmentClassScalarWhereWithAggregatesInput | AssignmentClassScalarWhereWithAggregatesInput[]
    OR?: AssignmentClassScalarWhereWithAggregatesInput[]
    NOT?: AssignmentClassScalarWhereWithAggregatesInput | AssignmentClassScalarWhereWithAggregatesInput[]
    assignmentId?: StringWithAggregatesFilter<"AssignmentClass"> | string
    classId?: StringWithAggregatesFilter<"AssignmentClass"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherCreateInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateManyInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    id?: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    children?: StudentCreateNestedManyWithoutParentsInput
    admissionApplications?: AdmissionApplicationCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    userId: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentUncheckedCreateNestedManyWithoutParentsInput
    admissionApplications?: AdmissionApplicationUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    children?: StudentUpdateManyWithoutParentsNestedInput
    admissionApplications?: AdmissionApplicationUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentUncheckedUpdateManyWithoutParentsNestedInput
    admissionApplications?: AdmissionApplicationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    userId: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassCreateInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherClassCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    schedules?: ScheduleCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherClassUncheckedCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUncheckedUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateManyInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    grades?: GradeCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    grades?: GradeUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    grades?: GradeUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
    subject: SubjectCreateNestedOneWithoutGradesInput
    teacher: TeacherCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    studentId: string
    subjectId: string
    teacherId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradesNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyInput = {
    id?: string
    studentId: string
    subjectId: string
    teacherId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentCreateInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutAssignmentsInput
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    classes?: AssignmentClassCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    teacherId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: AssignmentClassUncheckedCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    classes?: AssignmentClassUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: AssignmentClassUncheckedUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentCreateManyInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    teacherId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionCreateInput = {
    id?: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
    student: StudentCreateNestedOneWithoutAssignmentsInput
    attachments?: FileAttachmentCreateNestedManyWithoutSubmissionInput
  }

  export type AssignmentSubmissionUncheckedCreateInput = {
    id?: string
    assignmentId: string
    studentId: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type AssignmentSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
    student?: StudentUpdateOneRequiredWithoutAssignmentsNestedInput
    attachments?: FileAttachmentUpdateManyWithoutSubmissionNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: FileAttachmentUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type AssignmentSubmissionCreateManyInput = {
    id?: string
    assignmentId: string
    studentId: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceRecordsInput
    class?: ClassCreateNestedOneWithoutAttendanceRecordsInput
    teacher: TeacherCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateInput = {
    id?: string
    studentId: string
    classId?: string | null
    teacherId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    class?: ClassUpdateOneWithoutAttendanceRecordsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordCreateManyInput = {
    id?: string
    studentId: string
    classId?: string | null
    teacherId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    id?: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutSchedulesInput
    teacher: TeacherCreateNestedOneWithoutSchedulesInput
    subject: SubjectCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    classId: string
    teacherId: string
    subjectId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutSchedulesNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutSchedulesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyInput = {
    id?: string
    classId: string
    teacherId: string
    subjectId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipients?: UserCreateNestedManyWithoutReceivedMessagesInput
    parentMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    senderId: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: UserUncheckedCreateNestedManyWithoutReceivedMessagesInput
    replies?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipients?: UserUpdateManyWithoutReceivedMessagesNestedInput
    parentMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUncheckedUpdateManyWithoutReceivedMessagesNestedInput
    replies?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    senderId: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialRecordCreateInput = {
    id?: string
    type: $Enums.FinancialType
    amount: number
    currency?: string
    dueDate: Date | string
    paidDate?: Date | string | null
    status?: $Enums.PaymentStatus
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    invoiceNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutFinancialRecordsInput
  }

  export type FinancialRecordUncheckedCreateInput = {
    id?: string
    studentId: string
    type: $Enums.FinancialType
    amount: number
    currency?: string
    dueDate: Date | string
    paidDate?: Date | string | null
    status?: $Enums.PaymentStatus
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    invoiceNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialTypeFieldUpdateOperationsInput | $Enums.FinancialType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutFinancialRecordsNestedInput
  }

  export type FinancialRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialTypeFieldUpdateOperationsInput | $Enums.FinancialType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialRecordCreateManyInput = {
    id?: string
    studentId: string
    type: $Enums.FinancialType
    amount: number
    currency?: string
    dueDate: Date | string
    paidDate?: Date | string | null
    status?: $Enums.PaymentStatus
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    invoiceNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialTypeFieldUpdateOperationsInput | $Enums.FinancialType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialTypeFieldUpdateOperationsInput | $Enums.FinancialType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionApplicationCreateInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ParentCreateNestedOneWithoutAdmissionApplicationsInput
    documents?: FileAttachmentCreateNestedManyWithoutAdmissionInput
    stepProgress?: AdmissionStepProgressCreateNestedManyWithoutApplicationInput
  }

  export type AdmissionApplicationUncheckedCreateInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    parentId?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: FileAttachmentUncheckedCreateNestedManyWithoutAdmissionInput
    stepProgress?: AdmissionStepProgressUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type AdmissionApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneWithoutAdmissionApplicationsNestedInput
    documents?: FileAttachmentUpdateManyWithoutAdmissionNestedInput
    stepProgress?: AdmissionStepProgressUpdateManyWithoutApplicationNestedInput
  }

  export type AdmissionApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FileAttachmentUncheckedUpdateManyWithoutAdmissionNestedInput
    stepProgress?: AdmissionStepProgressUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type AdmissionApplicationCreateManyInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    parentId?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionStepProgressCreateInput = {
    id?: string
    stepName: string
    status?: $Enums.StepStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    assignedTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    application: AdmissionApplicationCreateNestedOneWithoutStepProgressInput
  }

  export type AdmissionStepProgressUncheckedCreateInput = {
    id?: string
    applicationId: string
    stepName: string
    status?: $Enums.StepStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    assignedTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionStepProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepName?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    application?: AdmissionApplicationUpdateOneRequiredWithoutStepProgressNestedInput
  }

  export type AdmissionStepProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    stepName?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionStepProgressCreateManyInput = {
    id?: string
    applicationId: string
    stepName: string
    status?: $Enums.StepStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    assignedTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionStepProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepName?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionStepProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    stepName?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningResourceCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutResourcesInput
    createdBy: TeacherCreateNestedOneWithoutResourcesInput
  }

  export type LearningResourceUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    subjectId: string
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    createdById: string
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningResourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutResourcesNestedInput
    createdBy?: TeacherUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type LearningResourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    subjectId?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    createdById?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningResourceCreateManyInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    subjectId: string
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    createdById: string
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningResourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningResourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    subjectId?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    createdById?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassCreateInput = {
    id?: string
    title: string
    description: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutVirtualClassesInput
    subject: SubjectCreateNestedOneWithoutVirtualClassesInput
    classes?: VirtualClassParticipantCreateNestedManyWithoutVirtualClassInput
  }

  export type VirtualClassUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    teacherId: string
    subjectId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: VirtualClassParticipantUncheckedCreateNestedManyWithoutVirtualClassInput
  }

  export type VirtualClassUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutVirtualClassesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutVirtualClassesNestedInput
    classes?: VirtualClassParticipantUpdateManyWithoutVirtualClassNestedInput
  }

  export type VirtualClassUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: VirtualClassParticipantUncheckedUpdateManyWithoutVirtualClassNestedInput
  }

  export type VirtualClassCreateManyInput = {
    id?: string
    title: string
    description: string
    teacherId: string
    subjectId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VirtualClassUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassParticipantCreateInput = {
    id?: string
    virtualClass: VirtualClassCreateNestedOneWithoutClassesInput
    class: ClassCreateNestedOneWithoutVirtualClassesInput
  }

  export type VirtualClassParticipantUncheckedCreateInput = {
    id?: string
    virtualClassId: string
    classId: string
  }

  export type VirtualClassParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualClass?: VirtualClassUpdateOneRequiredWithoutClassesNestedInput
    class?: ClassUpdateOneRequiredWithoutVirtualClassesNestedInput
  }

  export type VirtualClassParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualClassId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualClassParticipantCreateManyInput = {
    id?: string
    virtualClassId: string
    classId: string
  }

  export type VirtualClassParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualClassParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualClassId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type AchievementCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    points: number
    criteria?: AchievementCreatecriteriaInput | string[]
    rarity?: $Enums.Rarity
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    points: number
    criteria?: AchievementCreatecriteriaInput | string[]
    rarity?: $Enums.Rarity
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    points?: IntFieldUpdateOperationsInput | number
    criteria?: AchievementUpdatecriteriaInput | string[]
    rarity?: EnumRarityFieldUpdateOperationsInput | $Enums.Rarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    points?: IntFieldUpdateOperationsInput | number
    criteria?: AchievementUpdatecriteriaInput | string[]
    rarity?: EnumRarityFieldUpdateOperationsInput | $Enums.Rarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    points: number
    criteria?: AchievementCreatecriteriaInput | string[]
    rarity?: $Enums.Rarity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    points?: IntFieldUpdateOperationsInput | number
    criteria?: AchievementUpdatecriteriaInput | string[]
    rarity?: EnumRarityFieldUpdateOperationsInput | $Enums.Rarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    points?: IntFieldUpdateOperationsInput | number
    criteria?: AchievementUpdatecriteriaInput | string[]
    rarity?: EnumRarityFieldUpdateOperationsInput | $Enums.Rarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAchievementCreateInput = {
    id?: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
    student: StudentCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutStudentsInput
  }

  export type StudentAchievementUncheckedCreateInput = {
    id?: string
    studentId: string
    achievementId: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
  }

  export type StudentAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentAchievementCreateManyInput = {
    id?: string
    studentId: string
    achievementId: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
  }

  export type StudentAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehaviorRecordCreateInput = {
    id?: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutBehaviorRecordsInput
    teacher: TeacherCreateNestedOneWithoutBehaviorRecordsInput
  }

  export type BehaviorRecordUncheckedCreateInput = {
    id?: string
    studentId: string
    teacherId: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutBehaviorRecordsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutBehaviorRecordsNestedInput
  }

  export type BehaviorRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordCreateManyInput = {
    id?: string
    studentId: string
    teacherId: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardCreateInput = {
    id?: string
    academicYear: string
    semester: string
    overallAverage: number
    rank?: number | null
    totalStudents?: number | null
    behaviorGrade?: $Enums.BehaviorGrade
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment?: string | null
    generatedAt: Date | string
    generatedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutReportCardsInput
  }

  export type ReportCardUncheckedCreateInput = {
    id?: string
    studentId: string
    academicYear: string
    semester: string
    overallAverage: number
    rank?: number | null
    totalStudents?: number | null
    behaviorGrade?: $Enums.BehaviorGrade
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment?: string | null
    generatedAt: Date | string
    generatedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    overallAverage?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    behaviorGrade?: EnumBehaviorGradeFieldUpdateOperationsInput | $Enums.BehaviorGrade
    totalDays?: IntFieldUpdateOperationsInput | number
    presentDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutReportCardsNestedInput
  }

  export type ReportCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    overallAverage?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    behaviorGrade?: EnumBehaviorGradeFieldUpdateOperationsInput | $Enums.BehaviorGrade
    totalDays?: IntFieldUpdateOperationsInput | number
    presentDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardCreateManyInput = {
    id?: string
    studentId: string
    academicYear: string
    semester: string
    overallAverage: number
    rank?: number | null
    totalStudents?: number | null
    behaviorGrade?: $Enums.BehaviorGrade
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment?: string | null
    generatedAt: Date | string
    generatedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    overallAverage?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    behaviorGrade?: EnumBehaviorGradeFieldUpdateOperationsInput | $Enums.BehaviorGrade
    totalDays?: IntFieldUpdateOperationsInput | number
    presentDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    overallAverage?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    behaviorGrade?: EnumBehaviorGradeFieldUpdateOperationsInput | $Enums.BehaviorGrade
    totalDays?: IntFieldUpdateOperationsInput | number
    presentDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    read?: boolean
    actionRequired?: boolean
    actionUrl?: string | null
    scheduledFor?: Date | string | null
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    recipientId: string
    title: string
    message: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    read?: boolean
    actionRequired?: boolean
    actionUrl?: string | null
    scheduledFor?: Date | string | null
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    read?: BoolFieldUpdateOperationsInput | boolean
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    read?: BoolFieldUpdateOperationsInput | boolean
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    recipientId: string
    title: string
    message: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    read?: boolean
    actionRequired?: boolean
    actionUrl?: string | null
    scheduledFor?: Date | string | null
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    read?: BoolFieldUpdateOperationsInput | boolean
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    read?: BoolFieldUpdateOperationsInput | boolean
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentCreateInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutAttachmentsInput
    submission?: AssignmentSubmissionCreateNestedOneWithoutAttachmentsInput
    message?: MessageCreateNestedOneWithoutAttachmentsInput
    admission?: AdmissionApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type FileAttachmentUncheckedCreateInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    submissionId?: string | null
    messageId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutAttachmentsNestedInput
    submission?: AssignmentSubmissionUpdateOneWithoutAttachmentsNestedInput
    message?: MessageUpdateOneWithoutAttachmentsNestedInput
    admission?: AdmissionApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type FileAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentCreateManyInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    submissionId?: string | null
    messageId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherSubjectCreateInput = {
    teacher: TeacherCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutTeachersInput
  }

  export type TeacherSubjectUncheckedCreateInput = {
    teacherId: string
    subjectId: string
  }

  export type TeacherSubjectUpdateInput = {
    teacher?: TeacherUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherSubjectUncheckedUpdateInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectCreateManyInput = {
    teacherId: string
    subjectId: string
  }

  export type TeacherSubjectUpdateManyMutationInput = {

  }

  export type TeacherSubjectUncheckedUpdateManyInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassCreateInput = {
    isMainTeacher?: boolean
    teacher: TeacherCreateNestedOneWithoutClassesInput
    class: ClassCreateNestedOneWithoutTeachersInput
  }

  export type TeacherClassUncheckedCreateInput = {
    teacherId: string
    classId: string
    isMainTeacher?: boolean
  }

  export type TeacherClassUpdateInput = {
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeacherUpdateOneRequiredWithoutClassesNestedInput
    class?: ClassUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherClassUncheckedUpdateInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherClassCreateManyInput = {
    teacherId: string
    classId: string
    isMainTeacher?: boolean
  }

  export type TeacherClassUpdateManyMutationInput = {
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherClassUncheckedUpdateManyInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassSubjectCreateInput = {
    class: ClassCreateNestedOneWithoutSubjectsInput
    subject: SubjectCreateNestedOneWithoutClassesInput
  }

  export type ClassSubjectUncheckedCreateInput = {
    classId: string
    subjectId: string
  }

  export type ClassSubjectUpdateInput = {
    class?: ClassUpdateOneRequiredWithoutSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassSubjectUncheckedUpdateInput = {
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectCreateManyInput = {
    classId: string
    subjectId: string
  }

  export type ClassSubjectUpdateManyMutationInput = {

  }

  export type ClassSubjectUncheckedUpdateManyInput = {
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentClassCreateInput = {
    assignment: AssignmentCreateNestedOneWithoutClassesInput
    class: ClassCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentClassUncheckedCreateInput = {
    assignmentId: string
    classId: string
  }

  export type AssignmentClassUpdateInput = {
    assignment?: AssignmentUpdateOneRequiredWithoutClassesNestedInput
    class?: ClassUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentClassUncheckedUpdateInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentClassCreateManyInput = {
    assignmentId: string
    classId: string
  }

  export type AssignmentClassUpdateManyMutationInput = {

  }

  export type AssignmentClassUncheckedUpdateManyInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type TeacherNullableRelationFilter = {
    is?: TeacherWhereInput | null
    isNot?: TeacherWhereInput | null
  }

  export type ParentNullableRelationFilter = {
    is?: ParentWhereInput | null
    isNot?: ParentWhereInput | null
  }

  export type AdminNullableRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    avatar?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    dateOfBirth?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    emailVerifiedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ClassNullableRelationFilter = {
    is?: ClassWhereInput | null
    isNot?: ClassWhereInput | null
  }

  export type ParentListRelationFilter = {
    every?: ParentWhereInput
    some?: ParentWhereInput
    none?: ParentWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type AttendanceRecordListRelationFilter = {
    every?: AttendanceRecordWhereInput
    some?: AttendanceRecordWhereInput
    none?: AttendanceRecordWhereInput
  }

  export type AssignmentSubmissionListRelationFilter = {
    every?: AssignmentSubmissionWhereInput
    some?: AssignmentSubmissionWhereInput
    none?: AssignmentSubmissionWhereInput
  }

  export type StudentAchievementListRelationFilter = {
    every?: StudentAchievementWhereInput
    some?: StudentAchievementWhereInput
    none?: StudentAchievementWhereInput
  }

  export type BehaviorRecordListRelationFilter = {
    every?: BehaviorRecordWhereInput
    some?: BehaviorRecordWhereInput
    none?: BehaviorRecordWhereInput
  }

  export type FinancialRecordListRelationFilter = {
    every?: FinancialRecordWhereInput
    some?: FinancialRecordWhereInput
    none?: FinancialRecordWhereInput
  }

  export type ReportCardListRelationFilter = {
    every?: ReportCardWhereInput
    some?: ReportCardWhereInput
    none?: ReportCardWhereInput
  }

  export type ParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BehaviorRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    parentIds?: SortOrder
    admissionDate?: SortOrder
    academicYear?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    emergencyMedicalContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    admissionDate?: SortOrder
    academicYear?: SortOrder
    emergencyMedicalContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    userId?: SortOrder
    classId?: SortOrder
    admissionDate?: SortOrder
    academicYear?: SortOrder
    emergencyMedicalContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherSubjectListRelationFilter = {
    every?: TeacherSubjectWhereInput
    some?: TeacherSubjectWhereInput
    none?: TeacherSubjectWhereInput
  }

  export type TeacherClassListRelationFilter = {
    every?: TeacherClassWhereInput
    some?: TeacherClassWhereInput
    none?: TeacherClassWhereInput
  }

  export type AssignmentListRelationFilter = {
    every?: AssignmentWhereInput
    some?: AssignmentWhereInput
    none?: AssignmentWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type VirtualClassListRelationFilter = {
    every?: VirtualClassWhereInput
    some?: VirtualClassWhereInput
    none?: VirtualClassWhereInput
  }

  export type LearningResourceListRelationFilter = {
    every?: LearningResourceWhereInput
    some?: LearningResourceWhereInput
    none?: LearningResourceWhereInput
  }

  export type TeacherSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VirtualClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningResourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    qualifications?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    hireDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodFilter<$PrismaModel> | $Enums.ContactMethod
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type AdmissionApplicationListRelationFilter = {
    every?: AdmissionApplicationWhereInput
    some?: AdmissionApplicationWhereInput
    none?: AdmissionApplicationWhereInput
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    preferredContactMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    preferredContactMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    preferredContactMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContactMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodWithAggregatesFilter<$PrismaModel> | $Enums.ContactMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactMethodFilter<$PrismaModel>
    _max?: NestedEnumContactMethodFilter<$PrismaModel>
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClassSubjectListRelationFilter = {
    every?: ClassSubjectWhereInput
    some?: ClassSubjectWhereInput
    none?: ClassSubjectWhereInput
  }

  export type AssignmentClassListRelationFilter = {
    every?: AssignmentClassWhereInput
    some?: AssignmentClassWhereInput
    none?: AssignmentClassWhereInput
  }

  export type VirtualClassParticipantListRelationFilter = {
    every?: VirtualClassParticipantWhereInput
    some?: VirtualClassParticipantWhereInput
    none?: VirtualClassParticipantWhereInput
  }

  export type ClassSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VirtualClassParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    academicYear?: SortOrder
    room?: SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassAvgOrderByAggregateInput = {
    maxStudents?: SortOrder
  }

  export type ClassMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    academicYear?: SortOrder
    room?: SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    academicYear?: SortOrder
    room?: SortOrder
    maxStudents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClassSumOrderByAggregateInput = {
    maxStudents?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    department?: SortOrder
    credits?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    department?: SortOrder
    credits?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    department?: SortOrder
    credits?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    credits?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumGradeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeFilter<$PrismaModel> | $Enums.GradeType
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type SubjectRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type TeacherRelationFilter = {
    is?: TeacherWhereInput
    isNot?: TeacherWhereInput
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    type?: SortOrder
    comment?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    value?: SortOrder
    maxValue?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    type?: SortOrder
    comment?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    subjectId?: SortOrder
    teacherId?: SortOrder
    value?: SortOrder
    maxValue?: SortOrder
    type?: SortOrder
    comment?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    value?: SortOrder
    maxValue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumGradeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GradeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGradeTypeFilter<$PrismaModel>
    _max?: NestedEnumGradeTypeFilter<$PrismaModel>
  }

  export type EnumAssignmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentType | EnumAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTypeFilter<$PrismaModel> | $Enums.AssignmentType
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumSubmissionFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionFormat | EnumSubmissionFormatFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionFormatFilter<$PrismaModel> | $Enums.SubmissionFormat
  }

  export type FileAttachmentListRelationFilter = {
    every?: FileAttachmentWhereInput
    some?: FileAttachmentWhereInput
    none?: FileAttachmentWhereInput
  }

  export type FileAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    maxGrade?: SortOrder
    dueDate?: SortOrder
    submissionFormat?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentAvgOrderByAggregateInput = {
    maxGrade?: SortOrder
  }

  export type AssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    maxGrade?: SortOrder
    dueDate?: SortOrder
    submissionFormat?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    instructions?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    maxGrade?: SortOrder
    dueDate?: SortOrder
    submissionFormat?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSumOrderByAggregateInput = {
    maxGrade?: SortOrder
  }

  export type EnumAssignmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentType | EnumAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAssignmentTypeFilter<$PrismaModel>
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumSubmissionFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionFormat | EnumSubmissionFormatFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionFormatWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionFormatFilter<$PrismaModel>
    _max?: NestedEnumSubmissionFormatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type AssignmentRelationFilter = {
    is?: AssignmentWhereInput
    isNot?: AssignmentWhereInput
  }

  export type AssignmentSubmissionAssignmentIdStudentIdCompoundUniqueInput = {
    assignmentId: string
    studentId: string
  }

  export type AssignmentSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrder
    submittedAt?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSubmissionAvgOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type AssignmentSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrder
    submittedAt?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    assignmentId?: SortOrder
    studentId?: SortOrder
    content?: SortOrder
    submittedAt?: SortOrder
    grade?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AssignmentSubmissionSumOrderByAggregateInput = {
    grade?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    period?: SortOrder
    reason?: SortOrder
    notifiedParents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    period?: SortOrder
    reason?: SortOrder
    notifiedParents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AttendanceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    period?: SortOrder
    reason?: SortOrder
    notifiedParents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type ClassRelationFilter = {
    is?: ClassWhereInput
    isNot?: ClassWhereInput
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    room?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    duration?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    room?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    classId?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    room?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    duration?: SortOrder
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type MessageNullableRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    recipientIds?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    parentMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    parentMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    senderId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    read?: SortOrder
    parentMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumFinancialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialType | EnumFinancialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialTypeFilter<$PrismaModel> | $Enums.FinancialType
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type FinancialRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialRecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FinancialRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    dueDate?: SortOrder
    paidDate?: SortOrder
    status?: SortOrder
    description?: SortOrder
    paymentMethod?: SortOrder
    invoiceNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FinancialRecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumFinancialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialType | EnumFinancialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialTypeFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumAdmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusFilter<$PrismaModel> | $Enums.AdmissionStatus
  }

  export type AdmissionStepProgressListRelationFilter = {
    every?: AdmissionStepProgressWhereInput
    some?: AdmissionStepProgressWhereInput
    none?: AdmissionStepProgressWhereInput
  }

  export type AdmissionStepProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    applicationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    previousSchool?: SortOrder
    desiredClass?: SortOrder
    academicYear?: SortOrder
    specialNeeds?: SortOrder
    parentId?: SortOrder
    fatherName?: SortOrder
    fatherEmail?: SortOrder
    fatherPhone?: SortOrder
    fatherOccupation?: SortOrder
    motherName?: SortOrder
    motherEmail?: SortOrder
    motherPhone?: SortOrder
    motherOccupation?: SortOrder
    guardianName?: SortOrder
    guardianEmail?: SortOrder
    guardianPhone?: SortOrder
    familyAddress?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    previousSchool?: SortOrder
    desiredClass?: SortOrder
    academicYear?: SortOrder
    specialNeeds?: SortOrder
    parentId?: SortOrder
    fatherName?: SortOrder
    fatherEmail?: SortOrder
    fatherPhone?: SortOrder
    fatherOccupation?: SortOrder
    motherName?: SortOrder
    motherEmail?: SortOrder
    motherPhone?: SortOrder
    motherOccupation?: SortOrder
    guardianName?: SortOrder
    guardianEmail?: SortOrder
    guardianPhone?: SortOrder
    familyAddress?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    applicationNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    nationality?: SortOrder
    previousSchool?: SortOrder
    desiredClass?: SortOrder
    academicYear?: SortOrder
    specialNeeds?: SortOrder
    parentId?: SortOrder
    fatherName?: SortOrder
    fatherEmail?: SortOrder
    fatherPhone?: SortOrder
    fatherOccupation?: SortOrder
    motherName?: SortOrder
    motherEmail?: SortOrder
    motherPhone?: SortOrder
    motherOccupation?: SortOrder
    guardianName?: SortOrder
    guardianEmail?: SortOrder
    guardianPhone?: SortOrder
    familyAddress?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedAt?: SortOrder
    reviewedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumAdmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumAdmissionStatusFilter<$PrismaModel>
  }

  export type EnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type AdmissionApplicationRelationFilter = {
    is?: AdmissionApplicationWhereInput
    isNot?: AdmissionApplicationWhereInput
  }

  export type AdmissionStepProgressApplicationIdStepNameCompoundUniqueInput = {
    applicationId: string
    stepName: string
  }

  export type AdmissionStepProgressCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    stepName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    assignedTo?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionStepProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    stepName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    assignedTo?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdmissionStepProgressMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    stepName?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    assignedTo?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type EnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type LearningResourceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subjectId?: SortOrder
    level?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    duration?: SortOrder
    tags?: SortOrder
    createdById?: SortOrder
    accessLevel?: SortOrder
    downloadable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningResourceAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type LearningResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subjectId?: SortOrder
    level?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    duration?: SortOrder
    createdById?: SortOrder
    accessLevel?: SortOrder
    downloadable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningResourceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subjectId?: SortOrder
    level?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    duration?: SortOrder
    createdById?: SortOrder
    accessLevel?: SortOrder
    downloadable?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LearningResourceSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type EnumVirtualClassStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VirtualClassStatus | EnumVirtualClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirtualClassStatusFilter<$PrismaModel> | $Enums.VirtualClassStatus
  }

  export type VirtualClassCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    meetingUrl?: SortOrder
    recordingUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VirtualClassMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    meetingUrl?: SortOrder
    recordingUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VirtualClassMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    teacherId?: SortOrder
    subjectId?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    meetingUrl?: SortOrder
    recordingUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVirtualClassStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VirtualClassStatus | EnumVirtualClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirtualClassStatusWithAggregatesFilter<$PrismaModel> | $Enums.VirtualClassStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVirtualClassStatusFilter<$PrismaModel>
    _max?: NestedEnumVirtualClassStatusFilter<$PrismaModel>
  }

  export type VirtualClassRelationFilter = {
    is?: VirtualClassWhereInput
    isNot?: VirtualClassWhereInput
  }

  export type VirtualClassParticipantVirtualClassIdClassIdCompoundUniqueInput = {
    virtualClassId: string
    classId: string
  }

  export type VirtualClassParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    virtualClassId?: SortOrder
    classId?: SortOrder
  }

  export type VirtualClassParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    virtualClassId?: SortOrder
    classId?: SortOrder
  }

  export type VirtualClassParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    virtualClassId?: SortOrder
    classId?: SortOrder
  }

  export type EnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type EnumRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.Rarity | EnumRarityFieldRefInput<$PrismaModel>
    in?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumRarityFilter<$PrismaModel> | $Enums.Rarity
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    criteria?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    points?: SortOrder
    rarity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type EnumRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rarity | EnumRarityFieldRefInput<$PrismaModel>
    in?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumRarityWithAggregatesFilter<$PrismaModel> | $Enums.Rarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRarityFilter<$PrismaModel>
    _max?: NestedEnumRarityFilter<$PrismaModel>
  }

  export type AchievementRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type StudentAchievementStudentIdAchievementIdCompoundUniqueInput = {
    studentId: string
    achievementId: string
  }

  export type StudentAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
    awardedBy?: SortOrder
    evidence?: SortOrder
  }

  export type StudentAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
    awardedBy?: SortOrder
    evidence?: SortOrder
  }

  export type StudentAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    achievementId?: SortOrder
    earnedDate?: SortOrder
    awardedBy?: SortOrder
    evidence?: SortOrder
  }

  export type EnumBehaviorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeFilter<$PrismaModel> | $Enums.BehaviorType
  }

  export type EnumBehaviorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorCategory | EnumBehaviorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorCategoryFilter<$PrismaModel> | $Enums.BehaviorCategory
  }

  export type EnumSeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableFilter<$PrismaModel> | $Enums.Severity | null
  }

  export type BehaviorRecordCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    actionTaken?: SortOrder
    parentNotified?: SortOrder
    followUpRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BehaviorRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    actionTaken?: SortOrder
    parentNotified?: SortOrder
    followUpRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BehaviorRecordMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    date?: SortOrder
    type?: SortOrder
    category?: SortOrder
    description?: SortOrder
    severity?: SortOrder
    actionTaken?: SortOrder
    parentNotified?: SortOrder
    followUpRequired?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBehaviorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorTypeFilter<$PrismaModel>
    _max?: NestedEnumBehaviorTypeFilter<$PrismaModel>
  }

  export type EnumBehaviorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorCategory | EnumBehaviorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorCategoryFilter<$PrismaModel>
    _max?: NestedEnumBehaviorCategoryFilter<$PrismaModel>
  }

  export type EnumSeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Severity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumSeverityNullableFilter<$PrismaModel>
  }

  export type EnumBehaviorGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorGrade | EnumBehaviorGradeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorGradeFilter<$PrismaModel> | $Enums.BehaviorGrade
  }

  export type ReportCardStudentIdAcademicYearSemesterCompoundUniqueInput = {
    studentId: string
    academicYear: string
    semester: string
  }

  export type ReportCardCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    overallAverage?: SortOrder
    rank?: SortOrder
    totalStudents?: SortOrder
    behaviorGrade?: SortOrder
    totalDays?: SortOrder
    presentDays?: SortOrder
    absentDays?: SortOrder
    lateCount?: SortOrder
    principalComment?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardAvgOrderByAggregateInput = {
    overallAverage?: SortOrder
    rank?: SortOrder
    totalStudents?: SortOrder
    totalDays?: SortOrder
    presentDays?: SortOrder
    absentDays?: SortOrder
    lateCount?: SortOrder
  }

  export type ReportCardMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    overallAverage?: SortOrder
    rank?: SortOrder
    totalStudents?: SortOrder
    behaviorGrade?: SortOrder
    totalDays?: SortOrder
    presentDays?: SortOrder
    absentDays?: SortOrder
    lateCount?: SortOrder
    principalComment?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    academicYear?: SortOrder
    semester?: SortOrder
    overallAverage?: SortOrder
    rank?: SortOrder
    totalStudents?: SortOrder
    behaviorGrade?: SortOrder
    totalDays?: SortOrder
    presentDays?: SortOrder
    absentDays?: SortOrder
    lateCount?: SortOrder
    principalComment?: SortOrder
    generatedAt?: SortOrder
    generatedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportCardSumOrderByAggregateInput = {
    overallAverage?: SortOrder
    rank?: SortOrder
    totalStudents?: SortOrder
    totalDays?: SortOrder
    presentDays?: SortOrder
    absentDays?: SortOrder
    lateCount?: SortOrder
  }

  export type EnumBehaviorGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorGrade | EnumBehaviorGradeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorGradeWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorGradeFilter<$PrismaModel>
    _max?: NestedEnumBehaviorGradeFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryFilter<$PrismaModel> | $Enums.NotificationCategory
  }

  export type EnumNotificationChannelNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel> | null
    has?: $Enums.NotificationChannel | EnumNotificationChannelFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    hasSome?: $Enums.NotificationChannel[] | ListEnumNotificationChannelFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    read?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrder
    scheduledFor?: SortOrder
    channels?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    read?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    category?: SortOrder
    read?: SortOrder
    actionRequired?: SortOrder
    actionUrl?: SortOrder
    scheduledFor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationCategoryFilter<$PrismaModel>
  }

  export type AssignmentNullableRelationFilter = {
    is?: AssignmentWhereInput | null
    isNot?: AssignmentWhereInput | null
  }

  export type AssignmentSubmissionNullableRelationFilter = {
    is?: AssignmentSubmissionWhereInput | null
    isNot?: AssignmentSubmissionWhereInput | null
  }

  export type AdmissionApplicationNullableRelationFilter = {
    is?: AdmissionApplicationWhereInput | null
    isNot?: AdmissionApplicationWhereInput | null
  }

  export type FileAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    assignmentId?: SortOrder
    submissionId?: SortOrder
    messageId?: SortOrder
    admissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAttachmentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    assignmentId?: SortOrder
    submissionId?: SortOrder
    messageId?: SortOrder
    admissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    type?: SortOrder
    size?: SortOrder
    uploadedBy?: SortOrder
    assignmentId?: SortOrder
    submissionId?: SortOrder
    messageId?: SortOrder
    admissionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAttachmentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeacherSubjectTeacherIdSubjectIdCompoundUniqueInput = {
    teacherId: string
    subjectId: string
  }

  export type TeacherSubjectCountOrderByAggregateInput = {
    teacherId?: SortOrder
    subjectId?: SortOrder
  }

  export type TeacherSubjectMaxOrderByAggregateInput = {
    teacherId?: SortOrder
    subjectId?: SortOrder
  }

  export type TeacherSubjectMinOrderByAggregateInput = {
    teacherId?: SortOrder
    subjectId?: SortOrder
  }

  export type TeacherClassTeacherIdClassIdCompoundUniqueInput = {
    teacherId: string
    classId: string
  }

  export type TeacherClassCountOrderByAggregateInput = {
    teacherId?: SortOrder
    classId?: SortOrder
    isMainTeacher?: SortOrder
  }

  export type TeacherClassMaxOrderByAggregateInput = {
    teacherId?: SortOrder
    classId?: SortOrder
    isMainTeacher?: SortOrder
  }

  export type TeacherClassMinOrderByAggregateInput = {
    teacherId?: SortOrder
    classId?: SortOrder
    isMainTeacher?: SortOrder
  }

  export type ClassSubjectClassIdSubjectIdCompoundUniqueInput = {
    classId: string
    subjectId: string
  }

  export type ClassSubjectCountOrderByAggregateInput = {
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type ClassSubjectMaxOrderByAggregateInput = {
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type ClassSubjectMinOrderByAggregateInput = {
    classId?: SortOrder
    subjectId?: SortOrder
  }

  export type AssignmentClassAssignmentIdClassIdCompoundUniqueInput = {
    assignmentId: string
    classId: string
  }

  export type AssignmentClassCountOrderByAggregateInput = {
    assignmentId?: SortOrder
    classId?: SortOrder
  }

  export type AssignmentClassMaxOrderByAggregateInput = {
    assignmentId?: SortOrder
    classId?: SortOrder
  }

  export type AssignmentClassMinOrderByAggregateInput = {
    assignmentId?: SortOrder
    classId?: SortOrder
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutRecipientsInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput> | MessageCreateWithoutRecipientsInput[] | MessageUncheckedCreateWithoutRecipientsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput | MessageCreateOrConnectWithoutRecipientsInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    connect?: TeacherWhereUniqueInput
  }

  export type ParentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutRecipientsInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput> | MessageCreateWithoutRecipientsInput[] | MessageUncheckedCreateWithoutRecipientsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput | MessageCreateOrConnectWithoutRecipientsInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutRecipientsNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput> | MessageCreateWithoutRecipientsInput[] | MessageUncheckedCreateWithoutRecipientsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput | MessageCreateOrConnectWithoutRecipientsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientsInput | MessageUpsertWithWhereUniqueWithoutRecipientsInput[]
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientsInput | MessageUpdateWithWhereUniqueWithoutRecipientsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientsInput | MessageUpdateManyWithWhereWithoutRecipientsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutUserInput
    upsert?: TeacherUpsertWithoutUserInput
    disconnect?: TeacherWhereInput | boolean
    delete?: TeacherWhereInput | boolean
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutUserInput, TeacherUpdateWithoutUserInput>, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type ParentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutRecipientsNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput> | MessageCreateWithoutRecipientsInput[] | MessageUncheckedCreateWithoutRecipientsInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput | MessageCreateOrConnectWithoutRecipientsInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutRecipientsInput | MessageUpsertWithWhereUniqueWithoutRecipientsInput[]
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutRecipientsInput | MessageUpdateWithWhereUniqueWithoutRecipientsInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutRecipientsInput | MessageUpdateManyWithWhereWithoutRecipientsInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type StudentCreateparentIdsInput = {
    set: string[]
  }

  export type StudentCreateallergiesInput = {
    set: string[]
  }

  export type StudentCreatemedicationsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutStudentsInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    connect?: ClassWhereUniqueInput
  }

  export type ParentCreateNestedManyWithoutChildrenInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput> | ParentCreateWithoutChildrenInput[] | ParentUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput | ParentCreateOrConnectWithoutChildrenInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type StudentAchievementCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAchievementCreateWithoutStudentInput, StudentAchievementUncheckedCreateWithoutStudentInput> | StudentAchievementCreateWithoutStudentInput[] | StudentAchievementUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutStudentInput | StudentAchievementCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAchievementCreateManyStudentInputEnvelope
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
  }

  export type BehaviorRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
  }

  export type FinancialRecordCreateNestedManyWithoutStudentInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type ReportCardCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type ParentUncheckedCreateNestedManyWithoutChildrenInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput> | ParentCreateWithoutChildrenInput[] | ParentUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput | ParentCreateOrConnectWithoutChildrenInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type StudentAchievementUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentAchievementCreateWithoutStudentInput, StudentAchievementUncheckedCreateWithoutStudentInput> | StudentAchievementCreateWithoutStudentInput[] | StudentAchievementUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutStudentInput | StudentAchievementCreateOrConnectWithoutStudentInput[]
    createMany?: StudentAchievementCreateManyStudentInputEnvelope
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
  }

  export type BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
  }

  export type FinancialRecordUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
  }

  export type ReportCardUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
  }

  export type StudentUpdateparentIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StudentUpdateallergiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type StudentUpdatemedicationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type ClassUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutStudentsInput
    upsert?: ClassUpsertWithoutStudentsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutStudentsInput, ClassUpdateWithoutStudentsInput>, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ParentUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput> | ParentCreateWithoutChildrenInput[] | ParentUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput | ParentCreateOrConnectWithoutChildrenInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutChildrenInput | ParentUpsertWithWhereUniqueWithoutChildrenInput[]
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutChildrenInput | ParentUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutChildrenInput | ParentUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentInput | GradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentInput | GradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentInput | GradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput | AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type StudentAchievementUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAchievementCreateWithoutStudentInput, StudentAchievementUncheckedCreateWithoutStudentInput> | StudentAchievementCreateWithoutStudentInput[] | StudentAchievementUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutStudentInput | StudentAchievementCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAchievementUpsertWithWhereUniqueWithoutStudentInput | StudentAchievementUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAchievementCreateManyStudentInputEnvelope
    set?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    disconnect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    delete?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    update?: StudentAchievementUpdateWithWhereUniqueWithoutStudentInput | StudentAchievementUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAchievementUpdateManyWithWhereWithoutStudentInput | StudentAchievementUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAchievementScalarWhereInput | StudentAchievementScalarWhereInput[]
  }

  export type BehaviorRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    upsert?: BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput | BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    set?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    disconnect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    delete?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    update?: BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput | BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BehaviorRecordUpdateManyWithWhereWithoutStudentInput | BehaviorRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
  }

  export type FinancialRecordUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutStudentInput | FinancialRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutStudentInput | FinancialRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutStudentInput | FinancialRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type ReportCardUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type ParentUncheckedUpdateManyWithoutChildrenNestedInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput> | ParentCreateWithoutChildrenInput[] | ParentUncheckedCreateWithoutChildrenInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput | ParentCreateOrConnectWithoutChildrenInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutChildrenInput | ParentUpsertWithWhereUniqueWithoutChildrenInput[]
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutChildrenInput | ParentUpdateWithWhereUniqueWithoutChildrenInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutChildrenInput | ParentUpdateManyWithWhereWithoutChildrenInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput> | GradeCreateWithoutStudentInput[] | GradeUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutStudentInput | GradeCreateOrConnectWithoutStudentInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutStudentInput | GradeUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: GradeCreateManyStudentInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutStudentInput | GradeUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutStudentInput | GradeUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput> | AttendanceRecordCreateWithoutStudentInput[] | AttendanceRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutStudentInput | AttendanceRecordCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput | AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceRecordCreateManyStudentInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput | AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutStudentInput | AttendanceRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput> | AssignmentSubmissionCreateWithoutStudentInput[] | AssignmentSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutStudentInput | AssignmentSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AssignmentSubmissionCreateManyStudentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput | AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentAchievementCreateWithoutStudentInput, StudentAchievementUncheckedCreateWithoutStudentInput> | StudentAchievementCreateWithoutStudentInput[] | StudentAchievementUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutStudentInput | StudentAchievementCreateOrConnectWithoutStudentInput[]
    upsert?: StudentAchievementUpsertWithWhereUniqueWithoutStudentInput | StudentAchievementUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentAchievementCreateManyStudentInputEnvelope
    set?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    disconnect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    delete?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    update?: StudentAchievementUpdateWithWhereUniqueWithoutStudentInput | StudentAchievementUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentAchievementUpdateManyWithWhereWithoutStudentInput | StudentAchievementUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentAchievementScalarWhereInput | StudentAchievementScalarWhereInput[]
  }

  export type BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput> | BehaviorRecordCreateWithoutStudentInput[] | BehaviorRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutStudentInput | BehaviorRecordCreateOrConnectWithoutStudentInput[]
    upsert?: BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput | BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: BehaviorRecordCreateManyStudentInputEnvelope
    set?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    disconnect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    delete?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    update?: BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput | BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: BehaviorRecordUpdateManyWithWhereWithoutStudentInput | BehaviorRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
  }

  export type FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput> | FinancialRecordCreateWithoutStudentInput[] | FinancialRecordUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: FinancialRecordCreateOrConnectWithoutStudentInput | FinancialRecordCreateOrConnectWithoutStudentInput[]
    upsert?: FinancialRecordUpsertWithWhereUniqueWithoutStudentInput | FinancialRecordUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: FinancialRecordCreateManyStudentInputEnvelope
    set?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    disconnect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    delete?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    connect?: FinancialRecordWhereUniqueInput | FinancialRecordWhereUniqueInput[]
    update?: FinancialRecordUpdateWithWhereUniqueWithoutStudentInput | FinancialRecordUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: FinancialRecordUpdateManyWithWhereWithoutStudentInput | FinancialRecordUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput> | ReportCardCreateWithoutStudentInput[] | ReportCardUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ReportCardCreateOrConnectWithoutStudentInput | ReportCardCreateOrConnectWithoutStudentInput[]
    upsert?: ReportCardUpsertWithWhereUniqueWithoutStudentInput | ReportCardUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ReportCardCreateManyStudentInputEnvelope
    set?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    disconnect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    delete?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    connect?: ReportCardWhereUniqueInput | ReportCardWhereUniqueInput[]
    update?: ReportCardUpdateWithWhereUniqueWithoutStudentInput | ReportCardUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ReportCardUpdateManyWithWhereWithoutStudentInput | ReportCardUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
  }

  export type TeacherCreatequalificationsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutTeacherInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    connect?: UserWhereUniqueInput
  }

  export type TeacherSubjectCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type TeacherClassCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutTeacherInput = {
    create?: XOR<GradeCreateWithoutTeacherInput, GradeUncheckedCreateWithoutTeacherInput> | GradeCreateWithoutTeacherInput[] | GradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTeacherInput | GradeCreateOrConnectWithoutTeacherInput[]
    createMany?: GradeCreateManyTeacherInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AttendanceRecordCreateWithoutTeacherInput, AttendanceRecordUncheckedCreateWithoutTeacherInput> | AttendanceRecordCreateWithoutTeacherInput[] | AttendanceRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutTeacherInput | AttendanceRecordCreateOrConnectWithoutTeacherInput[]
    createMany?: AttendanceRecordCreateManyTeacherInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ScheduleCreateWithoutTeacherInput, ScheduleUncheckedCreateWithoutTeacherInput> | ScheduleCreateWithoutTeacherInput[] | ScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTeacherInput | ScheduleCreateOrConnectWithoutTeacherInput[]
    createMany?: ScheduleCreateManyTeacherInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type VirtualClassCreateNestedManyWithoutTeacherInput = {
    create?: XOR<VirtualClassCreateWithoutTeacherInput, VirtualClassUncheckedCreateWithoutTeacherInput> | VirtualClassCreateWithoutTeacherInput[] | VirtualClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutTeacherInput | VirtualClassCreateOrConnectWithoutTeacherInput[]
    createMany?: VirtualClassCreateManyTeacherInputEnvelope
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
  }

  export type LearningResourceCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LearningResourceCreateWithoutCreatedByInput, LearningResourceUncheckedCreateWithoutCreatedByInput> | LearningResourceCreateWithoutCreatedByInput[] | LearningResourceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutCreatedByInput | LearningResourceCreateOrConnectWithoutCreatedByInput[]
    createMany?: LearningResourceCreateManyCreatedByInputEnvelope
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
  }

  export type BehaviorRecordCreateNestedManyWithoutTeacherInput = {
    create?: XOR<BehaviorRecordCreateWithoutTeacherInput, BehaviorRecordUncheckedCreateWithoutTeacherInput> | BehaviorRecordCreateWithoutTeacherInput[] | BehaviorRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutTeacherInput | BehaviorRecordCreateOrConnectWithoutTeacherInput[]
    createMany?: BehaviorRecordCreateManyTeacherInputEnvelope
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type TeacherClassUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<GradeCreateWithoutTeacherInput, GradeUncheckedCreateWithoutTeacherInput> | GradeCreateWithoutTeacherInput[] | GradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTeacherInput | GradeCreateOrConnectWithoutTeacherInput[]
    createMany?: GradeCreateManyTeacherInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<AttendanceRecordCreateWithoutTeacherInput, AttendanceRecordUncheckedCreateWithoutTeacherInput> | AttendanceRecordCreateWithoutTeacherInput[] | AttendanceRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutTeacherInput | AttendanceRecordCreateOrConnectWithoutTeacherInput[]
    createMany?: AttendanceRecordCreateManyTeacherInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ScheduleCreateWithoutTeacherInput, ScheduleUncheckedCreateWithoutTeacherInput> | ScheduleCreateWithoutTeacherInput[] | ScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTeacherInput | ScheduleCreateOrConnectWithoutTeacherInput[]
    createMany?: ScheduleCreateManyTeacherInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type VirtualClassUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<VirtualClassCreateWithoutTeacherInput, VirtualClassUncheckedCreateWithoutTeacherInput> | VirtualClassCreateWithoutTeacherInput[] | VirtualClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutTeacherInput | VirtualClassCreateOrConnectWithoutTeacherInput[]
    createMany?: VirtualClassCreateManyTeacherInputEnvelope
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
  }

  export type LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LearningResourceCreateWithoutCreatedByInput, LearningResourceUncheckedCreateWithoutCreatedByInput> | LearningResourceCreateWithoutCreatedByInput[] | LearningResourceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutCreatedByInput | LearningResourceCreateOrConnectWithoutCreatedByInput[]
    createMany?: LearningResourceCreateManyCreatedByInputEnvelope
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
  }

  export type BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<BehaviorRecordCreateWithoutTeacherInput, BehaviorRecordUncheckedCreateWithoutTeacherInput> | BehaviorRecordCreateWithoutTeacherInput[] | BehaviorRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutTeacherInput | BehaviorRecordCreateOrConnectWithoutTeacherInput[]
    createMany?: BehaviorRecordCreateManyTeacherInputEnvelope
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
  }

  export type TeacherUpdatequalificationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutTeacherNestedInput = {
    create?: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherInput
    upsert?: UserUpsertWithoutTeacherInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherInput, UserUpdateWithoutTeacherInput>, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type TeacherClassUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherClassUpsertWithWhereUniqueWithoutTeacherInput | TeacherClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    set?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    disconnect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    delete?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    update?: TeacherClassUpdateWithWhereUniqueWithoutTeacherInput | TeacherClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherClassUpdateManyWithWhereWithoutTeacherInput | TeacherClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<GradeCreateWithoutTeacherInput, GradeUncheckedCreateWithoutTeacherInput> | GradeCreateWithoutTeacherInput[] | GradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTeacherInput | GradeCreateOrConnectWithoutTeacherInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutTeacherInput | GradeUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: GradeCreateManyTeacherInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutTeacherInput | GradeUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutTeacherInput | GradeUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutTeacherInput | AssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutTeacherInput | AssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutTeacherInput | AssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutTeacherInput, AttendanceRecordUncheckedCreateWithoutTeacherInput> | AttendanceRecordCreateWithoutTeacherInput[] | AttendanceRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutTeacherInput | AttendanceRecordCreateOrConnectWithoutTeacherInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutTeacherInput | AttendanceRecordUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AttendanceRecordCreateManyTeacherInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutTeacherInput | AttendanceRecordUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutTeacherInput | AttendanceRecordUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ScheduleCreateWithoutTeacherInput, ScheduleUncheckedCreateWithoutTeacherInput> | ScheduleCreateWithoutTeacherInput[] | ScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTeacherInput | ScheduleCreateOrConnectWithoutTeacherInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutTeacherInput | ScheduleUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ScheduleCreateManyTeacherInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutTeacherInput | ScheduleUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutTeacherInput | ScheduleUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type VirtualClassUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<VirtualClassCreateWithoutTeacherInput, VirtualClassUncheckedCreateWithoutTeacherInput> | VirtualClassCreateWithoutTeacherInput[] | VirtualClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutTeacherInput | VirtualClassCreateOrConnectWithoutTeacherInput[]
    upsert?: VirtualClassUpsertWithWhereUniqueWithoutTeacherInput | VirtualClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: VirtualClassCreateManyTeacherInputEnvelope
    set?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    disconnect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    delete?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    update?: VirtualClassUpdateWithWhereUniqueWithoutTeacherInput | VirtualClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: VirtualClassUpdateManyWithWhereWithoutTeacherInput | VirtualClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: VirtualClassScalarWhereInput | VirtualClassScalarWhereInput[]
  }

  export type LearningResourceUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LearningResourceCreateWithoutCreatedByInput, LearningResourceUncheckedCreateWithoutCreatedByInput> | LearningResourceCreateWithoutCreatedByInput[] | LearningResourceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutCreatedByInput | LearningResourceCreateOrConnectWithoutCreatedByInput[]
    upsert?: LearningResourceUpsertWithWhereUniqueWithoutCreatedByInput | LearningResourceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LearningResourceCreateManyCreatedByInputEnvelope
    set?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    disconnect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    delete?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    update?: LearningResourceUpdateWithWhereUniqueWithoutCreatedByInput | LearningResourceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LearningResourceUpdateManyWithWhereWithoutCreatedByInput | LearningResourceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LearningResourceScalarWhereInput | LearningResourceScalarWhereInput[]
  }

  export type BehaviorRecordUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<BehaviorRecordCreateWithoutTeacherInput, BehaviorRecordUncheckedCreateWithoutTeacherInput> | BehaviorRecordCreateWithoutTeacherInput[] | BehaviorRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutTeacherInput | BehaviorRecordCreateOrConnectWithoutTeacherInput[]
    upsert?: BehaviorRecordUpsertWithWhereUniqueWithoutTeacherInput | BehaviorRecordUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: BehaviorRecordCreateManyTeacherInputEnvelope
    set?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    disconnect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    delete?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    update?: BehaviorRecordUpdateWithWhereUniqueWithoutTeacherInput | BehaviorRecordUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: BehaviorRecordUpdateManyWithWhereWithoutTeacherInput | BehaviorRecordUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput> | TeacherSubjectCreateWithoutTeacherInput[] | TeacherSubjectUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutTeacherInput | TeacherSubjectCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherSubjectCreateManyTeacherInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput | TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutTeacherInput | TeacherSubjectUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput> | TeacherClassCreateWithoutTeacherInput[] | TeacherClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutTeacherInput | TeacherClassCreateOrConnectWithoutTeacherInput[]
    upsert?: TeacherClassUpsertWithWhereUniqueWithoutTeacherInput | TeacherClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: TeacherClassCreateManyTeacherInputEnvelope
    set?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    disconnect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    delete?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    update?: TeacherClassUpdateWithWhereUniqueWithoutTeacherInput | TeacherClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: TeacherClassUpdateManyWithWhereWithoutTeacherInput | TeacherClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<GradeCreateWithoutTeacherInput, GradeUncheckedCreateWithoutTeacherInput> | GradeCreateWithoutTeacherInput[] | GradeUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTeacherInput | GradeCreateOrConnectWithoutTeacherInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutTeacherInput | GradeUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: GradeCreateManyTeacherInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutTeacherInput | GradeUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutTeacherInput | GradeUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput> | AssignmentCreateWithoutTeacherInput[] | AssignmentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutTeacherInput | AssignmentCreateOrConnectWithoutTeacherInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutTeacherInput | AssignmentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AssignmentCreateManyTeacherInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutTeacherInput | AssignmentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutTeacherInput | AssignmentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutTeacherInput, AttendanceRecordUncheckedCreateWithoutTeacherInput> | AttendanceRecordCreateWithoutTeacherInput[] | AttendanceRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutTeacherInput | AttendanceRecordCreateOrConnectWithoutTeacherInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutTeacherInput | AttendanceRecordUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: AttendanceRecordCreateManyTeacherInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutTeacherInput | AttendanceRecordUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutTeacherInput | AttendanceRecordUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ScheduleCreateWithoutTeacherInput, ScheduleUncheckedCreateWithoutTeacherInput> | ScheduleCreateWithoutTeacherInput[] | ScheduleUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTeacherInput | ScheduleCreateOrConnectWithoutTeacherInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutTeacherInput | ScheduleUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ScheduleCreateManyTeacherInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutTeacherInput | ScheduleUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutTeacherInput | ScheduleUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<VirtualClassCreateWithoutTeacherInput, VirtualClassUncheckedCreateWithoutTeacherInput> | VirtualClassCreateWithoutTeacherInput[] | VirtualClassUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutTeacherInput | VirtualClassCreateOrConnectWithoutTeacherInput[]
    upsert?: VirtualClassUpsertWithWhereUniqueWithoutTeacherInput | VirtualClassUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: VirtualClassCreateManyTeacherInputEnvelope
    set?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    disconnect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    delete?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    update?: VirtualClassUpdateWithWhereUniqueWithoutTeacherInput | VirtualClassUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: VirtualClassUpdateManyWithWhereWithoutTeacherInput | VirtualClassUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: VirtualClassScalarWhereInput | VirtualClassScalarWhereInput[]
  }

  export type LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LearningResourceCreateWithoutCreatedByInput, LearningResourceUncheckedCreateWithoutCreatedByInput> | LearningResourceCreateWithoutCreatedByInput[] | LearningResourceUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutCreatedByInput | LearningResourceCreateOrConnectWithoutCreatedByInput[]
    upsert?: LearningResourceUpsertWithWhereUniqueWithoutCreatedByInput | LearningResourceUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LearningResourceCreateManyCreatedByInputEnvelope
    set?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    disconnect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    delete?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    update?: LearningResourceUpdateWithWhereUniqueWithoutCreatedByInput | LearningResourceUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LearningResourceUpdateManyWithWhereWithoutCreatedByInput | LearningResourceUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LearningResourceScalarWhereInput | LearningResourceScalarWhereInput[]
  }

  export type BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<BehaviorRecordCreateWithoutTeacherInput, BehaviorRecordUncheckedCreateWithoutTeacherInput> | BehaviorRecordCreateWithoutTeacherInput[] | BehaviorRecordUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: BehaviorRecordCreateOrConnectWithoutTeacherInput | BehaviorRecordCreateOrConnectWithoutTeacherInput[]
    upsert?: BehaviorRecordUpsertWithWhereUniqueWithoutTeacherInput | BehaviorRecordUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: BehaviorRecordCreateManyTeacherInputEnvelope
    set?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    disconnect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    delete?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    connect?: BehaviorRecordWhereUniqueInput | BehaviorRecordWhereUniqueInput[]
    update?: BehaviorRecordUpdateWithWhereUniqueWithoutTeacherInput | BehaviorRecordUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: BehaviorRecordUpdateManyWithWhereWithoutTeacherInput | BehaviorRecordUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParentInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    connect?: UserWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput> | StudentCreateWithoutParentsInput[] | StudentUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput | StudentCreateOrConnectWithoutParentsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AdmissionApplicationCreateNestedManyWithoutParentInput = {
    create?: XOR<AdmissionApplicationCreateWithoutParentInput, AdmissionApplicationUncheckedCreateWithoutParentInput> | AdmissionApplicationCreateWithoutParentInput[] | AdmissionApplicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutParentInput | AdmissionApplicationCreateOrConnectWithoutParentInput[]
    createMany?: AdmissionApplicationCreateManyParentInputEnvelope
    connect?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput> | StudentCreateWithoutParentsInput[] | StudentUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput | StudentCreateOrConnectWithoutParentsInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type AdmissionApplicationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AdmissionApplicationCreateWithoutParentInput, AdmissionApplicationUncheckedCreateWithoutParentInput> | AdmissionApplicationCreateWithoutParentInput[] | AdmissionApplicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutParentInput | AdmissionApplicationCreateOrConnectWithoutParentInput[]
    createMany?: AdmissionApplicationCreateManyParentInputEnvelope
    connect?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
  }

  export type EnumContactMethodFieldUpdateOperationsInput = {
    set?: $Enums.ContactMethod
  }

  export type UserUpdateOneRequiredWithoutParentNestedInput = {
    create?: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    connectOrCreate?: UserCreateOrConnectWithoutParentInput
    upsert?: UserUpsertWithoutParentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParentInput, UserUpdateWithoutParentInput>, UserUncheckedUpdateWithoutParentInput>
  }

  export type StudentUpdateManyWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput> | StudentCreateWithoutParentsInput[] | StudentUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput | StudentCreateOrConnectWithoutParentsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutParentsInput | StudentUpsertWithWhereUniqueWithoutParentsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutParentsInput | StudentUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutParentsInput | StudentUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AdmissionApplicationUpdateManyWithoutParentNestedInput = {
    create?: XOR<AdmissionApplicationCreateWithoutParentInput, AdmissionApplicationUncheckedCreateWithoutParentInput> | AdmissionApplicationCreateWithoutParentInput[] | AdmissionApplicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutParentInput | AdmissionApplicationCreateOrConnectWithoutParentInput[]
    upsert?: AdmissionApplicationUpsertWithWhereUniqueWithoutParentInput | AdmissionApplicationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AdmissionApplicationCreateManyParentInputEnvelope
    set?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    disconnect?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    delete?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    connect?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    update?: AdmissionApplicationUpdateWithWhereUniqueWithoutParentInput | AdmissionApplicationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AdmissionApplicationUpdateManyWithWhereWithoutParentInput | AdmissionApplicationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AdmissionApplicationScalarWhereInput | AdmissionApplicationScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput> | StudentCreateWithoutParentsInput[] | StudentUncheckedCreateWithoutParentsInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput | StudentCreateOrConnectWithoutParentsInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutParentsInput | StudentUpsertWithWhereUniqueWithoutParentsInput[]
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutParentsInput | StudentUpdateWithWhereUniqueWithoutParentsInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutParentsInput | StudentUpdateManyWithWhereWithoutParentsInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type AdmissionApplicationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AdmissionApplicationCreateWithoutParentInput, AdmissionApplicationUncheckedCreateWithoutParentInput> | AdmissionApplicationCreateWithoutParentInput[] | AdmissionApplicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutParentInput | AdmissionApplicationCreateOrConnectWithoutParentInput[]
    upsert?: AdmissionApplicationUpsertWithWhereUniqueWithoutParentInput | AdmissionApplicationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AdmissionApplicationCreateManyParentInputEnvelope
    set?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    disconnect?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    delete?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    connect?: AdmissionApplicationWhereUniqueInput | AdmissionApplicationWhereUniqueInput[]
    update?: AdmissionApplicationUpdateWithWhereUniqueWithoutParentInput | AdmissionApplicationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AdmissionApplicationUpdateManyWithWhereWithoutParentInput | AdmissionApplicationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AdmissionApplicationScalarWhereInput | AdmissionApplicationScalarWhereInput[]
  }

  export type AdminCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAdminInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    connect?: UserWhereUniqueInput
  }

  export type AdminUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAdminNestedInput = {
    create?: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminInput
    upsert?: UserUpsertWithoutAdminInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminInput, UserUpdateWithoutAdminInput>, UserUncheckedUpdateWithoutAdminInput>
  }

  export type StudentCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherClassCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherClassCreateWithoutClassInput, TeacherClassUncheckedCreateWithoutClassInput> | TeacherClassCreateWithoutClassInput[] | TeacherClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutClassInput | TeacherClassCreateOrConnectWithoutClassInput[]
    createMany?: TeacherClassCreateManyClassInputEnvelope
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
  }

  export type ClassSubjectCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutClassInput = {
    create?: XOR<ScheduleCreateWithoutClassInput, ScheduleUncheckedCreateWithoutClassInput> | ScheduleCreateWithoutClassInput[] | ScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClassInput | ScheduleCreateOrConnectWithoutClassInput[]
    createMany?: ScheduleCreateManyClassInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type AssignmentClassCreateNestedManyWithoutClassInput = {
    create?: XOR<AssignmentClassCreateWithoutClassInput, AssignmentClassUncheckedCreateWithoutClassInput> | AssignmentClassCreateWithoutClassInput[] | AssignmentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutClassInput | AssignmentClassCreateOrConnectWithoutClassInput[]
    createMany?: AssignmentClassCreateManyClassInputEnvelope
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
  }

  export type AttendanceRecordCreateNestedManyWithoutClassInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type VirtualClassParticipantCreateNestedManyWithoutClassInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutClassInput, VirtualClassParticipantUncheckedCreateWithoutClassInput> | VirtualClassParticipantCreateWithoutClassInput[] | VirtualClassParticipantUncheckedCreateWithoutClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutClassInput | VirtualClassParticipantCreateOrConnectWithoutClassInput[]
    createMany?: VirtualClassParticipantCreateManyClassInputEnvelope
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type TeacherClassUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<TeacherClassCreateWithoutClassInput, TeacherClassUncheckedCreateWithoutClassInput> | TeacherClassCreateWithoutClassInput[] | TeacherClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutClassInput | TeacherClassCreateOrConnectWithoutClassInput[]
    createMany?: TeacherClassCreateManyClassInputEnvelope
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
  }

  export type ClassSubjectUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<ScheduleCreateWithoutClassInput, ScheduleUncheckedCreateWithoutClassInput> | ScheduleCreateWithoutClassInput[] | ScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClassInput | ScheduleCreateOrConnectWithoutClassInput[]
    createMany?: ScheduleCreateManyClassInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type AssignmentClassUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<AssignmentClassCreateWithoutClassInput, AssignmentClassUncheckedCreateWithoutClassInput> | AssignmentClassCreateWithoutClassInput[] | AssignmentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutClassInput | AssignmentClassCreateOrConnectWithoutClassInput[]
    createMany?: AssignmentClassCreateManyClassInputEnvelope
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
  }

  export type AttendanceRecordUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
  }

  export type VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutClassInput, VirtualClassParticipantUncheckedCreateWithoutClassInput> | VirtualClassParticipantCreateWithoutClassInput[] | VirtualClassParticipantUncheckedCreateWithoutClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutClassInput | VirtualClassParticipantCreateOrConnectWithoutClassInput[]
    createMany?: VirtualClassParticipantCreateManyClassInputEnvelope
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherClassUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherClassCreateWithoutClassInput, TeacherClassUncheckedCreateWithoutClassInput> | TeacherClassCreateWithoutClassInput[] | TeacherClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutClassInput | TeacherClassCreateOrConnectWithoutClassInput[]
    upsert?: TeacherClassUpsertWithWhereUniqueWithoutClassInput | TeacherClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherClassCreateManyClassInputEnvelope
    set?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    disconnect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    delete?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    update?: TeacherClassUpdateWithWhereUniqueWithoutClassInput | TeacherClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherClassUpdateManyWithWhereWithoutClassInput | TeacherClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
  }

  export type ClassSubjectUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutClassInput | ClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutClassInput | ClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutClassInput | ClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutClassNestedInput = {
    create?: XOR<ScheduleCreateWithoutClassInput, ScheduleUncheckedCreateWithoutClassInput> | ScheduleCreateWithoutClassInput[] | ScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClassInput | ScheduleCreateOrConnectWithoutClassInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutClassInput | ScheduleUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ScheduleCreateManyClassInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutClassInput | ScheduleUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutClassInput | ScheduleUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type AssignmentClassUpdateManyWithoutClassNestedInput = {
    create?: XOR<AssignmentClassCreateWithoutClassInput, AssignmentClassUncheckedCreateWithoutClassInput> | AssignmentClassCreateWithoutClassInput[] | AssignmentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutClassInput | AssignmentClassCreateOrConnectWithoutClassInput[]
    upsert?: AssignmentClassUpsertWithWhereUniqueWithoutClassInput | AssignmentClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AssignmentClassCreateManyClassInputEnvelope
    set?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    disconnect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    delete?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    update?: AssignmentClassUpdateWithWhereUniqueWithoutClassInput | AssignmentClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AssignmentClassUpdateManyWithWhereWithoutClassInput | AssignmentClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AssignmentClassScalarWhereInput | AssignmentClassScalarWhereInput[]
  }

  export type AttendanceRecordUpdateManyWithoutClassNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutClassInput | AttendanceRecordUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutClassInput | AttendanceRecordUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutClassInput | AttendanceRecordUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type VirtualClassParticipantUpdateManyWithoutClassNestedInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutClassInput, VirtualClassParticipantUncheckedCreateWithoutClassInput> | VirtualClassParticipantCreateWithoutClassInput[] | VirtualClassParticipantUncheckedCreateWithoutClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutClassInput | VirtualClassParticipantCreateOrConnectWithoutClassInput[]
    upsert?: VirtualClassParticipantUpsertWithWhereUniqueWithoutClassInput | VirtualClassParticipantUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: VirtualClassParticipantCreateManyClassInputEnvelope
    set?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    disconnect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    delete?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    update?: VirtualClassParticipantUpdateWithWhereUniqueWithoutClassInput | VirtualClassParticipantUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: VirtualClassParticipantUpdateManyWithWhereWithoutClassInput | VirtualClassParticipantUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: VirtualClassParticipantScalarWhereInput | VirtualClassParticipantScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput> | StudentCreateWithoutClassInput[] | StudentUncheckedCreateWithoutClassInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutClassInput | StudentCreateOrConnectWithoutClassInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutClassInput | StudentUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: StudentCreateManyClassInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutClassInput | StudentUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutClassInput | StudentUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type TeacherClassUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<TeacherClassCreateWithoutClassInput, TeacherClassUncheckedCreateWithoutClassInput> | TeacherClassCreateWithoutClassInput[] | TeacherClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: TeacherClassCreateOrConnectWithoutClassInput | TeacherClassCreateOrConnectWithoutClassInput[]
    upsert?: TeacherClassUpsertWithWhereUniqueWithoutClassInput | TeacherClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: TeacherClassCreateManyClassInputEnvelope
    set?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    disconnect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    delete?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    connect?: TeacherClassWhereUniqueInput | TeacherClassWhereUniqueInput[]
    update?: TeacherClassUpdateWithWhereUniqueWithoutClassInput | TeacherClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: TeacherClassUpdateManyWithWhereWithoutClassInput | TeacherClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
  }

  export type ClassSubjectUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput> | ClassSubjectCreateWithoutClassInput[] | ClassSubjectUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutClassInput | ClassSubjectCreateOrConnectWithoutClassInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutClassInput | ClassSubjectUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ClassSubjectCreateManyClassInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutClassInput | ClassSubjectUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutClassInput | ClassSubjectUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<ScheduleCreateWithoutClassInput, ScheduleUncheckedCreateWithoutClassInput> | ScheduleCreateWithoutClassInput[] | ScheduleUncheckedCreateWithoutClassInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClassInput | ScheduleCreateOrConnectWithoutClassInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutClassInput | ScheduleUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: ScheduleCreateManyClassInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutClassInput | ScheduleUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutClassInput | ScheduleUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type AssignmentClassUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<AssignmentClassCreateWithoutClassInput, AssignmentClassUncheckedCreateWithoutClassInput> | AssignmentClassCreateWithoutClassInput[] | AssignmentClassUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutClassInput | AssignmentClassCreateOrConnectWithoutClassInput[]
    upsert?: AssignmentClassUpsertWithWhereUniqueWithoutClassInput | AssignmentClassUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AssignmentClassCreateManyClassInputEnvelope
    set?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    disconnect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    delete?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    update?: AssignmentClassUpdateWithWhereUniqueWithoutClassInput | AssignmentClassUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AssignmentClassUpdateManyWithWhereWithoutClassInput | AssignmentClassUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AssignmentClassScalarWhereInput | AssignmentClassScalarWhereInput[]
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput> | AttendanceRecordCreateWithoutClassInput[] | AttendanceRecordUncheckedCreateWithoutClassInput[]
    connectOrCreate?: AttendanceRecordCreateOrConnectWithoutClassInput | AttendanceRecordCreateOrConnectWithoutClassInput[]
    upsert?: AttendanceRecordUpsertWithWhereUniqueWithoutClassInput | AttendanceRecordUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: AttendanceRecordCreateManyClassInputEnvelope
    set?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    disconnect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    delete?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    connect?: AttendanceRecordWhereUniqueInput | AttendanceRecordWhereUniqueInput[]
    update?: AttendanceRecordUpdateWithWhereUniqueWithoutClassInput | AttendanceRecordUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: AttendanceRecordUpdateManyWithWhereWithoutClassInput | AttendanceRecordUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
  }

  export type VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutClassInput, VirtualClassParticipantUncheckedCreateWithoutClassInput> | VirtualClassParticipantCreateWithoutClassInput[] | VirtualClassParticipantUncheckedCreateWithoutClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutClassInput | VirtualClassParticipantCreateOrConnectWithoutClassInput[]
    upsert?: VirtualClassParticipantUpsertWithWhereUniqueWithoutClassInput | VirtualClassParticipantUpsertWithWhereUniqueWithoutClassInput[]
    createMany?: VirtualClassParticipantCreateManyClassInputEnvelope
    set?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    disconnect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    delete?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    update?: VirtualClassParticipantUpdateWithWhereUniqueWithoutClassInput | VirtualClassParticipantUpdateWithWhereUniqueWithoutClassInput[]
    updateMany?: VirtualClassParticipantUpdateManyWithWhereWithoutClassInput | VirtualClassParticipantUpdateManyWithWhereWithoutClassInput[]
    deleteMany?: VirtualClassParticipantScalarWhereInput | VirtualClassParticipantScalarWhereInput[]
  }

  export type TeacherSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type ClassSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutSubjectInput = {
    create?: XOR<GradeCreateWithoutSubjectInput, GradeUncheckedCreateWithoutSubjectInput> | GradeCreateWithoutSubjectInput[] | GradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectInput | GradeCreateOrConnectWithoutSubjectInput[]
    createMany?: GradeCreateManySubjectInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AssignmentCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ScheduleCreateWithoutSubjectInput, ScheduleUncheckedCreateWithoutSubjectInput> | ScheduleCreateWithoutSubjectInput[] | ScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutSubjectInput | ScheduleCreateOrConnectWithoutSubjectInput[]
    createMany?: ScheduleCreateManySubjectInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type LearningResourceCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LearningResourceCreateWithoutSubjectInput, LearningResourceUncheckedCreateWithoutSubjectInput> | LearningResourceCreateWithoutSubjectInput[] | LearningResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutSubjectInput | LearningResourceCreateOrConnectWithoutSubjectInput[]
    createMany?: LearningResourceCreateManySubjectInputEnvelope
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
  }

  export type VirtualClassCreateNestedManyWithoutSubjectInput = {
    create?: XOR<VirtualClassCreateWithoutSubjectInput, VirtualClassUncheckedCreateWithoutSubjectInput> | VirtualClassCreateWithoutSubjectInput[] | VirtualClassUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutSubjectInput | VirtualClassCreateOrConnectWithoutSubjectInput[]
    createMany?: VirtualClassCreateManySubjectInputEnvelope
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
  }

  export type TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
  }

  export type ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<GradeCreateWithoutSubjectInput, GradeUncheckedCreateWithoutSubjectInput> | GradeCreateWithoutSubjectInput[] | GradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectInput | GradeCreateOrConnectWithoutSubjectInput[]
    createMany?: GradeCreateManySubjectInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type AssignmentUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ScheduleCreateWithoutSubjectInput, ScheduleUncheckedCreateWithoutSubjectInput> | ScheduleCreateWithoutSubjectInput[] | ScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutSubjectInput | ScheduleCreateOrConnectWithoutSubjectInput[]
    createMany?: ScheduleCreateManySubjectInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type LearningResourceUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<LearningResourceCreateWithoutSubjectInput, LearningResourceUncheckedCreateWithoutSubjectInput> | LearningResourceCreateWithoutSubjectInput[] | LearningResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutSubjectInput | LearningResourceCreateOrConnectWithoutSubjectInput[]
    createMany?: LearningResourceCreateManySubjectInputEnvelope
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
  }

  export type VirtualClassUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<VirtualClassCreateWithoutSubjectInput, VirtualClassUncheckedCreateWithoutSubjectInput> | VirtualClassCreateWithoutSubjectInput[] | VirtualClassUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutSubjectInput | VirtualClassCreateOrConnectWithoutSubjectInput[]
    createMany?: VirtualClassCreateManySubjectInputEnvelope
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
  }

  export type TeacherSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type ClassSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutSubjectInput | ClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<GradeCreateWithoutSubjectInput, GradeUncheckedCreateWithoutSubjectInput> | GradeCreateWithoutSubjectInput[] | GradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectInput | GradeCreateOrConnectWithoutSubjectInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutSubjectInput | GradeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: GradeCreateManySubjectInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutSubjectInput | GradeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutSubjectInput | GradeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AssignmentUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutSubjectInput | AssignmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutSubjectInput | AssignmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutSubjectInput | AssignmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ScheduleCreateWithoutSubjectInput, ScheduleUncheckedCreateWithoutSubjectInput> | ScheduleCreateWithoutSubjectInput[] | ScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutSubjectInput | ScheduleCreateOrConnectWithoutSubjectInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutSubjectInput | ScheduleUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ScheduleCreateManySubjectInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutSubjectInput | ScheduleUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutSubjectInput | ScheduleUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type LearningResourceUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LearningResourceCreateWithoutSubjectInput, LearningResourceUncheckedCreateWithoutSubjectInput> | LearningResourceCreateWithoutSubjectInput[] | LearningResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutSubjectInput | LearningResourceCreateOrConnectWithoutSubjectInput[]
    upsert?: LearningResourceUpsertWithWhereUniqueWithoutSubjectInput | LearningResourceUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LearningResourceCreateManySubjectInputEnvelope
    set?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    disconnect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    delete?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    update?: LearningResourceUpdateWithWhereUniqueWithoutSubjectInput | LearningResourceUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LearningResourceUpdateManyWithWhereWithoutSubjectInput | LearningResourceUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LearningResourceScalarWhereInput | LearningResourceScalarWhereInput[]
  }

  export type VirtualClassUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<VirtualClassCreateWithoutSubjectInput, VirtualClassUncheckedCreateWithoutSubjectInput> | VirtualClassCreateWithoutSubjectInput[] | VirtualClassUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutSubjectInput | VirtualClassCreateOrConnectWithoutSubjectInput[]
    upsert?: VirtualClassUpsertWithWhereUniqueWithoutSubjectInput | VirtualClassUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: VirtualClassCreateManySubjectInputEnvelope
    set?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    disconnect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    delete?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    update?: VirtualClassUpdateWithWhereUniqueWithoutSubjectInput | VirtualClassUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: VirtualClassUpdateManyWithWhereWithoutSubjectInput | VirtualClassUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: VirtualClassScalarWhereInput | VirtualClassScalarWhereInput[]
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput> | TeacherSubjectCreateWithoutSubjectInput[] | TeacherSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: TeacherSubjectCreateOrConnectWithoutSubjectInput | TeacherSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: TeacherSubjectCreateManySubjectInputEnvelope
    set?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    disconnect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    delete?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    connect?: TeacherSubjectWhereUniqueInput | TeacherSubjectWhereUniqueInput[]
    update?: TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput | TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: TeacherSubjectUpdateManyWithWhereWithoutSubjectInput | TeacherSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
  }

  export type ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput> | ClassSubjectCreateWithoutSubjectInput[] | ClassSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ClassSubjectCreateOrConnectWithoutSubjectInput | ClassSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput | ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ClassSubjectCreateManySubjectInputEnvelope
    set?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    disconnect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    delete?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    connect?: ClassSubjectWhereUniqueInput | ClassSubjectWhereUniqueInput[]
    update?: ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput | ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ClassSubjectUpdateManyWithWhereWithoutSubjectInput | ClassSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<GradeCreateWithoutSubjectInput, GradeUncheckedCreateWithoutSubjectInput> | GradeCreateWithoutSubjectInput[] | GradeUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSubjectInput | GradeCreateOrConnectWithoutSubjectInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutSubjectInput | GradeUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: GradeCreateManySubjectInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutSubjectInput | GradeUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutSubjectInput | GradeUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type AssignmentUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput> | AssignmentCreateWithoutSubjectInput[] | AssignmentUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubjectInput | AssignmentCreateOrConnectWithoutSubjectInput[]
    upsert?: AssignmentUpsertWithWhereUniqueWithoutSubjectInput | AssignmentUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: AssignmentCreateManySubjectInputEnvelope
    set?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    disconnect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    delete?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    connect?: AssignmentWhereUniqueInput | AssignmentWhereUniqueInput[]
    update?: AssignmentUpdateWithWhereUniqueWithoutSubjectInput | AssignmentUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: AssignmentUpdateManyWithWhereWithoutSubjectInput | AssignmentUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ScheduleCreateWithoutSubjectInput, ScheduleUncheckedCreateWithoutSubjectInput> | ScheduleCreateWithoutSubjectInput[] | ScheduleUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutSubjectInput | ScheduleCreateOrConnectWithoutSubjectInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutSubjectInput | ScheduleUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ScheduleCreateManySubjectInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutSubjectInput | ScheduleUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutSubjectInput | ScheduleUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<LearningResourceCreateWithoutSubjectInput, LearningResourceUncheckedCreateWithoutSubjectInput> | LearningResourceCreateWithoutSubjectInput[] | LearningResourceUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: LearningResourceCreateOrConnectWithoutSubjectInput | LearningResourceCreateOrConnectWithoutSubjectInput[]
    upsert?: LearningResourceUpsertWithWhereUniqueWithoutSubjectInput | LearningResourceUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: LearningResourceCreateManySubjectInputEnvelope
    set?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    disconnect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    delete?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    connect?: LearningResourceWhereUniqueInput | LearningResourceWhereUniqueInput[]
    update?: LearningResourceUpdateWithWhereUniqueWithoutSubjectInput | LearningResourceUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: LearningResourceUpdateManyWithWhereWithoutSubjectInput | LearningResourceUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: LearningResourceScalarWhereInput | LearningResourceScalarWhereInput[]
  }

  export type VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<VirtualClassCreateWithoutSubjectInput, VirtualClassUncheckedCreateWithoutSubjectInput> | VirtualClassCreateWithoutSubjectInput[] | VirtualClassUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: VirtualClassCreateOrConnectWithoutSubjectInput | VirtualClassCreateOrConnectWithoutSubjectInput[]
    upsert?: VirtualClassUpsertWithWhereUniqueWithoutSubjectInput | VirtualClassUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: VirtualClassCreateManySubjectInputEnvelope
    set?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    disconnect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    delete?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    connect?: VirtualClassWhereUniqueInput | VirtualClassWhereUniqueInput[]
    update?: VirtualClassUpdateWithWhereUniqueWithoutSubjectInput | VirtualClassUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: VirtualClassUpdateManyWithWhereWithoutSubjectInput | VirtualClassUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: VirtualClassScalarWhereInput | VirtualClassScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutGradesInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    connect?: StudentWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutGradesInput = {
    create?: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradesInput
    connect?: SubjectWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutGradesInput = {
    create?: XOR<TeacherCreateWithoutGradesInput, TeacherUncheckedCreateWithoutGradesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutGradesInput
    connect?: TeacherWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGradeTypeFieldUpdateOperationsInput = {
    set?: $Enums.GradeType
  }

  export type StudentUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutGradesInput
    upsert?: StudentUpsertWithoutGradesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutGradesInput, StudentUpdateWithoutGradesInput>, StudentUncheckedUpdateWithoutGradesInput>
  }

  export type SubjectUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutGradesInput
    upsert?: SubjectUpsertWithoutGradesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutGradesInput, SubjectUpdateWithoutGradesInput>, SubjectUncheckedUpdateWithoutGradesInput>
  }

  export type TeacherUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<TeacherCreateWithoutGradesInput, TeacherUncheckedCreateWithoutGradesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutGradesInput
    upsert?: TeacherUpsertWithoutGradesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutGradesInput, TeacherUpdateWithoutGradesInput>, TeacherUncheckedUpdateWithoutGradesInput>
  }

  export type TeacherCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<TeacherCreateWithoutAssignmentsInput, TeacherUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAssignmentsInput
    connect?: TeacherWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAssignmentsInput
    connect?: SubjectWhereUniqueInput
  }

  export type AssignmentClassCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentClassCreateWithoutAssignmentInput, AssignmentClassUncheckedCreateWithoutAssignmentInput> | AssignmentClassCreateWithoutAssignmentInput[] | AssignmentClassUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutAssignmentInput | AssignmentClassCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentClassCreateManyAssignmentInputEnvelope
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
  }

  export type AssignmentSubmissionCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type FileAttachmentCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<FileAttachmentCreateWithoutAssignmentInput, FileAttachmentUncheckedCreateWithoutAssignmentInput> | FileAttachmentCreateWithoutAssignmentInput[] | FileAttachmentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAssignmentInput | FileAttachmentCreateOrConnectWithoutAssignmentInput[]
    createMany?: FileAttachmentCreateManyAssignmentInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type AssignmentClassUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentClassCreateWithoutAssignmentInput, AssignmentClassUncheckedCreateWithoutAssignmentInput> | AssignmentClassCreateWithoutAssignmentInput[] | AssignmentClassUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutAssignmentInput | AssignmentClassCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentClassCreateManyAssignmentInputEnvelope
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
  }

  export type AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
  }

  export type FileAttachmentUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<FileAttachmentCreateWithoutAssignmentInput, FileAttachmentUncheckedCreateWithoutAssignmentInput> | FileAttachmentCreateWithoutAssignmentInput[] | FileAttachmentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAssignmentInput | FileAttachmentCreateOrConnectWithoutAssignmentInput[]
    createMany?: FileAttachmentCreateManyAssignmentInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type EnumAssignmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AssignmentType
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumSubmissionFormatFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionFormat
  }

  export type TeacherUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<TeacherCreateWithoutAssignmentsInput, TeacherUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAssignmentsInput
    upsert?: TeacherUpsertWithoutAssignmentsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutAssignmentsInput, TeacherUpdateWithoutAssignmentsInput>, TeacherUncheckedUpdateWithoutAssignmentsInput>
  }

  export type SubjectUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutAssignmentsInput
    upsert?: SubjectUpsertWithoutAssignmentsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutAssignmentsInput, SubjectUpdateWithoutAssignmentsInput>, SubjectUncheckedUpdateWithoutAssignmentsInput>
  }

  export type AssignmentClassUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentClassCreateWithoutAssignmentInput, AssignmentClassUncheckedCreateWithoutAssignmentInput> | AssignmentClassCreateWithoutAssignmentInput[] | AssignmentClassUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutAssignmentInput | AssignmentClassCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentClassUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentClassUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentClassCreateManyAssignmentInputEnvelope
    set?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    disconnect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    delete?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    update?: AssignmentClassUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentClassUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentClassUpdateManyWithWhereWithoutAssignmentInput | AssignmentClassUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentClassScalarWhereInput | AssignmentClassScalarWhereInput[]
  }

  export type AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type FileAttachmentUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutAssignmentInput, FileAttachmentUncheckedCreateWithoutAssignmentInput> | FileAttachmentCreateWithoutAssignmentInput[] | FileAttachmentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAssignmentInput | FileAttachmentCreateOrConnectWithoutAssignmentInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutAssignmentInput | FileAttachmentUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: FileAttachmentCreateManyAssignmentInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutAssignmentInput | FileAttachmentUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutAssignmentInput | FileAttachmentUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type AssignmentClassUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentClassCreateWithoutAssignmentInput, AssignmentClassUncheckedCreateWithoutAssignmentInput> | AssignmentClassCreateWithoutAssignmentInput[] | AssignmentClassUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentClassCreateOrConnectWithoutAssignmentInput | AssignmentClassCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentClassUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentClassUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentClassCreateManyAssignmentInputEnvelope
    set?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    disconnect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    delete?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    connect?: AssignmentClassWhereUniqueInput | AssignmentClassWhereUniqueInput[]
    update?: AssignmentClassUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentClassUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentClassUpdateManyWithWhereWithoutAssignmentInput | AssignmentClassUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentClassScalarWhereInput | AssignmentClassScalarWhereInput[]
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput> | AssignmentSubmissionCreateWithoutAssignmentInput[] | AssignmentSubmissionUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAssignmentInput | AssignmentSubmissionCreateOrConnectWithoutAssignmentInput[]
    upsert?: AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: AssignmentSubmissionCreateManyAssignmentInputEnvelope
    set?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    disconnect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    delete?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    connect?: AssignmentSubmissionWhereUniqueInput | AssignmentSubmissionWhereUniqueInput[]
    update?: AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput | AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput | AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
  }

  export type FileAttachmentUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutAssignmentInput, FileAttachmentUncheckedCreateWithoutAssignmentInput> | FileAttachmentCreateWithoutAssignmentInput[] | FileAttachmentUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAssignmentInput | FileAttachmentCreateOrConnectWithoutAssignmentInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutAssignmentInput | FileAttachmentUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: FileAttachmentCreateManyAssignmentInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutAssignmentInput | FileAttachmentUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutAssignmentInput | FileAttachmentUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type AssignmentCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<StudentCreateWithoutAssignmentsInput, StudentUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAssignmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type FileAttachmentCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<FileAttachmentCreateWithoutSubmissionInput, FileAttachmentUncheckedCreateWithoutSubmissionInput> | FileAttachmentCreateWithoutSubmissionInput[] | FileAttachmentUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutSubmissionInput | FileAttachmentCreateOrConnectWithoutSubmissionInput[]
    createMany?: FileAttachmentCreateManySubmissionInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type FileAttachmentUncheckedCreateNestedManyWithoutSubmissionInput = {
    create?: XOR<FileAttachmentCreateWithoutSubmissionInput, FileAttachmentUncheckedCreateWithoutSubmissionInput> | FileAttachmentCreateWithoutSubmissionInput[] | FileAttachmentUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutSubmissionInput | FileAttachmentCreateOrConnectWithoutSubmissionInput[]
    createMany?: FileAttachmentCreateManySubmissionInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSubmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubmissionStatus
  }

  export type AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutSubmissionsInput
    upsert?: AssignmentUpsertWithoutSubmissionsInput
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutSubmissionsInput, AssignmentUpdateWithoutSubmissionsInput>, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type StudentUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<StudentCreateWithoutAssignmentsInput, StudentUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAssignmentsInput
    upsert?: StudentUpsertWithoutAssignmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAssignmentsInput, StudentUpdateWithoutAssignmentsInput>, StudentUncheckedUpdateWithoutAssignmentsInput>
  }

  export type FileAttachmentUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutSubmissionInput, FileAttachmentUncheckedCreateWithoutSubmissionInput> | FileAttachmentCreateWithoutSubmissionInput[] | FileAttachmentUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutSubmissionInput | FileAttachmentCreateOrConnectWithoutSubmissionInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutSubmissionInput | FileAttachmentUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: FileAttachmentCreateManySubmissionInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutSubmissionInput | FileAttachmentUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutSubmissionInput | FileAttachmentUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type FileAttachmentUncheckedUpdateManyWithoutSubmissionNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutSubmissionInput, FileAttachmentUncheckedCreateWithoutSubmissionInput> | FileAttachmentCreateWithoutSubmissionInput[] | FileAttachmentUncheckedCreateWithoutSubmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutSubmissionInput | FileAttachmentCreateOrConnectWithoutSubmissionInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutSubmissionInput | FileAttachmentUpsertWithWhereUniqueWithoutSubmissionInput[]
    createMany?: FileAttachmentCreateManySubmissionInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutSubmissionInput | FileAttachmentUpdateWithWhereUniqueWithoutSubmissionInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutSubmissionInput | FileAttachmentUpdateManyWithWhereWithoutSubmissionInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttendanceRecordsInput
    connect?: ClassWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutAttendanceRecordsInput = {
    create?: XOR<TeacherCreateWithoutAttendanceRecordsInput, TeacherUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAttendanceRecordsInput
    connect?: TeacherWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type StudentUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: StudentUpsertWithoutAttendanceRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAttendanceRecordsInput, StudentUpdateWithoutAttendanceRecordsInput>, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type ClassUpdateOneWithoutAttendanceRecordsNestedInput = {
    create?: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: ClassUpsertWithoutAttendanceRecordsInput
    disconnect?: ClassWhereInput | boolean
    delete?: ClassWhereInput | boolean
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAttendanceRecordsInput, ClassUpdateWithoutAttendanceRecordsInput>, ClassUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type TeacherUpdateOneRequiredWithoutAttendanceRecordsNestedInput = {
    create?: XOR<TeacherCreateWithoutAttendanceRecordsInput, TeacherUncheckedCreateWithoutAttendanceRecordsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutAttendanceRecordsInput
    upsert?: TeacherUpsertWithoutAttendanceRecordsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutAttendanceRecordsInput, TeacherUpdateWithoutAttendanceRecordsInput>, TeacherUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type ClassCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<ClassCreateWithoutSchedulesInput, ClassUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSchedulesInput
    connect?: ClassWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<TeacherCreateWithoutSchedulesInput, TeacherUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSchedulesInput
    connect?: TeacherWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<SubjectCreateWithoutSchedulesInput, SubjectUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutSchedulesInput
    connect?: SubjectWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<ClassCreateWithoutSchedulesInput, ClassUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSchedulesInput
    upsert?: ClassUpsertWithoutSchedulesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSchedulesInput, ClassUpdateWithoutSchedulesInput>, ClassUncheckedUpdateWithoutSchedulesInput>
  }

  export type TeacherUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<TeacherCreateWithoutSchedulesInput, TeacherUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSchedulesInput
    upsert?: TeacherUpsertWithoutSchedulesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutSchedulesInput, TeacherUpdateWithoutSchedulesInput>, TeacherUncheckedUpdateWithoutSchedulesInput>
  }

  export type SubjectUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<SubjectCreateWithoutSchedulesInput, SubjectUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutSchedulesInput
    upsert?: SubjectUpsertWithoutSchedulesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutSchedulesInput, SubjectUpdateWithoutSchedulesInput>, SubjectUncheckedUpdateWithoutSchedulesInput>
  }

  export type MessageCreaterecipientIdsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput> | UserCreateWithoutReceivedMessagesInput[] | UserUncheckedCreateWithoutReceivedMessagesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput | UserCreateOrConnectWithoutReceivedMessagesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageCreateNestedOneWithoutRepliesInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutParentMessageInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FileAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<FileAttachmentCreateWithoutMessageInput, FileAttachmentUncheckedCreateWithoutMessageInput> | FileAttachmentCreateWithoutMessageInput[] | FileAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutMessageInput | FileAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: FileAttachmentCreateManyMessageInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput> | UserCreateWithoutReceivedMessagesInput[] | UserUncheckedCreateWithoutReceivedMessagesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput | UserCreateOrConnectWithoutReceivedMessagesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutParentMessageInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type FileAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<FileAttachmentCreateWithoutMessageInput, FileAttachmentUncheckedCreateWithoutMessageInput> | FileAttachmentCreateWithoutMessageInput[] | FileAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutMessageInput | FileAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: FileAttachmentCreateManyMessageInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type MessageUpdaterecipientIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateManyWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput> | UserCreateWithoutReceivedMessagesInput[] | UserUncheckedCreateWithoutReceivedMessagesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput | UserCreateOrConnectWithoutReceivedMessagesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReceivedMessagesInput | UserUpsertWithWhereUniqueWithoutReceivedMessagesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReceivedMessagesInput | UserUpdateWithWhereUniqueWithoutReceivedMessagesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReceivedMessagesInput | UserUpdateManyWithWhereWithoutReceivedMessagesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRepliesInput
    upsert?: MessageUpsertWithoutRepliesInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRepliesInput, MessageUpdateWithoutRepliesInput>, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateManyWithoutParentMessageNestedInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentMessageInput | MessageUpsertWithWhereUniqueWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentMessageInput | MessageUpdateWithWhereUniqueWithoutParentMessageInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentMessageInput | MessageUpdateManyWithWhereWithoutParentMessageInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FileAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutMessageInput, FileAttachmentUncheckedCreateWithoutMessageInput> | FileAttachmentCreateWithoutMessageInput[] | FileAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutMessageInput | FileAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutMessageInput | FileAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: FileAttachmentCreateManyMessageInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutMessageInput | FileAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutMessageInput | FileAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput> | UserCreateWithoutReceivedMessagesInput[] | UserUncheckedCreateWithoutReceivedMessagesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput | UserCreateOrConnectWithoutReceivedMessagesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutReceivedMessagesInput | UserUpsertWithWhereUniqueWithoutReceivedMessagesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutReceivedMessagesInput | UserUpdateWithWhereUniqueWithoutReceivedMessagesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutReceivedMessagesInput | UserUpdateManyWithWhereWithoutReceivedMessagesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutParentMessageNestedInput = {
    create?: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput> | MessageCreateWithoutParentMessageInput[] | MessageUncheckedCreateWithoutParentMessageInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutParentMessageInput | MessageCreateOrConnectWithoutParentMessageInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutParentMessageInput | MessageUpsertWithWhereUniqueWithoutParentMessageInput[]
    createMany?: MessageCreateManyParentMessageInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutParentMessageInput | MessageUpdateWithWhereUniqueWithoutParentMessageInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutParentMessageInput | MessageUpdateManyWithWhereWithoutParentMessageInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type FileAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutMessageInput, FileAttachmentUncheckedCreateWithoutMessageInput> | FileAttachmentCreateWithoutMessageInput[] | FileAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutMessageInput | FileAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutMessageInput | FileAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: FileAttachmentCreateManyMessageInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutMessageInput | FileAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutMessageInput | FileAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutFinancialRecordsInput = {
    create?: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFinancialRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumFinancialTypeFieldUpdateOperationsInput = {
    set?: $Enums.FinancialType
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type StudentUpdateOneRequiredWithoutFinancialRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutFinancialRecordsInput
    upsert?: StudentUpsertWithoutFinancialRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutFinancialRecordsInput, StudentUpdateWithoutFinancialRecordsInput>, StudentUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type ParentCreateNestedOneWithoutAdmissionApplicationsInput = {
    create?: XOR<ParentCreateWithoutAdmissionApplicationsInput, ParentUncheckedCreateWithoutAdmissionApplicationsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutAdmissionApplicationsInput
    connect?: ParentWhereUniqueInput
  }

  export type FileAttachmentCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<FileAttachmentCreateWithoutAdmissionInput, FileAttachmentUncheckedCreateWithoutAdmissionInput> | FileAttachmentCreateWithoutAdmissionInput[] | FileAttachmentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAdmissionInput | FileAttachmentCreateOrConnectWithoutAdmissionInput[]
    createMany?: FileAttachmentCreateManyAdmissionInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type AdmissionStepProgressCreateNestedManyWithoutApplicationInput = {
    create?: XOR<AdmissionStepProgressCreateWithoutApplicationInput, AdmissionStepProgressUncheckedCreateWithoutApplicationInput> | AdmissionStepProgressCreateWithoutApplicationInput[] | AdmissionStepProgressUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdmissionStepProgressCreateOrConnectWithoutApplicationInput | AdmissionStepProgressCreateOrConnectWithoutApplicationInput[]
    createMany?: AdmissionStepProgressCreateManyApplicationInputEnvelope
    connect?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
  }

  export type FileAttachmentUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<FileAttachmentCreateWithoutAdmissionInput, FileAttachmentUncheckedCreateWithoutAdmissionInput> | FileAttachmentCreateWithoutAdmissionInput[] | FileAttachmentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAdmissionInput | FileAttachmentCreateOrConnectWithoutAdmissionInput[]
    createMany?: FileAttachmentCreateManyAdmissionInputEnvelope
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
  }

  export type AdmissionStepProgressUncheckedCreateNestedManyWithoutApplicationInput = {
    create?: XOR<AdmissionStepProgressCreateWithoutApplicationInput, AdmissionStepProgressUncheckedCreateWithoutApplicationInput> | AdmissionStepProgressCreateWithoutApplicationInput[] | AdmissionStepProgressUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdmissionStepProgressCreateOrConnectWithoutApplicationInput | AdmissionStepProgressCreateOrConnectWithoutApplicationInput[]
    createMany?: AdmissionStepProgressCreateManyApplicationInputEnvelope
    connect?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumAdmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdmissionStatus
  }

  export type ParentUpdateOneWithoutAdmissionApplicationsNestedInput = {
    create?: XOR<ParentCreateWithoutAdmissionApplicationsInput, ParentUncheckedCreateWithoutAdmissionApplicationsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutAdmissionApplicationsInput
    upsert?: ParentUpsertWithoutAdmissionApplicationsInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutAdmissionApplicationsInput, ParentUpdateWithoutAdmissionApplicationsInput>, ParentUncheckedUpdateWithoutAdmissionApplicationsInput>
  }

  export type FileAttachmentUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutAdmissionInput, FileAttachmentUncheckedCreateWithoutAdmissionInput> | FileAttachmentCreateWithoutAdmissionInput[] | FileAttachmentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAdmissionInput | FileAttachmentCreateOrConnectWithoutAdmissionInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutAdmissionInput | FileAttachmentUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: FileAttachmentCreateManyAdmissionInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutAdmissionInput | FileAttachmentUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutAdmissionInput | FileAttachmentUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type AdmissionStepProgressUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<AdmissionStepProgressCreateWithoutApplicationInput, AdmissionStepProgressUncheckedCreateWithoutApplicationInput> | AdmissionStepProgressCreateWithoutApplicationInput[] | AdmissionStepProgressUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdmissionStepProgressCreateOrConnectWithoutApplicationInput | AdmissionStepProgressCreateOrConnectWithoutApplicationInput[]
    upsert?: AdmissionStepProgressUpsertWithWhereUniqueWithoutApplicationInput | AdmissionStepProgressUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: AdmissionStepProgressCreateManyApplicationInputEnvelope
    set?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    disconnect?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    delete?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    connect?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    update?: AdmissionStepProgressUpdateWithWhereUniqueWithoutApplicationInput | AdmissionStepProgressUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: AdmissionStepProgressUpdateManyWithWhereWithoutApplicationInput | AdmissionStepProgressUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: AdmissionStepProgressScalarWhereInput | AdmissionStepProgressScalarWhereInput[]
  }

  export type FileAttachmentUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<FileAttachmentCreateWithoutAdmissionInput, FileAttachmentUncheckedCreateWithoutAdmissionInput> | FileAttachmentCreateWithoutAdmissionInput[] | FileAttachmentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: FileAttachmentCreateOrConnectWithoutAdmissionInput | FileAttachmentCreateOrConnectWithoutAdmissionInput[]
    upsert?: FileAttachmentUpsertWithWhereUniqueWithoutAdmissionInput | FileAttachmentUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: FileAttachmentCreateManyAdmissionInputEnvelope
    set?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    disconnect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    delete?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    connect?: FileAttachmentWhereUniqueInput | FileAttachmentWhereUniqueInput[]
    update?: FileAttachmentUpdateWithWhereUniqueWithoutAdmissionInput | FileAttachmentUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: FileAttachmentUpdateManyWithWhereWithoutAdmissionInput | FileAttachmentUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
  }

  export type AdmissionStepProgressUncheckedUpdateManyWithoutApplicationNestedInput = {
    create?: XOR<AdmissionStepProgressCreateWithoutApplicationInput, AdmissionStepProgressUncheckedCreateWithoutApplicationInput> | AdmissionStepProgressCreateWithoutApplicationInput[] | AdmissionStepProgressUncheckedCreateWithoutApplicationInput[]
    connectOrCreate?: AdmissionStepProgressCreateOrConnectWithoutApplicationInput | AdmissionStepProgressCreateOrConnectWithoutApplicationInput[]
    upsert?: AdmissionStepProgressUpsertWithWhereUniqueWithoutApplicationInput | AdmissionStepProgressUpsertWithWhereUniqueWithoutApplicationInput[]
    createMany?: AdmissionStepProgressCreateManyApplicationInputEnvelope
    set?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    disconnect?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    delete?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    connect?: AdmissionStepProgressWhereUniqueInput | AdmissionStepProgressWhereUniqueInput[]
    update?: AdmissionStepProgressUpdateWithWhereUniqueWithoutApplicationInput | AdmissionStepProgressUpdateWithWhereUniqueWithoutApplicationInput[]
    updateMany?: AdmissionStepProgressUpdateManyWithWhereWithoutApplicationInput | AdmissionStepProgressUpdateManyWithWhereWithoutApplicationInput[]
    deleteMany?: AdmissionStepProgressScalarWhereInput | AdmissionStepProgressScalarWhereInput[]
  }

  export type AdmissionApplicationCreateNestedOneWithoutStepProgressInput = {
    create?: XOR<AdmissionApplicationCreateWithoutStepProgressInput, AdmissionApplicationUncheckedCreateWithoutStepProgressInput>
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutStepProgressInput
    connect?: AdmissionApplicationWhereUniqueInput
  }

  export type EnumStepStatusFieldUpdateOperationsInput = {
    set?: $Enums.StepStatus
  }

  export type AdmissionApplicationUpdateOneRequiredWithoutStepProgressNestedInput = {
    create?: XOR<AdmissionApplicationCreateWithoutStepProgressInput, AdmissionApplicationUncheckedCreateWithoutStepProgressInput>
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutStepProgressInput
    upsert?: AdmissionApplicationUpsertWithoutStepProgressInput
    connect?: AdmissionApplicationWhereUniqueInput
    update?: XOR<XOR<AdmissionApplicationUpdateToOneWithWhereWithoutStepProgressInput, AdmissionApplicationUpdateWithoutStepProgressInput>, AdmissionApplicationUncheckedUpdateWithoutStepProgressInput>
  }

  export type LearningResourceCreatetagsInput = {
    set: string[]
  }

  export type SubjectCreateNestedOneWithoutResourcesInput = {
    create?: XOR<SubjectCreateWithoutResourcesInput, SubjectUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutResourcesInput
    connect?: SubjectWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutResourcesInput = {
    create?: XOR<TeacherCreateWithoutResourcesInput, TeacherUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutResourcesInput
    connect?: TeacherWhereUniqueInput
  }

  export type EnumResourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ResourceType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LearningResourceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type SubjectUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<SubjectCreateWithoutResourcesInput, SubjectUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutResourcesInput
    upsert?: SubjectUpsertWithoutResourcesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutResourcesInput, SubjectUpdateWithoutResourcesInput>, SubjectUncheckedUpdateWithoutResourcesInput>
  }

  export type TeacherUpdateOneRequiredWithoutResourcesNestedInput = {
    create?: XOR<TeacherCreateWithoutResourcesInput, TeacherUncheckedCreateWithoutResourcesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutResourcesInput
    upsert?: TeacherUpsertWithoutResourcesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutResourcesInput, TeacherUpdateWithoutResourcesInput>, TeacherUncheckedUpdateWithoutResourcesInput>
  }

  export type TeacherCreateNestedOneWithoutVirtualClassesInput = {
    create?: XOR<TeacherCreateWithoutVirtualClassesInput, TeacherUncheckedCreateWithoutVirtualClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutVirtualClassesInput
    connect?: TeacherWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutVirtualClassesInput = {
    create?: XOR<SubjectCreateWithoutVirtualClassesInput, SubjectUncheckedCreateWithoutVirtualClassesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutVirtualClassesInput
    connect?: SubjectWhereUniqueInput
  }

  export type VirtualClassParticipantCreateNestedManyWithoutVirtualClassInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutVirtualClassInput, VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput> | VirtualClassParticipantCreateWithoutVirtualClassInput[] | VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput | VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput[]
    createMany?: VirtualClassParticipantCreateManyVirtualClassInputEnvelope
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
  }

  export type VirtualClassParticipantUncheckedCreateNestedManyWithoutVirtualClassInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutVirtualClassInput, VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput> | VirtualClassParticipantCreateWithoutVirtualClassInput[] | VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput | VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput[]
    createMany?: VirtualClassParticipantCreateManyVirtualClassInputEnvelope
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
  }

  export type EnumVirtualClassStatusFieldUpdateOperationsInput = {
    set?: $Enums.VirtualClassStatus
  }

  export type TeacherUpdateOneRequiredWithoutVirtualClassesNestedInput = {
    create?: XOR<TeacherCreateWithoutVirtualClassesInput, TeacherUncheckedCreateWithoutVirtualClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutVirtualClassesInput
    upsert?: TeacherUpsertWithoutVirtualClassesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutVirtualClassesInput, TeacherUpdateWithoutVirtualClassesInput>, TeacherUncheckedUpdateWithoutVirtualClassesInput>
  }

  export type SubjectUpdateOneRequiredWithoutVirtualClassesNestedInput = {
    create?: XOR<SubjectCreateWithoutVirtualClassesInput, SubjectUncheckedCreateWithoutVirtualClassesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutVirtualClassesInput
    upsert?: SubjectUpsertWithoutVirtualClassesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutVirtualClassesInput, SubjectUpdateWithoutVirtualClassesInput>, SubjectUncheckedUpdateWithoutVirtualClassesInput>
  }

  export type VirtualClassParticipantUpdateManyWithoutVirtualClassNestedInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutVirtualClassInput, VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput> | VirtualClassParticipantCreateWithoutVirtualClassInput[] | VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput | VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput[]
    upsert?: VirtualClassParticipantUpsertWithWhereUniqueWithoutVirtualClassInput | VirtualClassParticipantUpsertWithWhereUniqueWithoutVirtualClassInput[]
    createMany?: VirtualClassParticipantCreateManyVirtualClassInputEnvelope
    set?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    disconnect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    delete?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    update?: VirtualClassParticipantUpdateWithWhereUniqueWithoutVirtualClassInput | VirtualClassParticipantUpdateWithWhereUniqueWithoutVirtualClassInput[]
    updateMany?: VirtualClassParticipantUpdateManyWithWhereWithoutVirtualClassInput | VirtualClassParticipantUpdateManyWithWhereWithoutVirtualClassInput[]
    deleteMany?: VirtualClassParticipantScalarWhereInput | VirtualClassParticipantScalarWhereInput[]
  }

  export type VirtualClassParticipantUncheckedUpdateManyWithoutVirtualClassNestedInput = {
    create?: XOR<VirtualClassParticipantCreateWithoutVirtualClassInput, VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput> | VirtualClassParticipantCreateWithoutVirtualClassInput[] | VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput[]
    connectOrCreate?: VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput | VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput[]
    upsert?: VirtualClassParticipantUpsertWithWhereUniqueWithoutVirtualClassInput | VirtualClassParticipantUpsertWithWhereUniqueWithoutVirtualClassInput[]
    createMany?: VirtualClassParticipantCreateManyVirtualClassInputEnvelope
    set?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    disconnect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    delete?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    connect?: VirtualClassParticipantWhereUniqueInput | VirtualClassParticipantWhereUniqueInput[]
    update?: VirtualClassParticipantUpdateWithWhereUniqueWithoutVirtualClassInput | VirtualClassParticipantUpdateWithWhereUniqueWithoutVirtualClassInput[]
    updateMany?: VirtualClassParticipantUpdateManyWithWhereWithoutVirtualClassInput | VirtualClassParticipantUpdateManyWithWhereWithoutVirtualClassInput[]
    deleteMany?: VirtualClassParticipantScalarWhereInput | VirtualClassParticipantScalarWhereInput[]
  }

  export type VirtualClassCreateNestedOneWithoutClassesInput = {
    create?: XOR<VirtualClassCreateWithoutClassesInput, VirtualClassUncheckedCreateWithoutClassesInput>
    connectOrCreate?: VirtualClassCreateOrConnectWithoutClassesInput
    connect?: VirtualClassWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutVirtualClassesInput = {
    create?: XOR<ClassCreateWithoutVirtualClassesInput, ClassUncheckedCreateWithoutVirtualClassesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutVirtualClassesInput
    connect?: ClassWhereUniqueInput
  }

  export type VirtualClassUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<VirtualClassCreateWithoutClassesInput, VirtualClassUncheckedCreateWithoutClassesInput>
    connectOrCreate?: VirtualClassCreateOrConnectWithoutClassesInput
    upsert?: VirtualClassUpsertWithoutClassesInput
    connect?: VirtualClassWhereUniqueInput
    update?: XOR<XOR<VirtualClassUpdateToOneWithWhereWithoutClassesInput, VirtualClassUpdateWithoutClassesInput>, VirtualClassUncheckedUpdateWithoutClassesInput>
  }

  export type ClassUpdateOneRequiredWithoutVirtualClassesNestedInput = {
    create?: XOR<ClassCreateWithoutVirtualClassesInput, ClassUncheckedCreateWithoutVirtualClassesInput>
    connectOrCreate?: ClassCreateOrConnectWithoutVirtualClassesInput
    upsert?: ClassUpsertWithoutVirtualClassesInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutVirtualClassesInput, ClassUpdateWithoutVirtualClassesInput>, ClassUncheckedUpdateWithoutVirtualClassesInput>
  }

  export type AchievementCreatecriteriaInput = {
    set: string[]
  }

  export type StudentAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<StudentAchievementCreateWithoutAchievementInput, StudentAchievementUncheckedCreateWithoutAchievementInput> | StudentAchievementCreateWithoutAchievementInput[] | StudentAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutAchievementInput | StudentAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: StudentAchievementCreateManyAchievementInputEnvelope
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
  }

  export type StudentAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<StudentAchievementCreateWithoutAchievementInput, StudentAchievementUncheckedCreateWithoutAchievementInput> | StudentAchievementCreateWithoutAchievementInput[] | StudentAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutAchievementInput | StudentAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: StudentAchievementCreateManyAchievementInputEnvelope
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
  }

  export type EnumAchievementCategoryFieldUpdateOperationsInput = {
    set?: $Enums.AchievementCategory
  }

  export type AchievementUpdatecriteriaInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumRarityFieldUpdateOperationsInput = {
    set?: $Enums.Rarity
  }

  export type StudentAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<StudentAchievementCreateWithoutAchievementInput, StudentAchievementUncheckedCreateWithoutAchievementInput> | StudentAchievementCreateWithoutAchievementInput[] | StudentAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutAchievementInput | StudentAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: StudentAchievementUpsertWithWhereUniqueWithoutAchievementInput | StudentAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: StudentAchievementCreateManyAchievementInputEnvelope
    set?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    disconnect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    delete?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    update?: StudentAchievementUpdateWithWhereUniqueWithoutAchievementInput | StudentAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: StudentAchievementUpdateManyWithWhereWithoutAchievementInput | StudentAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: StudentAchievementScalarWhereInput | StudentAchievementScalarWhereInput[]
  }

  export type StudentAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<StudentAchievementCreateWithoutAchievementInput, StudentAchievementUncheckedCreateWithoutAchievementInput> | StudentAchievementCreateWithoutAchievementInput[] | StudentAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: StudentAchievementCreateOrConnectWithoutAchievementInput | StudentAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: StudentAchievementUpsertWithWhereUniqueWithoutAchievementInput | StudentAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: StudentAchievementCreateManyAchievementInputEnvelope
    set?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    disconnect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    delete?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    connect?: StudentAchievementWhereUniqueInput | StudentAchievementWhereUniqueInput[]
    update?: StudentAchievementUpdateWithWhereUniqueWithoutAchievementInput | StudentAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: StudentAchievementUpdateManyWithWhereWithoutAchievementInput | StudentAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: StudentAchievementScalarWhereInput | StudentAchievementScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAchievementsInput
    connect?: StudentWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutStudentsInput = {
    create?: XOR<AchievementCreateWithoutStudentsInput, AchievementUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutStudentsInput
    connect?: AchievementWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutAchievementsInput
    upsert?: StudentUpsertWithoutAchievementsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutAchievementsInput, StudentUpdateWithoutAchievementsInput>, StudentUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<AchievementCreateWithoutStudentsInput, AchievementUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutStudentsInput
    upsert?: AchievementUpsertWithoutStudentsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutStudentsInput, AchievementUpdateWithoutStudentsInput>, AchievementUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentCreateNestedOneWithoutBehaviorRecordsInput = {
    create?: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBehaviorRecordsInput
    connect?: StudentWhereUniqueInput
  }

  export type TeacherCreateNestedOneWithoutBehaviorRecordsInput = {
    create?: XOR<TeacherCreateWithoutBehaviorRecordsInput, TeacherUncheckedCreateWithoutBehaviorRecordsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutBehaviorRecordsInput
    connect?: TeacherWhereUniqueInput
  }

  export type EnumBehaviorTypeFieldUpdateOperationsInput = {
    set?: $Enums.BehaviorType
  }

  export type EnumBehaviorCategoryFieldUpdateOperationsInput = {
    set?: $Enums.BehaviorCategory
  }

  export type NullableEnumSeverityFieldUpdateOperationsInput = {
    set?: $Enums.Severity | null
  }

  export type StudentUpdateOneRequiredWithoutBehaviorRecordsNestedInput = {
    create?: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutBehaviorRecordsInput
    upsert?: StudentUpsertWithoutBehaviorRecordsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutBehaviorRecordsInput, StudentUpdateWithoutBehaviorRecordsInput>, StudentUncheckedUpdateWithoutBehaviorRecordsInput>
  }

  export type TeacherUpdateOneRequiredWithoutBehaviorRecordsNestedInput = {
    create?: XOR<TeacherCreateWithoutBehaviorRecordsInput, TeacherUncheckedCreateWithoutBehaviorRecordsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutBehaviorRecordsInput
    upsert?: TeacherUpsertWithoutBehaviorRecordsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutBehaviorRecordsInput, TeacherUpdateWithoutBehaviorRecordsInput>, TeacherUncheckedUpdateWithoutBehaviorRecordsInput>
  }

  export type StudentCreateNestedOneWithoutReportCardsInput = {
    create?: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportCardsInput
    connect?: StudentWhereUniqueInput
  }

  export type EnumBehaviorGradeFieldUpdateOperationsInput = {
    set?: $Enums.BehaviorGrade
  }

  export type StudentUpdateOneRequiredWithoutReportCardsNestedInput = {
    create?: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReportCardsInput
    upsert?: StudentUpsertWithoutReportCardsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutReportCardsInput, StudentUpdateWithoutReportCardsInput>, StudentUncheckedUpdateWithoutReportCardsInput>
  }

  export type NotificationCreatechannelsInput = {
    set: $Enums.NotificationChannel[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationCategoryFieldUpdateOperationsInput = {
    set?: $Enums.NotificationCategory
  }

  export type NotificationUpdatechannelsInput = {
    set?: $Enums.NotificationChannel[]
    push?: $Enums.NotificationChannel | $Enums.NotificationChannel[]
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type AssignmentCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<AssignmentCreateWithoutAttachmentsInput, AssignmentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutAttachmentsInput
    connect?: AssignmentWhereUniqueInput
  }

  export type AssignmentSubmissionCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAttachmentsInput, AssignmentSubmissionUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAttachmentsInput
    connect?: AssignmentSubmissionWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    connect?: MessageWhereUniqueInput
  }

  export type AdmissionApplicationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AdmissionApplicationCreateWithoutDocumentsInput, AdmissionApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutDocumentsInput
    connect?: AdmissionApplicationWhereUniqueInput
  }

  export type AssignmentUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<AssignmentCreateWithoutAttachmentsInput, AssignmentUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutAttachmentsInput
    upsert?: AssignmentUpsertWithoutAttachmentsInput
    disconnect?: AssignmentWhereInput | boolean
    delete?: AssignmentWhereInput | boolean
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutAttachmentsInput, AssignmentUpdateWithoutAttachmentsInput>, AssignmentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type AssignmentSubmissionUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<AssignmentSubmissionCreateWithoutAttachmentsInput, AssignmentSubmissionUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: AssignmentSubmissionCreateOrConnectWithoutAttachmentsInput
    upsert?: AssignmentSubmissionUpsertWithoutAttachmentsInput
    disconnect?: AssignmentSubmissionWhereInput | boolean
    delete?: AssignmentSubmissionWhereInput | boolean
    connect?: AssignmentSubmissionWhereUniqueInput
    update?: XOR<XOR<AssignmentSubmissionUpdateToOneWithWhereWithoutAttachmentsInput, AssignmentSubmissionUpdateWithoutAttachmentsInput>, AssignmentSubmissionUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateOneWithoutAttachmentsNestedInput = {
    create?: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutAttachmentsInput
    upsert?: MessageUpsertWithoutAttachmentsInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutAttachmentsInput, MessageUpdateWithoutAttachmentsInput>, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type AdmissionApplicationUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<AdmissionApplicationCreateWithoutDocumentsInput, AdmissionApplicationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AdmissionApplicationCreateOrConnectWithoutDocumentsInput
    upsert?: AdmissionApplicationUpsertWithoutDocumentsInput
    disconnect?: AdmissionApplicationWhereInput | boolean
    delete?: AdmissionApplicationWhereInput | boolean
    connect?: AdmissionApplicationWhereUniqueInput
    update?: XOR<XOR<AdmissionApplicationUpdateToOneWithWhereWithoutDocumentsInput, AdmissionApplicationUpdateWithoutDocumentsInput>, AdmissionApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type TeacherCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSubjectsInput
    connect?: TeacherWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutTeachersInput = {
    create?: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachersInput
    connect?: SubjectWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutSubjectsInput
    upsert?: TeacherUpsertWithoutSubjectsInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutSubjectsInput, TeacherUpdateWithoutSubjectsInput>, TeacherUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutTeachersInput
    upsert?: SubjectUpsertWithoutTeachersInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutTeachersInput, SubjectUpdateWithoutTeachersInput>, SubjectUncheckedUpdateWithoutTeachersInput>
  }

  export type TeacherCreateNestedOneWithoutClassesInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    connect?: TeacherWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutTeachersInput = {
    create?: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeachersInput
    connect?: ClassWhereUniqueInput
  }

  export type TeacherUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherCreateOrConnectWithoutClassesInput
    upsert?: TeacherUpsertWithoutClassesInput
    connect?: TeacherWhereUniqueInput
    update?: XOR<XOR<TeacherUpdateToOneWithWhereWithoutClassesInput, TeacherUpdateWithoutClassesInput>, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type ClassUpdateOneRequiredWithoutTeachersNestedInput = {
    create?: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: ClassCreateOrConnectWithoutTeachersInput
    upsert?: ClassUpsertWithoutTeachersInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutTeachersInput, ClassUpdateWithoutTeachersInput>, ClassUncheckedUpdateWithoutTeachersInput>
  }

  export type ClassCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput
    connect?: ClassWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutClassesInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput
    connect?: SubjectWhereUniqueInput
  }

  export type ClassUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutSubjectsInput
    upsert?: ClassUpsertWithoutSubjectsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutSubjectsInput, ClassUpdateWithoutSubjectsInput>, ClassUncheckedUpdateWithoutSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutClassesInput
    upsert?: SubjectUpsertWithoutClassesInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutClassesInput, SubjectUpdateWithoutClassesInput>, SubjectUncheckedUpdateWithoutClassesInput>
  }

  export type AssignmentCreateNestedOneWithoutClassesInput = {
    create?: XOR<AssignmentCreateWithoutClassesInput, AssignmentUncheckedCreateWithoutClassesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutClassesInput
    connect?: AssignmentWhereUniqueInput
  }

  export type ClassCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAssignmentsInput
    connect?: ClassWhereUniqueInput
  }

  export type AssignmentUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<AssignmentCreateWithoutClassesInput, AssignmentUncheckedCreateWithoutClassesInput>
    connectOrCreate?: AssignmentCreateOrConnectWithoutClassesInput
    upsert?: AssignmentUpsertWithoutClassesInput
    connect?: AssignmentWhereUniqueInput
    update?: XOR<XOR<AssignmentUpdateToOneWithWhereWithoutClassesInput, AssignmentUpdateWithoutClassesInput>, AssignmentUncheckedUpdateWithoutClassesInput>
  }

  export type ClassUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ClassCreateOrConnectWithoutAssignmentsInput
    upsert?: ClassUpsertWithoutAssignmentsInput
    connect?: ClassWhereUniqueInput
    update?: XOR<XOR<ClassUpdateToOneWithWhereWithoutAssignmentsInput, ClassUpdateWithoutAssignmentsInput>, ClassUncheckedUpdateWithoutAssignmentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumContactMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodFilter<$PrismaModel> | $Enums.ContactMethod
  }

  export type NestedEnumContactMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactMethod | EnumContactMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactMethod[] | ListEnumContactMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumContactMethodWithAggregatesFilter<$PrismaModel> | $Enums.ContactMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactMethodFilter<$PrismaModel>
    _max?: NestedEnumContactMethodFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumGradeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeFilter<$PrismaModel> | $Enums.GradeType
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GradeType | EnumGradeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GradeType[] | ListEnumGradeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGradeTypeWithAggregatesFilter<$PrismaModel> | $Enums.GradeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGradeTypeFilter<$PrismaModel>
    _max?: NestedEnumGradeTypeFilter<$PrismaModel>
  }

  export type NestedEnumAssignmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentType | EnumAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTypeFilter<$PrismaModel> | $Enums.AssignmentType
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumSubmissionFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionFormat | EnumSubmissionFormatFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionFormatFilter<$PrismaModel> | $Enums.SubmissionFormat
  }

  export type NestedEnumAssignmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AssignmentType | EnumAssignmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AssignmentType[] | ListEnumAssignmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAssignmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AssignmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAssignmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAssignmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumSubmissionFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionFormat | EnumSubmissionFormatFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionFormat[] | ListEnumSubmissionFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionFormatWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionFormatFilter<$PrismaModel>
    _max?: NestedEnumSubmissionFormatFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSubmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusFilter<$PrismaModel> | $Enums.SubmissionStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubmissionStatus | EnumSubmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubmissionStatus[] | ListEnumSubmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumFinancialTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialType | EnumFinancialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialTypeFilter<$PrismaModel> | $Enums.FinancialType
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumFinancialTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FinancialType | EnumFinancialTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FinancialType[] | ListEnumFinancialTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFinancialTypeWithAggregatesFilter<$PrismaModel> | $Enums.FinancialType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFinancialTypeFilter<$PrismaModel>
    _max?: NestedEnumFinancialTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumAdmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusFilter<$PrismaModel> | $Enums.AdmissionStatus
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumAdmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumAdmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type NestedEnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type NestedEnumResourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeFilter<$PrismaModel> | $Enums.ResourceType
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResourceType | EnumResourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResourceType[] | ListEnumResourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumResourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ResourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResourceTypeFilter<$PrismaModel>
    _max?: NestedEnumResourceTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type NestedEnumVirtualClassStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VirtualClassStatus | EnumVirtualClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirtualClassStatusFilter<$PrismaModel> | $Enums.VirtualClassStatus
  }

  export type NestedEnumVirtualClassStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VirtualClassStatus | EnumVirtualClassStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VirtualClassStatus[] | ListEnumVirtualClassStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVirtualClassStatusWithAggregatesFilter<$PrismaModel> | $Enums.VirtualClassStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVirtualClassStatusFilter<$PrismaModel>
    _max?: NestedEnumVirtualClassStatusFilter<$PrismaModel>
  }

  export type NestedEnumAchievementCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryFilter<$PrismaModel> | $Enums.AchievementCategory
  }

  export type NestedEnumRarityFilter<$PrismaModel = never> = {
    equals?: $Enums.Rarity | EnumRarityFieldRefInput<$PrismaModel>
    in?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumRarityFilter<$PrismaModel> | $Enums.Rarity
  }

  export type NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementCategory | EnumAchievementCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementCategory[] | ListEnumAchievementCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementCategoryWithAggregatesFilter<$PrismaModel> | $Enums.AchievementCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementCategoryFilter<$PrismaModel>
    _max?: NestedEnumAchievementCategoryFilter<$PrismaModel>
  }

  export type NestedEnumRarityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rarity | EnumRarityFieldRefInput<$PrismaModel>
    in?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rarity[] | ListEnumRarityFieldRefInput<$PrismaModel>
    not?: NestedEnumRarityWithAggregatesFilter<$PrismaModel> | $Enums.Rarity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRarityFilter<$PrismaModel>
    _max?: NestedEnumRarityFilter<$PrismaModel>
  }

  export type NestedEnumBehaviorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeFilter<$PrismaModel> | $Enums.BehaviorType
  }

  export type NestedEnumBehaviorCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorCategory | EnumBehaviorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorCategoryFilter<$PrismaModel> | $Enums.BehaviorCategory
  }

  export type NestedEnumSeverityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableFilter<$PrismaModel> | $Enums.Severity | null
  }

  export type NestedEnumBehaviorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorType | EnumBehaviorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorType[] | ListEnumBehaviorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorTypeWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorTypeFilter<$PrismaModel>
    _max?: NestedEnumBehaviorTypeFilter<$PrismaModel>
  }

  export type NestedEnumBehaviorCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorCategory | EnumBehaviorCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorCategory[] | ListEnumBehaviorCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorCategoryWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorCategoryFilter<$PrismaModel>
    _max?: NestedEnumBehaviorCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSeverityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel> | null
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSeverityNullableWithAggregatesFilter<$PrismaModel> | $Enums.Severity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSeverityNullableFilter<$PrismaModel>
    _max?: NestedEnumSeverityNullableFilter<$PrismaModel>
  }

  export type NestedEnumBehaviorGradeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorGrade | EnumBehaviorGradeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorGradeFilter<$PrismaModel> | $Enums.BehaviorGrade
  }

  export type NestedEnumBehaviorGradeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehaviorGrade | EnumBehaviorGradeFieldRefInput<$PrismaModel>
    in?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehaviorGrade[] | ListEnumBehaviorGradeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehaviorGradeWithAggregatesFilter<$PrismaModel> | $Enums.BehaviorGrade
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehaviorGradeFilter<$PrismaModel>
    _max?: NestedEnumBehaviorGradeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryFilter<$PrismaModel> | $Enums.NotificationCategory
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationCategory | EnumNotificationCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationCategory[] | ListEnumNotificationCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationCategoryWithAggregatesFilter<$PrismaModel> | $Enums.NotificationCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationCategoryFilter<$PrismaModel>
    _max?: NestedEnumNotificationCategoryFilter<$PrismaModel>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    studentId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type TeacherCreateWithoutUserInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutUserInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutUserInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
  }

  export type ParentCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentCreateNestedManyWithoutParentsInput
    admissionApplications?: AdmissionApplicationCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentUncheckedCreateNestedManyWithoutParentsInput
    admissionApplications?: AdmissionApplicationUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: UserCreateNestedManyWithoutReceivedMessagesInput
    parentMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: UserUncheckedCreateNestedManyWithoutReceivedMessagesInput
    replies?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutRecipientsInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    parentMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRecipientsInput = {
    id?: string
    senderId: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRecipientsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    read?: boolean
    actionRequired?: boolean
    actionUrl?: string | null
    scheduledFor?: Date | string | null
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    read?: boolean
    actionRequired?: boolean
    actionUrl?: string | null
    scheduledFor?: Date | string | null
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherUpsertWithoutUserInput = {
    update: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherCreateWithoutUserInput, TeacherUncheckedCreateWithoutUserInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutUserInput, TeacherUncheckedUpdateWithoutUserInput>
  }

  export type TeacherUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentUpdateManyWithoutParentsNestedInput
    admissionApplications?: AdmissionApplicationUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentUncheckedUpdateManyWithoutParentsNestedInput
    admissionApplications?: AdmissionApplicationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    recipientIds?: StringNullableListFilter<"Message">
    subject?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    priority?: EnumPriorityFilter<"Message"> | $Enums.Priority
    read?: BoolFilter<"Message"> | boolean
    parentMessageId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutRecipientsInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutRecipientsInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
  }

  export type MessageUpdateManyWithWhereWithoutRecipientsInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutRecipientsInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    category?: EnumNotificationCategoryFilter<"Notification"> | $Enums.NotificationCategory
    read?: BoolFilter<"Notification"> | boolean
    actionRequired?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    scheduledFor?: DateTimeNullableFilter<"Notification"> | Date | string | null
    channels?: EnumNotificationChannelNullableListFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    deviceInfo?: StringNullableFilter<"UserSession"> | string | null
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type ClassCreateWithoutStudentsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherClassCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    schedules?: ScheduleCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherClassUncheckedCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutStudentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
  }

  export type ParentCreateWithoutChildrenInput = {
    id?: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    admissionApplications?: AdmissionApplicationCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutChildrenInput = {
    id?: string
    userId: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionApplications?: AdmissionApplicationUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutChildrenInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
  }

  export type GradeCreateWithoutStudentInput = {
    id?: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutGradesInput
    teacher: TeacherCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutStudentInput = {
    id?: string
    subjectId: string
    teacherId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutStudentInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput>
  }

  export type GradeCreateManyStudentInputEnvelope = {
    data: GradeCreateManyStudentInput | GradeCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    class?: ClassCreateNestedOneWithoutAttendanceRecordsInput
    teacher: TeacherCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    classId?: string | null
    teacherId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordCreateManyStudentInputEnvelope = {
    data: AttendanceRecordCreateManyStudentInput | AttendanceRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutStudentInput = {
    id?: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
    attachments?: FileAttachmentCreateNestedManyWithoutSubmissionInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutStudentInput = {
    id?: string
    assignmentId: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type AssignmentSubmissionCreateOrConnectWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentSubmissionCreateManyStudentInputEnvelope = {
    data: AssignmentSubmissionCreateManyStudentInput | AssignmentSubmissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type StudentAchievementCreateWithoutStudentInput = {
    id?: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
    achievement: AchievementCreateNestedOneWithoutStudentsInput
  }

  export type StudentAchievementUncheckedCreateWithoutStudentInput = {
    id?: string
    achievementId: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
  }

  export type StudentAchievementCreateOrConnectWithoutStudentInput = {
    where: StudentAchievementWhereUniqueInput
    create: XOR<StudentAchievementCreateWithoutStudentInput, StudentAchievementUncheckedCreateWithoutStudentInput>
  }

  export type StudentAchievementCreateManyStudentInputEnvelope = {
    data: StudentAchievementCreateManyStudentInput | StudentAchievementCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type BehaviorRecordCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutBehaviorRecordsInput
  }

  export type BehaviorRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    teacherId: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorRecordCreateOrConnectWithoutStudentInput = {
    where: BehaviorRecordWhereUniqueInput
    create: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput>
  }

  export type BehaviorRecordCreateManyStudentInputEnvelope = {
    data: BehaviorRecordCreateManyStudentInput | BehaviorRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type FinancialRecordCreateWithoutStudentInput = {
    id?: string
    type: $Enums.FinancialType
    amount: number
    currency?: string
    dueDate: Date | string
    paidDate?: Date | string | null
    status?: $Enums.PaymentStatus
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    invoiceNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialRecordUncheckedCreateWithoutStudentInput = {
    id?: string
    type: $Enums.FinancialType
    amount: number
    currency?: string
    dueDate: Date | string
    paidDate?: Date | string | null
    status?: $Enums.PaymentStatus
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    invoiceNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialRecordCreateOrConnectWithoutStudentInput = {
    where: FinancialRecordWhereUniqueInput
    create: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput>
  }

  export type FinancialRecordCreateManyStudentInputEnvelope = {
    data: FinancialRecordCreateManyStudentInput | FinancialRecordCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ReportCardCreateWithoutStudentInput = {
    id?: string
    academicYear: string
    semester: string
    overallAverage: number
    rank?: number | null
    totalStudents?: number | null
    behaviorGrade?: $Enums.BehaviorGrade
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment?: string | null
    generatedAt: Date | string
    generatedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardUncheckedCreateWithoutStudentInput = {
    id?: string
    academicYear: string
    semester: string
    overallAverage: number
    rank?: number | null
    totalStudents?: number | null
    behaviorGrade?: $Enums.BehaviorGrade
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment?: string | null
    generatedAt: Date | string
    generatedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardCreateOrConnectWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardCreateManyStudentInputEnvelope = {
    data: ReportCardCreateManyStudentInput | ReportCardCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClassUpsertWithoutStudentsInput = {
    update: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassCreateWithoutStudentsInput, ClassUncheckedCreateWithoutStudentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutStudentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutStudentsInput, ClassUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherClassUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherClassUncheckedUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ParentUpsertWithWhereUniqueWithoutChildrenInput = {
    where: ParentWhereUniqueInput
    update: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
  }

  export type ParentUpdateWithWhereUniqueWithoutChildrenInput = {
    where: ParentWhereUniqueInput
    data: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type ParentUpdateManyWithWhereWithoutChildrenInput = {
    where: ParentScalarWhereInput
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyWithoutChildrenInput>
  }

  export type ParentScalarWhereInput = {
    AND?: ParentScalarWhereInput | ParentScalarWhereInput[]
    OR?: ParentScalarWhereInput[]
    NOT?: ParentScalarWhereInput | ParentScalarWhereInput[]
    id?: StringFilter<"Parent"> | string
    userId?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    preferredContactMethod?: EnumContactMethodFilter<"Parent"> | $Enums.ContactMethod
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
  }

  export type GradeUpsertWithWhereUniqueWithoutStudentInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutStudentInput, GradeUncheckedUpdateWithoutStudentInput>
    create: XOR<GradeCreateWithoutStudentInput, GradeUncheckedCreateWithoutStudentInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutStudentInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutStudentInput, GradeUncheckedUpdateWithoutStudentInput>
  }

  export type GradeUpdateManyWithWhereWithoutStudentInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutStudentInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    studentId?: StringFilter<"Grade"> | string
    subjectId?: StringFilter<"Grade"> | string
    teacherId?: StringFilter<"Grade"> | string
    value?: FloatFilter<"Grade"> | number
    maxValue?: FloatFilter<"Grade"> | number
    type?: EnumGradeTypeFilter<"Grade"> | $Enums.GradeType
    comment?: StringNullableFilter<"Grade"> | string | null
    date?: DateTimeFilter<"Grade"> | Date | string
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    updatedAt?: DateTimeFilter<"Grade"> | Date | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceRecordCreateWithoutStudentInput, AttendanceRecordUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutStudentInput, AttendanceRecordUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceRecordScalarWhereInput = {
    AND?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    OR?: AttendanceRecordScalarWhereInput[]
    NOT?: AttendanceRecordScalarWhereInput | AttendanceRecordScalarWhereInput[]
    id?: StringFilter<"AttendanceRecord"> | string
    studentId?: StringFilter<"AttendanceRecord"> | string
    classId?: StringNullableFilter<"AttendanceRecord"> | string | null
    teacherId?: StringFilter<"AttendanceRecord"> | string
    date?: DateTimeFilter<"AttendanceRecord"> | Date | string
    status?: EnumAttendanceStatusFilter<"AttendanceRecord"> | $Enums.AttendanceStatus
    period?: StringNullableFilter<"AttendanceRecord"> | string | null
    reason?: StringNullableFilter<"AttendanceRecord"> | string | null
    notifiedParents?: BoolFilter<"AttendanceRecord"> | boolean
    createdAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
    updatedAt?: DateTimeFilter<"AttendanceRecord"> | Date | string
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutStudentInput, AssignmentSubmissionUncheckedUpdateWithoutStudentInput>
    create: XOR<AssignmentSubmissionCreateWithoutStudentInput, AssignmentSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutStudentInput, AssignmentSubmissionUncheckedUpdateWithoutStudentInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutStudentInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type AssignmentSubmissionScalarWhereInput = {
    AND?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    OR?: AssignmentSubmissionScalarWhereInput[]
    NOT?: AssignmentSubmissionScalarWhereInput | AssignmentSubmissionScalarWhereInput[]
    id?: StringFilter<"AssignmentSubmission"> | string
    assignmentId?: StringFilter<"AssignmentSubmission"> | string
    studentId?: StringFilter<"AssignmentSubmission"> | string
    content?: StringNullableFilter<"AssignmentSubmission"> | string | null
    submittedAt?: DateTimeNullableFilter<"AssignmentSubmission"> | Date | string | null
    grade?: FloatNullableFilter<"AssignmentSubmission"> | number | null
    feedback?: StringNullableFilter<"AssignmentSubmission"> | string | null
    status?: EnumSubmissionStatusFilter<"AssignmentSubmission"> | $Enums.SubmissionStatus
    createdAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"AssignmentSubmission"> | Date | string
  }

  export type StudentAchievementUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentAchievementWhereUniqueInput
    update: XOR<StudentAchievementUpdateWithoutStudentInput, StudentAchievementUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentAchievementCreateWithoutStudentInput, StudentAchievementUncheckedCreateWithoutStudentInput>
  }

  export type StudentAchievementUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentAchievementWhereUniqueInput
    data: XOR<StudentAchievementUpdateWithoutStudentInput, StudentAchievementUncheckedUpdateWithoutStudentInput>
  }

  export type StudentAchievementUpdateManyWithWhereWithoutStudentInput = {
    where: StudentAchievementScalarWhereInput
    data: XOR<StudentAchievementUpdateManyMutationInput, StudentAchievementUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentAchievementScalarWhereInput = {
    AND?: StudentAchievementScalarWhereInput | StudentAchievementScalarWhereInput[]
    OR?: StudentAchievementScalarWhereInput[]
    NOT?: StudentAchievementScalarWhereInput | StudentAchievementScalarWhereInput[]
    id?: StringFilter<"StudentAchievement"> | string
    studentId?: StringFilter<"StudentAchievement"> | string
    achievementId?: StringFilter<"StudentAchievement"> | string
    earnedDate?: DateTimeFilter<"StudentAchievement"> | Date | string
    awardedBy?: StringFilter<"StudentAchievement"> | string
    evidence?: StringNullableFilter<"StudentAchievement"> | string | null
  }

  export type BehaviorRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: BehaviorRecordWhereUniqueInput
    update: XOR<BehaviorRecordUpdateWithoutStudentInput, BehaviorRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<BehaviorRecordCreateWithoutStudentInput, BehaviorRecordUncheckedCreateWithoutStudentInput>
  }

  export type BehaviorRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: BehaviorRecordWhereUniqueInput
    data: XOR<BehaviorRecordUpdateWithoutStudentInput, BehaviorRecordUncheckedUpdateWithoutStudentInput>
  }

  export type BehaviorRecordUpdateManyWithWhereWithoutStudentInput = {
    where: BehaviorRecordScalarWhereInput
    data: XOR<BehaviorRecordUpdateManyMutationInput, BehaviorRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type BehaviorRecordScalarWhereInput = {
    AND?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
    OR?: BehaviorRecordScalarWhereInput[]
    NOT?: BehaviorRecordScalarWhereInput | BehaviorRecordScalarWhereInput[]
    id?: StringFilter<"BehaviorRecord"> | string
    studentId?: StringFilter<"BehaviorRecord"> | string
    teacherId?: StringFilter<"BehaviorRecord"> | string
    date?: DateTimeFilter<"BehaviorRecord"> | Date | string
    type?: EnumBehaviorTypeFilter<"BehaviorRecord"> | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFilter<"BehaviorRecord"> | $Enums.BehaviorCategory
    description?: StringFilter<"BehaviorRecord"> | string
    severity?: EnumSeverityNullableFilter<"BehaviorRecord"> | $Enums.Severity | null
    actionTaken?: StringNullableFilter<"BehaviorRecord"> | string | null
    parentNotified?: BoolFilter<"BehaviorRecord"> | boolean
    followUpRequired?: BoolFilter<"BehaviorRecord"> | boolean
    createdAt?: DateTimeFilter<"BehaviorRecord"> | Date | string
    updatedAt?: DateTimeFilter<"BehaviorRecord"> | Date | string
  }

  export type FinancialRecordUpsertWithWhereUniqueWithoutStudentInput = {
    where: FinancialRecordWhereUniqueInput
    update: XOR<FinancialRecordUpdateWithoutStudentInput, FinancialRecordUncheckedUpdateWithoutStudentInput>
    create: XOR<FinancialRecordCreateWithoutStudentInput, FinancialRecordUncheckedCreateWithoutStudentInput>
  }

  export type FinancialRecordUpdateWithWhereUniqueWithoutStudentInput = {
    where: FinancialRecordWhereUniqueInput
    data: XOR<FinancialRecordUpdateWithoutStudentInput, FinancialRecordUncheckedUpdateWithoutStudentInput>
  }

  export type FinancialRecordUpdateManyWithWhereWithoutStudentInput = {
    where: FinancialRecordScalarWhereInput
    data: XOR<FinancialRecordUpdateManyMutationInput, FinancialRecordUncheckedUpdateManyWithoutStudentInput>
  }

  export type FinancialRecordScalarWhereInput = {
    AND?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
    OR?: FinancialRecordScalarWhereInput[]
    NOT?: FinancialRecordScalarWhereInput | FinancialRecordScalarWhereInput[]
    id?: StringFilter<"FinancialRecord"> | string
    studentId?: StringFilter<"FinancialRecord"> | string
    type?: EnumFinancialTypeFilter<"FinancialRecord"> | $Enums.FinancialType
    amount?: FloatFilter<"FinancialRecord"> | number
    currency?: StringFilter<"FinancialRecord"> | string
    dueDate?: DateTimeFilter<"FinancialRecord"> | Date | string
    paidDate?: DateTimeNullableFilter<"FinancialRecord"> | Date | string | null
    status?: EnumPaymentStatusFilter<"FinancialRecord"> | $Enums.PaymentStatus
    description?: StringFilter<"FinancialRecord"> | string
    paymentMethod?: EnumPaymentMethodNullableFilter<"FinancialRecord"> | $Enums.PaymentMethod | null
    invoiceNumber?: StringFilter<"FinancialRecord"> | string
    createdAt?: DateTimeFilter<"FinancialRecord"> | Date | string
    updatedAt?: DateTimeFilter<"FinancialRecord"> | Date | string
  }

  export type ReportCardUpsertWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    update: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
    create: XOR<ReportCardCreateWithoutStudentInput, ReportCardUncheckedCreateWithoutStudentInput>
  }

  export type ReportCardUpdateWithWhereUniqueWithoutStudentInput = {
    where: ReportCardWhereUniqueInput
    data: XOR<ReportCardUpdateWithoutStudentInput, ReportCardUncheckedUpdateWithoutStudentInput>
  }

  export type ReportCardUpdateManyWithWhereWithoutStudentInput = {
    where: ReportCardScalarWhereInput
    data: XOR<ReportCardUpdateManyMutationInput, ReportCardUncheckedUpdateManyWithoutStudentInput>
  }

  export type ReportCardScalarWhereInput = {
    AND?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    OR?: ReportCardScalarWhereInput[]
    NOT?: ReportCardScalarWhereInput | ReportCardScalarWhereInput[]
    id?: StringFilter<"ReportCard"> | string
    studentId?: StringFilter<"ReportCard"> | string
    academicYear?: StringFilter<"ReportCard"> | string
    semester?: StringFilter<"ReportCard"> | string
    overallAverage?: FloatFilter<"ReportCard"> | number
    rank?: IntNullableFilter<"ReportCard"> | number | null
    totalStudents?: IntNullableFilter<"ReportCard"> | number | null
    behaviorGrade?: EnumBehaviorGradeFilter<"ReportCard"> | $Enums.BehaviorGrade
    totalDays?: IntFilter<"ReportCard"> | number
    presentDays?: IntFilter<"ReportCard"> | number
    absentDays?: IntFilter<"ReportCard"> | number
    lateCount?: IntFilter<"ReportCard"> | number
    principalComment?: StringNullableFilter<"ReportCard"> | string | null
    generatedAt?: DateTimeFilter<"ReportCard"> | Date | string
    generatedBy?: StringFilter<"ReportCard"> | string
    createdAt?: DateTimeFilter<"ReportCard"> | Date | string
    updatedAt?: DateTimeFilter<"ReportCard"> | Date | string
  }

  export type UserCreateWithoutTeacherInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeacherInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeacherInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectCreateWithoutTeacherInput = {
    subject: SubjectCreateNestedOneWithoutTeachersInput
  }

  export type TeacherSubjectUncheckedCreateWithoutTeacherInput = {
    subjectId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectCreateManyTeacherInputEnvelope = {
    data: TeacherSubjectCreateManyTeacherInput | TeacherSubjectCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type TeacherClassCreateWithoutTeacherInput = {
    isMainTeacher?: boolean
    class: ClassCreateNestedOneWithoutTeachersInput
  }

  export type TeacherClassUncheckedCreateWithoutTeacherInput = {
    classId: string
    isMainTeacher?: boolean
  }

  export type TeacherClassCreateOrConnectWithoutTeacherInput = {
    where: TeacherClassWhereUniqueInput
    create: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherClassCreateManyTeacherInputEnvelope = {
    data: TeacherClassCreateManyTeacherInput | TeacherClassCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutTeacherInput = {
    id?: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
    subject: SubjectCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutTeacherInput = {
    id?: string
    studentId: string
    subjectId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutTeacherInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutTeacherInput, GradeUncheckedCreateWithoutTeacherInput>
  }

  export type GradeCreateManyTeacherInputEnvelope = {
    data: GradeCreateManyTeacherInput | GradeCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutTeacherInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    classes?: AssignmentClassCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutTeacherInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: AssignmentClassUncheckedCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutTeacherInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type AssignmentCreateManyTeacherInputEnvelope = {
    data: AssignmentCreateManyTeacherInput | AssignmentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutTeacherInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceRecordsInput
    class?: ClassCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutTeacherInput = {
    id?: string
    studentId: string
    classId?: string | null
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutTeacherInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutTeacherInput, AttendanceRecordUncheckedCreateWithoutTeacherInput>
  }

  export type AttendanceRecordCreateManyTeacherInputEnvelope = {
    data: AttendanceRecordCreateManyTeacherInput | AttendanceRecordCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutTeacherInput = {
    id?: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutSchedulesInput
    subject: SubjectCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutTeacherInput = {
    id?: string
    classId: string
    subjectId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutTeacherInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutTeacherInput, ScheduleUncheckedCreateWithoutTeacherInput>
  }

  export type ScheduleCreateManyTeacherInputEnvelope = {
    data: ScheduleCreateManyTeacherInput | ScheduleCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type VirtualClassCreateWithoutTeacherInput = {
    id?: string
    title: string
    description: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutVirtualClassesInput
    classes?: VirtualClassParticipantCreateNestedManyWithoutVirtualClassInput
  }

  export type VirtualClassUncheckedCreateWithoutTeacherInput = {
    id?: string
    title: string
    description: string
    subjectId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: VirtualClassParticipantUncheckedCreateNestedManyWithoutVirtualClassInput
  }

  export type VirtualClassCreateOrConnectWithoutTeacherInput = {
    where: VirtualClassWhereUniqueInput
    create: XOR<VirtualClassCreateWithoutTeacherInput, VirtualClassUncheckedCreateWithoutTeacherInput>
  }

  export type VirtualClassCreateManyTeacherInputEnvelope = {
    data: VirtualClassCreateManyTeacherInput | VirtualClassCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type LearningResourceCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subject: SubjectCreateNestedOneWithoutResourcesInput
  }

  export type LearningResourceUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    subjectId: string
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningResourceCreateOrConnectWithoutCreatedByInput = {
    where: LearningResourceWhereUniqueInput
    create: XOR<LearningResourceCreateWithoutCreatedByInput, LearningResourceUncheckedCreateWithoutCreatedByInput>
  }

  export type LearningResourceCreateManyCreatedByInputEnvelope = {
    data: LearningResourceCreateManyCreatedByInput | LearningResourceCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BehaviorRecordCreateWithoutTeacherInput = {
    id?: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutBehaviorRecordsInput
  }

  export type BehaviorRecordUncheckedCreateWithoutTeacherInput = {
    id?: string
    studentId: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorRecordCreateOrConnectWithoutTeacherInput = {
    where: BehaviorRecordWhereUniqueInput
    create: XOR<BehaviorRecordCreateWithoutTeacherInput, BehaviorRecordUncheckedCreateWithoutTeacherInput>
  }

  export type BehaviorRecordCreateManyTeacherInputEnvelope = {
    data: BehaviorRecordCreateManyTeacherInput | BehaviorRecordCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTeacherInput = {
    update: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
    create: XOR<UserCreateWithoutTeacherInput, UserUncheckedCreateWithoutTeacherInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherInput, UserUncheckedUpdateWithoutTeacherInput>
  }

  export type UserUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherSubjectCreateWithoutTeacherInput, TeacherSubjectUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutTeacherInput, TeacherSubjectUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherSubjectScalarWhereInput = {
    AND?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    OR?: TeacherSubjectScalarWhereInput[]
    NOT?: TeacherSubjectScalarWhereInput | TeacherSubjectScalarWhereInput[]
    teacherId?: StringFilter<"TeacherSubject"> | string
    subjectId?: StringFilter<"TeacherSubject"> | string
  }

  export type TeacherClassUpsertWithWhereUniqueWithoutTeacherInput = {
    where: TeacherClassWhereUniqueInput
    update: XOR<TeacherClassUpdateWithoutTeacherInput, TeacherClassUncheckedUpdateWithoutTeacherInput>
    create: XOR<TeacherClassCreateWithoutTeacherInput, TeacherClassUncheckedCreateWithoutTeacherInput>
  }

  export type TeacherClassUpdateWithWhereUniqueWithoutTeacherInput = {
    where: TeacherClassWhereUniqueInput
    data: XOR<TeacherClassUpdateWithoutTeacherInput, TeacherClassUncheckedUpdateWithoutTeacherInput>
  }

  export type TeacherClassUpdateManyWithWhereWithoutTeacherInput = {
    where: TeacherClassScalarWhereInput
    data: XOR<TeacherClassUpdateManyMutationInput, TeacherClassUncheckedUpdateManyWithoutTeacherInput>
  }

  export type TeacherClassScalarWhereInput = {
    AND?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
    OR?: TeacherClassScalarWhereInput[]
    NOT?: TeacherClassScalarWhereInput | TeacherClassScalarWhereInput[]
    teacherId?: StringFilter<"TeacherClass"> | string
    classId?: StringFilter<"TeacherClass"> | string
    isMainTeacher?: BoolFilter<"TeacherClass"> | boolean
  }

  export type GradeUpsertWithWhereUniqueWithoutTeacherInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutTeacherInput, GradeUncheckedUpdateWithoutTeacherInput>
    create: XOR<GradeCreateWithoutTeacherInput, GradeUncheckedCreateWithoutTeacherInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutTeacherInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutTeacherInput, GradeUncheckedUpdateWithoutTeacherInput>
  }

  export type GradeUpdateManyWithWhereWithoutTeacherInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutTeacherInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutTeacherInput, AssignmentUncheckedUpdateWithoutTeacherInput>
    create: XOR<AssignmentCreateWithoutTeacherInput, AssignmentUncheckedCreateWithoutTeacherInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutTeacherInput, AssignmentUncheckedUpdateWithoutTeacherInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutTeacherInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type AssignmentScalarWhereInput = {
    AND?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    OR?: AssignmentScalarWhereInput[]
    NOT?: AssignmentScalarWhereInput | AssignmentScalarWhereInput[]
    id?: StringFilter<"Assignment"> | string
    title?: StringFilter<"Assignment"> | string
    description?: StringFilter<"Assignment"> | string
    instructions?: StringFilter<"Assignment"> | string
    type?: EnumAssignmentTypeFilter<"Assignment"> | $Enums.AssignmentType
    priority?: EnumPriorityFilter<"Assignment"> | $Enums.Priority
    maxGrade?: FloatFilter<"Assignment"> | number
    dueDate?: DateTimeFilter<"Assignment"> | Date | string
    submissionFormat?: EnumSubmissionFormatFilter<"Assignment"> | $Enums.SubmissionFormat
    teacherId?: StringFilter<"Assignment"> | string
    subjectId?: StringFilter<"Assignment"> | string
    createdAt?: DateTimeFilter<"Assignment"> | Date | string
    updatedAt?: DateTimeFilter<"Assignment"> | Date | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutTeacherInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutTeacherInput, AttendanceRecordUncheckedUpdateWithoutTeacherInput>
    create: XOR<AttendanceRecordCreateWithoutTeacherInput, AttendanceRecordUncheckedCreateWithoutTeacherInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutTeacherInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutTeacherInput, AttendanceRecordUncheckedUpdateWithoutTeacherInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutTeacherInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutTeacherInput, ScheduleUncheckedUpdateWithoutTeacherInput>
    create: XOR<ScheduleCreateWithoutTeacherInput, ScheduleUncheckedCreateWithoutTeacherInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutTeacherInput, ScheduleUncheckedUpdateWithoutTeacherInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutTeacherInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    classId?: StringFilter<"Schedule"> | string
    teacherId?: StringFilter<"Schedule"> | string
    subjectId?: StringFilter<"Schedule"> | string
    room?: StringFilter<"Schedule"> | string
    dayOfWeek?: IntFilter<"Schedule"> | number
    startTime?: StringFilter<"Schedule"> | string
    endTime?: StringFilter<"Schedule"> | string
    duration?: IntFilter<"Schedule"> | number
    academicYear?: StringFilter<"Schedule"> | string
    semester?: StringFilter<"Schedule"> | string
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type VirtualClassUpsertWithWhereUniqueWithoutTeacherInput = {
    where: VirtualClassWhereUniqueInput
    update: XOR<VirtualClassUpdateWithoutTeacherInput, VirtualClassUncheckedUpdateWithoutTeacherInput>
    create: XOR<VirtualClassCreateWithoutTeacherInput, VirtualClassUncheckedCreateWithoutTeacherInput>
  }

  export type VirtualClassUpdateWithWhereUniqueWithoutTeacherInput = {
    where: VirtualClassWhereUniqueInput
    data: XOR<VirtualClassUpdateWithoutTeacherInput, VirtualClassUncheckedUpdateWithoutTeacherInput>
  }

  export type VirtualClassUpdateManyWithWhereWithoutTeacherInput = {
    where: VirtualClassScalarWhereInput
    data: XOR<VirtualClassUpdateManyMutationInput, VirtualClassUncheckedUpdateManyWithoutTeacherInput>
  }

  export type VirtualClassScalarWhereInput = {
    AND?: VirtualClassScalarWhereInput | VirtualClassScalarWhereInput[]
    OR?: VirtualClassScalarWhereInput[]
    NOT?: VirtualClassScalarWhereInput | VirtualClassScalarWhereInput[]
    id?: StringFilter<"VirtualClass"> | string
    title?: StringFilter<"VirtualClass"> | string
    description?: StringFilter<"VirtualClass"> | string
    teacherId?: StringFilter<"VirtualClass"> | string
    subjectId?: StringFilter<"VirtualClass"> | string
    scheduledStart?: DateTimeFilter<"VirtualClass"> | Date | string
    scheduledEnd?: DateTimeFilter<"VirtualClass"> | Date | string
    meetingUrl?: StringFilter<"VirtualClass"> | string
    recordingUrl?: StringNullableFilter<"VirtualClass"> | string | null
    status?: EnumVirtualClassStatusFilter<"VirtualClass"> | $Enums.VirtualClassStatus
    createdAt?: DateTimeFilter<"VirtualClass"> | Date | string
    updatedAt?: DateTimeFilter<"VirtualClass"> | Date | string
  }

  export type LearningResourceUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LearningResourceWhereUniqueInput
    update: XOR<LearningResourceUpdateWithoutCreatedByInput, LearningResourceUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LearningResourceCreateWithoutCreatedByInput, LearningResourceUncheckedCreateWithoutCreatedByInput>
  }

  export type LearningResourceUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LearningResourceWhereUniqueInput
    data: XOR<LearningResourceUpdateWithoutCreatedByInput, LearningResourceUncheckedUpdateWithoutCreatedByInput>
  }

  export type LearningResourceUpdateManyWithWhereWithoutCreatedByInput = {
    where: LearningResourceScalarWhereInput
    data: XOR<LearningResourceUpdateManyMutationInput, LearningResourceUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LearningResourceScalarWhereInput = {
    AND?: LearningResourceScalarWhereInput | LearningResourceScalarWhereInput[]
    OR?: LearningResourceScalarWhereInput[]
    NOT?: LearningResourceScalarWhereInput | LearningResourceScalarWhereInput[]
    id?: StringFilter<"LearningResource"> | string
    title?: StringFilter<"LearningResource"> | string
    description?: StringFilter<"LearningResource"> | string
    type?: EnumResourceTypeFilter<"LearningResource"> | $Enums.ResourceType
    subjectId?: StringFilter<"LearningResource"> | string
    level?: StringFilter<"LearningResource"> | string
    url?: StringFilter<"LearningResource"> | string
    thumbnail?: StringNullableFilter<"LearningResource"> | string | null
    duration?: IntNullableFilter<"LearningResource"> | number | null
    tags?: StringNullableListFilter<"LearningResource">
    createdById?: StringFilter<"LearningResource"> | string
    accessLevel?: EnumAccessLevelFilter<"LearningResource"> | $Enums.AccessLevel
    downloadable?: BoolFilter<"LearningResource"> | boolean
    createdAt?: DateTimeFilter<"LearningResource"> | Date | string
    updatedAt?: DateTimeFilter<"LearningResource"> | Date | string
  }

  export type BehaviorRecordUpsertWithWhereUniqueWithoutTeacherInput = {
    where: BehaviorRecordWhereUniqueInput
    update: XOR<BehaviorRecordUpdateWithoutTeacherInput, BehaviorRecordUncheckedUpdateWithoutTeacherInput>
    create: XOR<BehaviorRecordCreateWithoutTeacherInput, BehaviorRecordUncheckedCreateWithoutTeacherInput>
  }

  export type BehaviorRecordUpdateWithWhereUniqueWithoutTeacherInput = {
    where: BehaviorRecordWhereUniqueInput
    data: XOR<BehaviorRecordUpdateWithoutTeacherInput, BehaviorRecordUncheckedUpdateWithoutTeacherInput>
  }

  export type BehaviorRecordUpdateManyWithWhereWithoutTeacherInput = {
    where: BehaviorRecordScalarWhereInput
    data: XOR<BehaviorRecordUpdateManyMutationInput, BehaviorRecordUncheckedUpdateManyWithoutTeacherInput>
  }

  export type UserCreateWithoutParentInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutParentInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutParentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
  }

  export type StudentCreateWithoutParentsInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentsInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type AdmissionApplicationCreateWithoutParentInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: FileAttachmentCreateNestedManyWithoutAdmissionInput
    stepProgress?: AdmissionStepProgressCreateNestedManyWithoutApplicationInput
  }

  export type AdmissionApplicationUncheckedCreateWithoutParentInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: FileAttachmentUncheckedCreateNestedManyWithoutAdmissionInput
    stepProgress?: AdmissionStepProgressUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type AdmissionApplicationCreateOrConnectWithoutParentInput = {
    where: AdmissionApplicationWhereUniqueInput
    create: XOR<AdmissionApplicationCreateWithoutParentInput, AdmissionApplicationUncheckedCreateWithoutParentInput>
  }

  export type AdmissionApplicationCreateManyParentInputEnvelope = {
    data: AdmissionApplicationCreateManyParentInput | AdmissionApplicationCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutParentInput = {
    update: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
    create: XOR<UserCreateWithoutParentInput, UserUncheckedCreateWithoutParentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParentInput, UserUncheckedUpdateWithoutParentInput>
  }

  export type UserUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutParentsInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutParentsInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type StudentUpdateManyWithWhereWithoutParentsInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutParentsInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    studentId?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    classId?: StringNullableFilter<"Student"> | string | null
    parentIds?: StringNullableListFilter<"Student">
    admissionDate?: DateTimeFilter<"Student"> | Date | string
    academicYear?: StringFilter<"Student"> | string
    allergies?: StringNullableListFilter<"Student">
    medications?: StringNullableListFilter<"Student">
    emergencyMedicalContact?: StringNullableFilter<"Student"> | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type AdmissionApplicationUpsertWithWhereUniqueWithoutParentInput = {
    where: AdmissionApplicationWhereUniqueInput
    update: XOR<AdmissionApplicationUpdateWithoutParentInput, AdmissionApplicationUncheckedUpdateWithoutParentInput>
    create: XOR<AdmissionApplicationCreateWithoutParentInput, AdmissionApplicationUncheckedCreateWithoutParentInput>
  }

  export type AdmissionApplicationUpdateWithWhereUniqueWithoutParentInput = {
    where: AdmissionApplicationWhereUniqueInput
    data: XOR<AdmissionApplicationUpdateWithoutParentInput, AdmissionApplicationUncheckedUpdateWithoutParentInput>
  }

  export type AdmissionApplicationUpdateManyWithWhereWithoutParentInput = {
    where: AdmissionApplicationScalarWhereInput
    data: XOR<AdmissionApplicationUpdateManyMutationInput, AdmissionApplicationUncheckedUpdateManyWithoutParentInput>
  }

  export type AdmissionApplicationScalarWhereInput = {
    AND?: AdmissionApplicationScalarWhereInput | AdmissionApplicationScalarWhereInput[]
    OR?: AdmissionApplicationScalarWhereInput[]
    NOT?: AdmissionApplicationScalarWhereInput | AdmissionApplicationScalarWhereInput[]
    id?: StringFilter<"AdmissionApplication"> | string
    applicationNumber?: StringFilter<"AdmissionApplication"> | string
    firstName?: StringFilter<"AdmissionApplication"> | string
    lastName?: StringFilter<"AdmissionApplication"> | string
    dateOfBirth?: DateTimeFilter<"AdmissionApplication"> | Date | string
    gender?: EnumGenderFilter<"AdmissionApplication"> | $Enums.Gender
    nationality?: StringFilter<"AdmissionApplication"> | string
    previousSchool?: StringNullableFilter<"AdmissionApplication"> | string | null
    desiredClass?: StringFilter<"AdmissionApplication"> | string
    academicYear?: StringFilter<"AdmissionApplication"> | string
    specialNeeds?: StringNullableFilter<"AdmissionApplication"> | string | null
    parentId?: StringNullableFilter<"AdmissionApplication"> | string | null
    fatherName?: StringFilter<"AdmissionApplication"> | string
    fatherEmail?: StringFilter<"AdmissionApplication"> | string
    fatherPhone?: StringFilter<"AdmissionApplication"> | string
    fatherOccupation?: StringNullableFilter<"AdmissionApplication"> | string | null
    motherName?: StringFilter<"AdmissionApplication"> | string
    motherEmail?: StringFilter<"AdmissionApplication"> | string
    motherPhone?: StringFilter<"AdmissionApplication"> | string
    motherOccupation?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianName?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianEmail?: StringNullableFilter<"AdmissionApplication"> | string | null
    guardianPhone?: StringNullableFilter<"AdmissionApplication"> | string | null
    familyAddress?: StringFilter<"AdmissionApplication"> | string
    status?: EnumAdmissionStatusFilter<"AdmissionApplication"> | $Enums.AdmissionStatus
    submittedAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"AdmissionApplication"> | Date | string | null
    reviewedBy?: StringNullableFilter<"AdmissionApplication"> | string | null
    notes?: StringNullableFilter<"AdmissionApplication"> | string | null
    createdAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionApplication"> | Date | string
  }

  export type UserCreateWithoutAdminInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
  }

  export type UserUpsertWithoutAdminInput = {
    update: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
    create: XOR<UserCreateWithoutAdminInput, UserUncheckedCreateWithoutAdminInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminInput, UserUncheckedUpdateWithoutAdminInput>
  }

  export type UserUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentCreateWithoutClassInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    userId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutClassInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentCreateManyClassInputEnvelope = {
    data: StudentCreateManyClassInput | StudentCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type TeacherClassCreateWithoutClassInput = {
    isMainTeacher?: boolean
    teacher: TeacherCreateNestedOneWithoutClassesInput
  }

  export type TeacherClassUncheckedCreateWithoutClassInput = {
    teacherId: string
    isMainTeacher?: boolean
  }

  export type TeacherClassCreateOrConnectWithoutClassInput = {
    where: TeacherClassWhereUniqueInput
    create: XOR<TeacherClassCreateWithoutClassInput, TeacherClassUncheckedCreateWithoutClassInput>
  }

  export type TeacherClassCreateManyClassInputEnvelope = {
    data: TeacherClassCreateManyClassInput | TeacherClassCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ClassSubjectCreateWithoutClassInput = {
    subject: SubjectCreateNestedOneWithoutClassesInput
  }

  export type ClassSubjectUncheckedCreateWithoutClassInput = {
    subjectId: string
  }

  export type ClassSubjectCreateOrConnectWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    create: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type ClassSubjectCreateManyClassInputEnvelope = {
    data: ClassSubjectCreateManyClassInput | ClassSubjectCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutClassInput = {
    id?: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutSchedulesInput
    subject: SubjectCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutClassInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutClassInput, ScheduleUncheckedCreateWithoutClassInput>
  }

  export type ScheduleCreateManyClassInputEnvelope = {
    data: ScheduleCreateManyClassInput | ScheduleCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentClassCreateWithoutClassInput = {
    assignment: AssignmentCreateNestedOneWithoutClassesInput
  }

  export type AssignmentClassUncheckedCreateWithoutClassInput = {
    assignmentId: string
  }

  export type AssignmentClassCreateOrConnectWithoutClassInput = {
    where: AssignmentClassWhereUniqueInput
    create: XOR<AssignmentClassCreateWithoutClassInput, AssignmentClassUncheckedCreateWithoutClassInput>
  }

  export type AssignmentClassCreateManyClassInputEnvelope = {
    data: AssignmentClassCreateManyClassInput | AssignmentClassCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceRecordCreateWithoutClassInput = {
    id?: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAttendanceRecordsInput
    teacher: TeacherCreateNestedOneWithoutAttendanceRecordsInput
  }

  export type AttendanceRecordUncheckedCreateWithoutClassInput = {
    id?: string
    studentId: string
    teacherId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateOrConnectWithoutClassInput = {
    where: AttendanceRecordWhereUniqueInput
    create: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput>
  }

  export type AttendanceRecordCreateManyClassInputEnvelope = {
    data: AttendanceRecordCreateManyClassInput | AttendanceRecordCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type VirtualClassParticipantCreateWithoutClassInput = {
    id?: string
    virtualClass: VirtualClassCreateNestedOneWithoutClassesInput
  }

  export type VirtualClassParticipantUncheckedCreateWithoutClassInput = {
    id?: string
    virtualClassId: string
  }

  export type VirtualClassParticipantCreateOrConnectWithoutClassInput = {
    where: VirtualClassParticipantWhereUniqueInput
    create: XOR<VirtualClassParticipantCreateWithoutClassInput, VirtualClassParticipantUncheckedCreateWithoutClassInput>
  }

  export type VirtualClassParticipantCreateManyClassInputEnvelope = {
    data: VirtualClassParticipantCreateManyClassInput | VirtualClassParticipantCreateManyClassInput[]
    skipDuplicates?: boolean
  }

  export type StudentUpsertWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
    create: XOR<StudentCreateWithoutClassInput, StudentUncheckedCreateWithoutClassInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutClassInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutClassInput, StudentUncheckedUpdateWithoutClassInput>
  }

  export type StudentUpdateManyWithWhereWithoutClassInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutClassInput>
  }

  export type TeacherClassUpsertWithWhereUniqueWithoutClassInput = {
    where: TeacherClassWhereUniqueInput
    update: XOR<TeacherClassUpdateWithoutClassInput, TeacherClassUncheckedUpdateWithoutClassInput>
    create: XOR<TeacherClassCreateWithoutClassInput, TeacherClassUncheckedCreateWithoutClassInput>
  }

  export type TeacherClassUpdateWithWhereUniqueWithoutClassInput = {
    where: TeacherClassWhereUniqueInput
    data: XOR<TeacherClassUpdateWithoutClassInput, TeacherClassUncheckedUpdateWithoutClassInput>
  }

  export type TeacherClassUpdateManyWithWhereWithoutClassInput = {
    where: TeacherClassScalarWhereInput
    data: XOR<TeacherClassUpdateManyMutationInput, TeacherClassUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSubjectUpsertWithWhereUniqueWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    update: XOR<ClassSubjectUpdateWithoutClassInput, ClassSubjectUncheckedUpdateWithoutClassInput>
    create: XOR<ClassSubjectCreateWithoutClassInput, ClassSubjectUncheckedCreateWithoutClassInput>
  }

  export type ClassSubjectUpdateWithWhereUniqueWithoutClassInput = {
    where: ClassSubjectWhereUniqueInput
    data: XOR<ClassSubjectUpdateWithoutClassInput, ClassSubjectUncheckedUpdateWithoutClassInput>
  }

  export type ClassSubjectUpdateManyWithWhereWithoutClassInput = {
    where: ClassSubjectScalarWhereInput
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyWithoutClassInput>
  }

  export type ClassSubjectScalarWhereInput = {
    AND?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
    OR?: ClassSubjectScalarWhereInput[]
    NOT?: ClassSubjectScalarWhereInput | ClassSubjectScalarWhereInput[]
    classId?: StringFilter<"ClassSubject"> | string
    subjectId?: StringFilter<"ClassSubject"> | string
  }

  export type ScheduleUpsertWithWhereUniqueWithoutClassInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutClassInput, ScheduleUncheckedUpdateWithoutClassInput>
    create: XOR<ScheduleCreateWithoutClassInput, ScheduleUncheckedCreateWithoutClassInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutClassInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutClassInput, ScheduleUncheckedUpdateWithoutClassInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutClassInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutClassInput>
  }

  export type AssignmentClassUpsertWithWhereUniqueWithoutClassInput = {
    where: AssignmentClassWhereUniqueInput
    update: XOR<AssignmentClassUpdateWithoutClassInput, AssignmentClassUncheckedUpdateWithoutClassInput>
    create: XOR<AssignmentClassCreateWithoutClassInput, AssignmentClassUncheckedCreateWithoutClassInput>
  }

  export type AssignmentClassUpdateWithWhereUniqueWithoutClassInput = {
    where: AssignmentClassWhereUniqueInput
    data: XOR<AssignmentClassUpdateWithoutClassInput, AssignmentClassUncheckedUpdateWithoutClassInput>
  }

  export type AssignmentClassUpdateManyWithWhereWithoutClassInput = {
    where: AssignmentClassScalarWhereInput
    data: XOR<AssignmentClassUpdateManyMutationInput, AssignmentClassUncheckedUpdateManyWithoutClassInput>
  }

  export type AssignmentClassScalarWhereInput = {
    AND?: AssignmentClassScalarWhereInput | AssignmentClassScalarWhereInput[]
    OR?: AssignmentClassScalarWhereInput[]
    NOT?: AssignmentClassScalarWhereInput | AssignmentClassScalarWhereInput[]
    assignmentId?: StringFilter<"AssignmentClass"> | string
    classId?: StringFilter<"AssignmentClass"> | string
  }

  export type AttendanceRecordUpsertWithWhereUniqueWithoutClassInput = {
    where: AttendanceRecordWhereUniqueInput
    update: XOR<AttendanceRecordUpdateWithoutClassInput, AttendanceRecordUncheckedUpdateWithoutClassInput>
    create: XOR<AttendanceRecordCreateWithoutClassInput, AttendanceRecordUncheckedCreateWithoutClassInput>
  }

  export type AttendanceRecordUpdateWithWhereUniqueWithoutClassInput = {
    where: AttendanceRecordWhereUniqueInput
    data: XOR<AttendanceRecordUpdateWithoutClassInput, AttendanceRecordUncheckedUpdateWithoutClassInput>
  }

  export type AttendanceRecordUpdateManyWithWhereWithoutClassInput = {
    where: AttendanceRecordScalarWhereInput
    data: XOR<AttendanceRecordUpdateManyMutationInput, AttendanceRecordUncheckedUpdateManyWithoutClassInput>
  }

  export type VirtualClassParticipantUpsertWithWhereUniqueWithoutClassInput = {
    where: VirtualClassParticipantWhereUniqueInput
    update: XOR<VirtualClassParticipantUpdateWithoutClassInput, VirtualClassParticipantUncheckedUpdateWithoutClassInput>
    create: XOR<VirtualClassParticipantCreateWithoutClassInput, VirtualClassParticipantUncheckedCreateWithoutClassInput>
  }

  export type VirtualClassParticipantUpdateWithWhereUniqueWithoutClassInput = {
    where: VirtualClassParticipantWhereUniqueInput
    data: XOR<VirtualClassParticipantUpdateWithoutClassInput, VirtualClassParticipantUncheckedUpdateWithoutClassInput>
  }

  export type VirtualClassParticipantUpdateManyWithWhereWithoutClassInput = {
    where: VirtualClassParticipantScalarWhereInput
    data: XOR<VirtualClassParticipantUpdateManyMutationInput, VirtualClassParticipantUncheckedUpdateManyWithoutClassInput>
  }

  export type VirtualClassParticipantScalarWhereInput = {
    AND?: VirtualClassParticipantScalarWhereInput | VirtualClassParticipantScalarWhereInput[]
    OR?: VirtualClassParticipantScalarWhereInput[]
    NOT?: VirtualClassParticipantScalarWhereInput | VirtualClassParticipantScalarWhereInput[]
    id?: StringFilter<"VirtualClassParticipant"> | string
    virtualClassId?: StringFilter<"VirtualClassParticipant"> | string
    classId?: StringFilter<"VirtualClassParticipant"> | string
  }

  export type TeacherSubjectCreateWithoutSubjectInput = {
    teacher: TeacherCreateNestedOneWithoutSubjectsInput
  }

  export type TeacherSubjectUncheckedCreateWithoutSubjectInput = {
    teacherId: string
  }

  export type TeacherSubjectCreateOrConnectWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    create: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherSubjectCreateManySubjectInputEnvelope = {
    data: TeacherSubjectCreateManySubjectInput | TeacherSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ClassSubjectCreateWithoutSubjectInput = {
    class: ClassCreateNestedOneWithoutSubjectsInput
  }

  export type ClassSubjectUncheckedCreateWithoutSubjectInput = {
    classId: string
  }

  export type ClassSubjectCreateOrConnectWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    create: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type ClassSubjectCreateManySubjectInputEnvelope = {
    data: ClassSubjectCreateManySubjectInput | ClassSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type GradeCreateWithoutSubjectInput = {
    id?: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutGradesInput
    teacher: TeacherCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutSubjectInput = {
    id?: string
    studentId: string
    teacherId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutSubjectInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutSubjectInput, GradeUncheckedCreateWithoutSubjectInput>
  }

  export type GradeCreateManySubjectInputEnvelope = {
    data: GradeCreateManySubjectInput | GradeCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentCreateWithoutSubjectInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutAssignmentsInput
    classes?: AssignmentClassCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: AssignmentClassUncheckedCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutSubjectInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput>
  }

  export type AssignmentCreateManySubjectInputEnvelope = {
    data: AssignmentCreateManySubjectInput | AssignmentCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutSubjectInput = {
    id?: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
    class: ClassCreateNestedOneWithoutSchedulesInput
    teacher: TeacherCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutSubjectInput = {
    id?: string
    classId: string
    teacherId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutSubjectInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutSubjectInput, ScheduleUncheckedCreateWithoutSubjectInput>
  }

  export type ScheduleCreateManySubjectInputEnvelope = {
    data: ScheduleCreateManySubjectInput | ScheduleCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type LearningResourceCreateWithoutSubjectInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: TeacherCreateNestedOneWithoutResourcesInput
  }

  export type LearningResourceUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    createdById: string
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningResourceCreateOrConnectWithoutSubjectInput = {
    where: LearningResourceWhereUniqueInput
    create: XOR<LearningResourceCreateWithoutSubjectInput, LearningResourceUncheckedCreateWithoutSubjectInput>
  }

  export type LearningResourceCreateManySubjectInputEnvelope = {
    data: LearningResourceCreateManySubjectInput | LearningResourceCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type VirtualClassCreateWithoutSubjectInput = {
    id?: string
    title: string
    description: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutVirtualClassesInput
    classes?: VirtualClassParticipantCreateNestedManyWithoutVirtualClassInput
  }

  export type VirtualClassUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    description: string
    teacherId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: VirtualClassParticipantUncheckedCreateNestedManyWithoutVirtualClassInput
  }

  export type VirtualClassCreateOrConnectWithoutSubjectInput = {
    where: VirtualClassWhereUniqueInput
    create: XOR<VirtualClassCreateWithoutSubjectInput, VirtualClassUncheckedCreateWithoutSubjectInput>
  }

  export type VirtualClassCreateManySubjectInputEnvelope = {
    data: VirtualClassCreateManySubjectInput | VirtualClassCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type TeacherSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    update: XOR<TeacherSubjectUpdateWithoutSubjectInput, TeacherSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<TeacherSubjectCreateWithoutSubjectInput, TeacherSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type TeacherSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: TeacherSubjectWhereUniqueInput
    data: XOR<TeacherSubjectUpdateWithoutSubjectInput, TeacherSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type TeacherSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: TeacherSubjectScalarWhereInput
    data: XOR<TeacherSubjectUpdateManyMutationInput, TeacherSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ClassSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    update: XOR<ClassSubjectUpdateWithoutSubjectInput, ClassSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<ClassSubjectCreateWithoutSubjectInput, ClassSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type ClassSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ClassSubjectWhereUniqueInput
    data: XOR<ClassSubjectUpdateWithoutSubjectInput, ClassSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type ClassSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: ClassSubjectScalarWhereInput
    data: XOR<ClassSubjectUpdateManyMutationInput, ClassSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type GradeUpsertWithWhereUniqueWithoutSubjectInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutSubjectInput, GradeUncheckedUpdateWithoutSubjectInput>
    create: XOR<GradeCreateWithoutSubjectInput, GradeUncheckedCreateWithoutSubjectInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutSubjectInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutSubjectInput, GradeUncheckedUpdateWithoutSubjectInput>
  }

  export type GradeUpdateManyWithWhereWithoutSubjectInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutSubjectInput>
  }

  export type AssignmentUpsertWithWhereUniqueWithoutSubjectInput = {
    where: AssignmentWhereUniqueInput
    update: XOR<AssignmentUpdateWithoutSubjectInput, AssignmentUncheckedUpdateWithoutSubjectInput>
    create: XOR<AssignmentCreateWithoutSubjectInput, AssignmentUncheckedCreateWithoutSubjectInput>
  }

  export type AssignmentUpdateWithWhereUniqueWithoutSubjectInput = {
    where: AssignmentWhereUniqueInput
    data: XOR<AssignmentUpdateWithoutSubjectInput, AssignmentUncheckedUpdateWithoutSubjectInput>
  }

  export type AssignmentUpdateManyWithWhereWithoutSubjectInput = {
    where: AssignmentScalarWhereInput
    data: XOR<AssignmentUpdateManyMutationInput, AssignmentUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutSubjectInput, ScheduleUncheckedUpdateWithoutSubjectInput>
    create: XOR<ScheduleCreateWithoutSubjectInput, ScheduleUncheckedCreateWithoutSubjectInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutSubjectInput, ScheduleUncheckedUpdateWithoutSubjectInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutSubjectInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutSubjectInput>
  }

  export type LearningResourceUpsertWithWhereUniqueWithoutSubjectInput = {
    where: LearningResourceWhereUniqueInput
    update: XOR<LearningResourceUpdateWithoutSubjectInput, LearningResourceUncheckedUpdateWithoutSubjectInput>
    create: XOR<LearningResourceCreateWithoutSubjectInput, LearningResourceUncheckedCreateWithoutSubjectInput>
  }

  export type LearningResourceUpdateWithWhereUniqueWithoutSubjectInput = {
    where: LearningResourceWhereUniqueInput
    data: XOR<LearningResourceUpdateWithoutSubjectInput, LearningResourceUncheckedUpdateWithoutSubjectInput>
  }

  export type LearningResourceUpdateManyWithWhereWithoutSubjectInput = {
    where: LearningResourceScalarWhereInput
    data: XOR<LearningResourceUpdateManyMutationInput, LearningResourceUncheckedUpdateManyWithoutSubjectInput>
  }

  export type VirtualClassUpsertWithWhereUniqueWithoutSubjectInput = {
    where: VirtualClassWhereUniqueInput
    update: XOR<VirtualClassUpdateWithoutSubjectInput, VirtualClassUncheckedUpdateWithoutSubjectInput>
    create: XOR<VirtualClassCreateWithoutSubjectInput, VirtualClassUncheckedCreateWithoutSubjectInput>
  }

  export type VirtualClassUpdateWithWhereUniqueWithoutSubjectInput = {
    where: VirtualClassWhereUniqueInput
    data: XOR<VirtualClassUpdateWithoutSubjectInput, VirtualClassUncheckedUpdateWithoutSubjectInput>
  }

  export type VirtualClassUpdateManyWithWhereWithoutSubjectInput = {
    where: VirtualClassScalarWhereInput
    data: XOR<VirtualClassUpdateManyMutationInput, VirtualClassUncheckedUpdateManyWithoutSubjectInput>
  }

  export type StudentCreateWithoutGradesInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutGradesInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutGradesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
  }

  export type SubjectCreateWithoutGradesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutGradesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutGradesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
  }

  export type TeacherCreateWithoutGradesInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutGradesInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutGradesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutGradesInput, TeacherUncheckedCreateWithoutGradesInput>
  }

  export type StudentUpsertWithoutGradesInput = {
    update: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
    create: XOR<StudentCreateWithoutGradesInput, StudentUncheckedCreateWithoutGradesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutGradesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutGradesInput, StudentUncheckedUpdateWithoutGradesInput>
  }

  export type StudentUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SubjectUpsertWithoutGradesInput = {
    update: XOR<SubjectUpdateWithoutGradesInput, SubjectUncheckedUpdateWithoutGradesInput>
    create: XOR<SubjectCreateWithoutGradesInput, SubjectUncheckedCreateWithoutGradesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutGradesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutGradesInput, SubjectUncheckedUpdateWithoutGradesInput>
  }

  export type SubjectUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeacherUpsertWithoutGradesInput = {
    update: XOR<TeacherUpdateWithoutGradesInput, TeacherUncheckedUpdateWithoutGradesInput>
    create: XOR<TeacherCreateWithoutGradesInput, TeacherUncheckedCreateWithoutGradesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutGradesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutGradesInput, TeacherUncheckedUpdateWithoutGradesInput>
  }

  export type TeacherUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutAssignmentsInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutAssignmentsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutAssignmentsInput, TeacherUncheckedCreateWithoutAssignmentsInput>
  }

  export type SubjectCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    grades?: GradeCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    grades?: GradeUncheckedCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutAssignmentsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
  }

  export type AssignmentClassCreateWithoutAssignmentInput = {
    class: ClassCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentClassUncheckedCreateWithoutAssignmentInput = {
    classId: string
  }

  export type AssignmentClassCreateOrConnectWithoutAssignmentInput = {
    where: AssignmentClassWhereUniqueInput
    create: XOR<AssignmentClassCreateWithoutAssignmentInput, AssignmentClassUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentClassCreateManyAssignmentInputEnvelope = {
    data: AssignmentClassCreateManyAssignmentInput | AssignmentClassCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentSubmissionCreateWithoutAssignmentInput = {
    id?: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutAssignmentsInput
    attachments?: FileAttachmentCreateNestedManyWithoutSubmissionInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutAssignmentInput = {
    id?: string
    studentId: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutSubmissionInput
  }

  export type AssignmentSubmissionCreateOrConnectWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionCreateManyAssignmentInputEnvelope = {
    data: AssignmentSubmissionCreateManyAssignmentInput | AssignmentSubmissionCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type FileAttachmentCreateWithoutAssignmentInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submission?: AssignmentSubmissionCreateNestedOneWithoutAttachmentsInput
    message?: MessageCreateNestedOneWithoutAttachmentsInput
    admission?: AdmissionApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type FileAttachmentUncheckedCreateWithoutAssignmentInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    submissionId?: string | null
    messageId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentCreateOrConnectWithoutAssignmentInput = {
    where: FileAttachmentWhereUniqueInput
    create: XOR<FileAttachmentCreateWithoutAssignmentInput, FileAttachmentUncheckedCreateWithoutAssignmentInput>
  }

  export type FileAttachmentCreateManyAssignmentInputEnvelope = {
    data: FileAttachmentCreateManyAssignmentInput | FileAttachmentCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type TeacherUpsertWithoutAssignmentsInput = {
    update: XOR<TeacherUpdateWithoutAssignmentsInput, TeacherUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<TeacherCreateWithoutAssignmentsInput, TeacherUncheckedCreateWithoutAssignmentsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutAssignmentsInput, TeacherUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TeacherUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SubjectUpsertWithoutAssignmentsInput = {
    update: XOR<SubjectUpdateWithoutAssignmentsInput, SubjectUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<SubjectCreateWithoutAssignmentsInput, SubjectUncheckedCreateWithoutAssignmentsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutAssignmentsInput, SubjectUncheckedUpdateWithoutAssignmentsInput>
  }

  export type SubjectUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    grades?: GradeUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type AssignmentClassUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentClassWhereUniqueInput
    update: XOR<AssignmentClassUpdateWithoutAssignmentInput, AssignmentClassUncheckedUpdateWithoutAssignmentInput>
    create: XOR<AssignmentClassCreateWithoutAssignmentInput, AssignmentClassUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentClassUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentClassWhereUniqueInput
    data: XOR<AssignmentClassUpdateWithoutAssignmentInput, AssignmentClassUncheckedUpdateWithoutAssignmentInput>
  }

  export type AssignmentClassUpdateManyWithWhereWithoutAssignmentInput = {
    where: AssignmentClassScalarWhereInput
    data: XOR<AssignmentClassUpdateManyMutationInput, AssignmentClassUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    update: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
    create: XOR<AssignmentSubmissionCreateWithoutAssignmentInput, AssignmentSubmissionUncheckedCreateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: AssignmentSubmissionWhereUniqueInput
    data: XOR<AssignmentSubmissionUpdateWithoutAssignmentInput, AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput>
  }

  export type AssignmentSubmissionUpdateManyWithWhereWithoutAssignmentInput = {
    where: AssignmentSubmissionScalarWhereInput
    data: XOR<AssignmentSubmissionUpdateManyMutationInput, AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type FileAttachmentUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: FileAttachmentWhereUniqueInput
    update: XOR<FileAttachmentUpdateWithoutAssignmentInput, FileAttachmentUncheckedUpdateWithoutAssignmentInput>
    create: XOR<FileAttachmentCreateWithoutAssignmentInput, FileAttachmentUncheckedCreateWithoutAssignmentInput>
  }

  export type FileAttachmentUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: FileAttachmentWhereUniqueInput
    data: XOR<FileAttachmentUpdateWithoutAssignmentInput, FileAttachmentUncheckedUpdateWithoutAssignmentInput>
  }

  export type FileAttachmentUpdateManyWithWhereWithoutAssignmentInput = {
    where: FileAttachmentScalarWhereInput
    data: XOR<FileAttachmentUpdateManyMutationInput, FileAttachmentUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type FileAttachmentScalarWhereInput = {
    AND?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
    OR?: FileAttachmentScalarWhereInput[]
    NOT?: FileAttachmentScalarWhereInput | FileAttachmentScalarWhereInput[]
    id?: StringFilter<"FileAttachment"> | string
    name?: StringFilter<"FileAttachment"> | string
    originalName?: StringFilter<"FileAttachment"> | string
    url?: StringFilter<"FileAttachment"> | string
    type?: StringFilter<"FileAttachment"> | string
    size?: IntFilter<"FileAttachment"> | number
    uploadedBy?: StringFilter<"FileAttachment"> | string
    assignmentId?: StringNullableFilter<"FileAttachment"> | string | null
    submissionId?: StringNullableFilter<"FileAttachment"> | string | null
    messageId?: StringNullableFilter<"FileAttachment"> | string | null
    admissionId?: StringNullableFilter<"FileAttachment"> | string | null
    createdAt?: DateTimeFilter<"FileAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"FileAttachment"> | Date | string
  }

  export type AssignmentCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutAssignmentsInput
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    classes?: AssignmentClassCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    teacherId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: AssignmentClassUncheckedCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutSubmissionsInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
  }

  export type StudentCreateWithoutAssignmentsInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAssignmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAssignmentsInput, StudentUncheckedCreateWithoutAssignmentsInput>
  }

  export type FileAttachmentCreateWithoutSubmissionInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutAttachmentsInput
    message?: MessageCreateNestedOneWithoutAttachmentsInput
    admission?: AdmissionApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type FileAttachmentUncheckedCreateWithoutSubmissionInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    messageId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentCreateOrConnectWithoutSubmissionInput = {
    where: FileAttachmentWhereUniqueInput
    create: XOR<FileAttachmentCreateWithoutSubmissionInput, FileAttachmentUncheckedCreateWithoutSubmissionInput>
  }

  export type FileAttachmentCreateManySubmissionInputEnvelope = {
    data: FileAttachmentCreateManySubmissionInput | FileAttachmentCreateManySubmissionInput[]
    skipDuplicates?: boolean
  }

  export type AssignmentUpsertWithoutSubmissionsInput = {
    update: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<AssignmentCreateWithoutSubmissionsInput, AssignmentUncheckedCreateWithoutSubmissionsInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutSubmissionsInput, AssignmentUncheckedUpdateWithoutSubmissionsInput>
  }

  export type AssignmentUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    classes?: AssignmentClassUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: AssignmentClassUncheckedUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type StudentUpsertWithoutAssignmentsInput = {
    update: XOR<StudentUpdateWithoutAssignmentsInput, StudentUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<StudentCreateWithoutAssignmentsInput, StudentUncheckedCreateWithoutAssignmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAssignmentsInput, StudentUncheckedUpdateWithoutAssignmentsInput>
  }

  export type StudentUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type FileAttachmentUpsertWithWhereUniqueWithoutSubmissionInput = {
    where: FileAttachmentWhereUniqueInput
    update: XOR<FileAttachmentUpdateWithoutSubmissionInput, FileAttachmentUncheckedUpdateWithoutSubmissionInput>
    create: XOR<FileAttachmentCreateWithoutSubmissionInput, FileAttachmentUncheckedCreateWithoutSubmissionInput>
  }

  export type FileAttachmentUpdateWithWhereUniqueWithoutSubmissionInput = {
    where: FileAttachmentWhereUniqueInput
    data: XOR<FileAttachmentUpdateWithoutSubmissionInput, FileAttachmentUncheckedUpdateWithoutSubmissionInput>
  }

  export type FileAttachmentUpdateManyWithWhereWithoutSubmissionInput = {
    where: FileAttachmentScalarWhereInput
    data: XOR<FileAttachmentUpdateManyMutationInput, FileAttachmentUncheckedUpdateManyWithoutSubmissionInput>
  }

  export type StudentCreateWithoutAttendanceRecordsInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAttendanceRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type ClassCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherClassCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    schedules?: ScheduleCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherClassUncheckedCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassUncheckedCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAttendanceRecordsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type TeacherCreateWithoutAttendanceRecordsInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutAttendanceRecordsInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutAttendanceRecordsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutAttendanceRecordsInput, TeacherUncheckedCreateWithoutAttendanceRecordsInput>
  }

  export type StudentUpsertWithoutAttendanceRecordsInput = {
    update: XOR<StudentUpdateWithoutAttendanceRecordsInput, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<StudentCreateWithoutAttendanceRecordsInput, StudentUncheckedCreateWithoutAttendanceRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAttendanceRecordsInput, StudentUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type StudentUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ClassUpsertWithoutAttendanceRecordsInput = {
    update: XOR<ClassUpdateWithoutAttendanceRecordsInput, ClassUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<ClassCreateWithoutAttendanceRecordsInput, ClassUncheckedCreateWithoutAttendanceRecordsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAttendanceRecordsInput, ClassUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type ClassUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUncheckedUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUncheckedUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeacherUpsertWithoutAttendanceRecordsInput = {
    update: XOR<TeacherUpdateWithoutAttendanceRecordsInput, TeacherUncheckedUpdateWithoutAttendanceRecordsInput>
    create: XOR<TeacherCreateWithoutAttendanceRecordsInput, TeacherUncheckedCreateWithoutAttendanceRecordsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutAttendanceRecordsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutAttendanceRecordsInput, TeacherUncheckedUpdateWithoutAttendanceRecordsInput>
  }

  export type TeacherUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutAttendanceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassCreateWithoutSchedulesInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherClassCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherClassUncheckedCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSchedulesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSchedulesInput, ClassUncheckedCreateWithoutSchedulesInput>
  }

  export type TeacherCreateWithoutSchedulesInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutSchedulesInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutSchedulesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutSchedulesInput, TeacherUncheckedCreateWithoutSchedulesInput>
  }

  export type SubjectCreateWithoutSchedulesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    grades?: GradeCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    grades?: GradeUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutSchedulesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutSchedulesInput, SubjectUncheckedCreateWithoutSchedulesInput>
  }

  export type ClassUpsertWithoutSchedulesInput = {
    update: XOR<ClassUpdateWithoutSchedulesInput, ClassUncheckedUpdateWithoutSchedulesInput>
    create: XOR<ClassCreateWithoutSchedulesInput, ClassUncheckedCreateWithoutSchedulesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSchedulesInput, ClassUncheckedUpdateWithoutSchedulesInput>
  }

  export type ClassUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUncheckedUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput
  }

  export type TeacherUpsertWithoutSchedulesInput = {
    update: XOR<TeacherUpdateWithoutSchedulesInput, TeacherUncheckedUpdateWithoutSchedulesInput>
    create: XOR<TeacherCreateWithoutSchedulesInput, TeacherUncheckedCreateWithoutSchedulesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutSchedulesInput, TeacherUncheckedUpdateWithoutSchedulesInput>
  }

  export type TeacherUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SubjectUpsertWithoutSchedulesInput = {
    update: XOR<SubjectUpdateWithoutSchedulesInput, SubjectUncheckedUpdateWithoutSchedulesInput>
    create: XOR<SubjectCreateWithoutSchedulesInput, SubjectUncheckedCreateWithoutSchedulesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutSchedulesInput, SubjectUncheckedUpdateWithoutSchedulesInput>
  }

  export type SubjectUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    grades?: GradeUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type MessageCreateWithoutRepliesInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipients?: UserCreateNestedManyWithoutReceivedMessagesInput
    parentMessage?: MessageCreateNestedOneWithoutRepliesInput
    attachments?: FileAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutRepliesInput = {
    id?: string
    senderId: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: UserUncheckedCreateNestedManyWithoutReceivedMessagesInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutRepliesInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
  }

  export type MessageCreateWithoutParentMessageInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipients?: UserCreateNestedManyWithoutReceivedMessagesInput
    replies?: MessageCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutParentMessageInput = {
    id?: string
    senderId: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: UserUncheckedCreateNestedManyWithoutReceivedMessagesInput
    replies?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutParentMessageInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput>
  }

  export type MessageCreateManyParentMessageInputEnvelope = {
    data: MessageCreateManyParentMessageInput | MessageCreateManyParentMessageInput[]
    skipDuplicates?: boolean
  }

  export type FileAttachmentCreateWithoutMessageInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutAttachmentsInput
    submission?: AssignmentSubmissionCreateNestedOneWithoutAttachmentsInput
    admission?: AdmissionApplicationCreateNestedOneWithoutDocumentsInput
  }

  export type FileAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    submissionId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentCreateOrConnectWithoutMessageInput = {
    where: FileAttachmentWhereUniqueInput
    create: XOR<FileAttachmentCreateWithoutMessageInput, FileAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type FileAttachmentCreateManyMessageInputEnvelope = {
    data: FileAttachmentCreateManyMessageInput | FileAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateManyWithWhereWithoutReceivedMessagesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutReceivedMessagesInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type MessageUpsertWithoutRepliesInput = {
    update: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
    create: XOR<MessageCreateWithoutRepliesInput, MessageUncheckedCreateWithoutRepliesInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRepliesInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRepliesInput, MessageUncheckedUpdateWithoutRepliesInput>
  }

  export type MessageUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipients?: UserUpdateManyWithoutReceivedMessagesNestedInput
    parentMessage?: MessageUpdateOneWithoutRepliesNestedInput
    attachments?: FileAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUncheckedUpdateManyWithoutReceivedMessagesNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutParentMessageInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutParentMessageInput, MessageUncheckedUpdateWithoutParentMessageInput>
    create: XOR<MessageCreateWithoutParentMessageInput, MessageUncheckedCreateWithoutParentMessageInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutParentMessageInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutParentMessageInput, MessageUncheckedUpdateWithoutParentMessageInput>
  }

  export type MessageUpdateManyWithWhereWithoutParentMessageInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutParentMessageInput>
  }

  export type FileAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: FileAttachmentWhereUniqueInput
    update: XOR<FileAttachmentUpdateWithoutMessageInput, FileAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<FileAttachmentCreateWithoutMessageInput, FileAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type FileAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: FileAttachmentWhereUniqueInput
    data: XOR<FileAttachmentUpdateWithoutMessageInput, FileAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type FileAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: FileAttachmentScalarWhereInput
    data: XOR<FileAttachmentUpdateManyMutationInput, FileAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type StudentCreateWithoutFinancialRecordsInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutFinancialRecordsInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutFinancialRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
  }

  export type StudentUpsertWithoutFinancialRecordsInput = {
    update: XOR<StudentUpdateWithoutFinancialRecordsInput, StudentUncheckedUpdateWithoutFinancialRecordsInput>
    create: XOR<StudentCreateWithoutFinancialRecordsInput, StudentUncheckedCreateWithoutFinancialRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutFinancialRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutFinancialRecordsInput, StudentUncheckedUpdateWithoutFinancialRecordsInput>
  }

  export type StudentUpdateWithoutFinancialRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutFinancialRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentCreateWithoutAdmissionApplicationsInput = {
    id?: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParentInput
    children?: StudentCreateNestedManyWithoutParentsInput
  }

  export type ParentUncheckedCreateWithoutAdmissionApplicationsInput = {
    id?: string
    userId: string
    occupation?: string | null
    preferredContactMethod?: $Enums.ContactMethod
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentUncheckedCreateNestedManyWithoutParentsInput
  }

  export type ParentCreateOrConnectWithoutAdmissionApplicationsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutAdmissionApplicationsInput, ParentUncheckedCreateWithoutAdmissionApplicationsInput>
  }

  export type FileAttachmentCreateWithoutAdmissionInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: AssignmentCreateNestedOneWithoutAttachmentsInput
    submission?: AssignmentSubmissionCreateNestedOneWithoutAttachmentsInput
    message?: MessageCreateNestedOneWithoutAttachmentsInput
  }

  export type FileAttachmentUncheckedCreateWithoutAdmissionInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    submissionId?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentCreateOrConnectWithoutAdmissionInput = {
    where: FileAttachmentWhereUniqueInput
    create: XOR<FileAttachmentCreateWithoutAdmissionInput, FileAttachmentUncheckedCreateWithoutAdmissionInput>
  }

  export type FileAttachmentCreateManyAdmissionInputEnvelope = {
    data: FileAttachmentCreateManyAdmissionInput | FileAttachmentCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionStepProgressCreateWithoutApplicationInput = {
    id?: string
    stepName: string
    status?: $Enums.StepStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    assignedTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionStepProgressUncheckedCreateWithoutApplicationInput = {
    id?: string
    stepName: string
    status?: $Enums.StepStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    assignedTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionStepProgressCreateOrConnectWithoutApplicationInput = {
    where: AdmissionStepProgressWhereUniqueInput
    create: XOR<AdmissionStepProgressCreateWithoutApplicationInput, AdmissionStepProgressUncheckedCreateWithoutApplicationInput>
  }

  export type AdmissionStepProgressCreateManyApplicationInputEnvelope = {
    data: AdmissionStepProgressCreateManyApplicationInput | AdmissionStepProgressCreateManyApplicationInput[]
    skipDuplicates?: boolean
  }

  export type ParentUpsertWithoutAdmissionApplicationsInput = {
    update: XOR<ParentUpdateWithoutAdmissionApplicationsInput, ParentUncheckedUpdateWithoutAdmissionApplicationsInput>
    create: XOR<ParentCreateWithoutAdmissionApplicationsInput, ParentUncheckedCreateWithoutAdmissionApplicationsInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutAdmissionApplicationsInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutAdmissionApplicationsInput, ParentUncheckedUpdateWithoutAdmissionApplicationsInput>
  }

  export type ParentUpdateWithoutAdmissionApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    children?: StudentUpdateManyWithoutParentsNestedInput
  }

  export type ParentUncheckedUpdateWithoutAdmissionApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentUncheckedUpdateManyWithoutParentsNestedInput
  }

  export type FileAttachmentUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: FileAttachmentWhereUniqueInput
    update: XOR<FileAttachmentUpdateWithoutAdmissionInput, FileAttachmentUncheckedUpdateWithoutAdmissionInput>
    create: XOR<FileAttachmentCreateWithoutAdmissionInput, FileAttachmentUncheckedCreateWithoutAdmissionInput>
  }

  export type FileAttachmentUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: FileAttachmentWhereUniqueInput
    data: XOR<FileAttachmentUpdateWithoutAdmissionInput, FileAttachmentUncheckedUpdateWithoutAdmissionInput>
  }

  export type FileAttachmentUpdateManyWithWhereWithoutAdmissionInput = {
    where: FileAttachmentScalarWhereInput
    data: XOR<FileAttachmentUpdateManyMutationInput, FileAttachmentUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type AdmissionStepProgressUpsertWithWhereUniqueWithoutApplicationInput = {
    where: AdmissionStepProgressWhereUniqueInput
    update: XOR<AdmissionStepProgressUpdateWithoutApplicationInput, AdmissionStepProgressUncheckedUpdateWithoutApplicationInput>
    create: XOR<AdmissionStepProgressCreateWithoutApplicationInput, AdmissionStepProgressUncheckedCreateWithoutApplicationInput>
  }

  export type AdmissionStepProgressUpdateWithWhereUniqueWithoutApplicationInput = {
    where: AdmissionStepProgressWhereUniqueInput
    data: XOR<AdmissionStepProgressUpdateWithoutApplicationInput, AdmissionStepProgressUncheckedUpdateWithoutApplicationInput>
  }

  export type AdmissionStepProgressUpdateManyWithWhereWithoutApplicationInput = {
    where: AdmissionStepProgressScalarWhereInput
    data: XOR<AdmissionStepProgressUpdateManyMutationInput, AdmissionStepProgressUncheckedUpdateManyWithoutApplicationInput>
  }

  export type AdmissionStepProgressScalarWhereInput = {
    AND?: AdmissionStepProgressScalarWhereInput | AdmissionStepProgressScalarWhereInput[]
    OR?: AdmissionStepProgressScalarWhereInput[]
    NOT?: AdmissionStepProgressScalarWhereInput | AdmissionStepProgressScalarWhereInput[]
    id?: StringFilter<"AdmissionStepProgress"> | string
    applicationId?: StringFilter<"AdmissionStepProgress"> | string
    stepName?: StringFilter<"AdmissionStepProgress"> | string
    status?: EnumStepStatusFilter<"AdmissionStepProgress"> | $Enums.StepStatus
    startedAt?: DateTimeNullableFilter<"AdmissionStepProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"AdmissionStepProgress"> | Date | string | null
    assignedTo?: StringNullableFilter<"AdmissionStepProgress"> | string | null
    notes?: StringNullableFilter<"AdmissionStepProgress"> | string | null
    createdAt?: DateTimeFilter<"AdmissionStepProgress"> | Date | string
    updatedAt?: DateTimeFilter<"AdmissionStepProgress"> | Date | string
  }

  export type AdmissionApplicationCreateWithoutStepProgressInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ParentCreateNestedOneWithoutAdmissionApplicationsInput
    documents?: FileAttachmentCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionApplicationUncheckedCreateWithoutStepProgressInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    parentId?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: FileAttachmentUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionApplicationCreateOrConnectWithoutStepProgressInput = {
    where: AdmissionApplicationWhereUniqueInput
    create: XOR<AdmissionApplicationCreateWithoutStepProgressInput, AdmissionApplicationUncheckedCreateWithoutStepProgressInput>
  }

  export type AdmissionApplicationUpsertWithoutStepProgressInput = {
    update: XOR<AdmissionApplicationUpdateWithoutStepProgressInput, AdmissionApplicationUncheckedUpdateWithoutStepProgressInput>
    create: XOR<AdmissionApplicationCreateWithoutStepProgressInput, AdmissionApplicationUncheckedCreateWithoutStepProgressInput>
    where?: AdmissionApplicationWhereInput
  }

  export type AdmissionApplicationUpdateToOneWithWhereWithoutStepProgressInput = {
    where?: AdmissionApplicationWhereInput
    data: XOR<AdmissionApplicationUpdateWithoutStepProgressInput, AdmissionApplicationUncheckedUpdateWithoutStepProgressInput>
  }

  export type AdmissionApplicationUpdateWithoutStepProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneWithoutAdmissionApplicationsNestedInput
    documents?: FileAttachmentUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionApplicationUncheckedUpdateWithoutStepProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FileAttachmentUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type SubjectCreateWithoutResourcesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    grades?: GradeCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutResourcesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    grades?: GradeUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutResourcesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutResourcesInput, SubjectUncheckedCreateWithoutResourcesInput>
  }

  export type TeacherCreateWithoutResourcesInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutResourcesInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutResourcesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutResourcesInput, TeacherUncheckedCreateWithoutResourcesInput>
  }

  export type SubjectUpsertWithoutResourcesInput = {
    update: XOR<SubjectUpdateWithoutResourcesInput, SubjectUncheckedUpdateWithoutResourcesInput>
    create: XOR<SubjectCreateWithoutResourcesInput, SubjectUncheckedCreateWithoutResourcesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutResourcesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutResourcesInput, SubjectUncheckedUpdateWithoutResourcesInput>
  }

  export type SubjectUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    grades?: GradeUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeacherUpsertWithoutResourcesInput = {
    update: XOR<TeacherUpdateWithoutResourcesInput, TeacherUncheckedUpdateWithoutResourcesInput>
    create: XOR<TeacherCreateWithoutResourcesInput, TeacherUncheckedCreateWithoutResourcesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutResourcesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutResourcesInput, TeacherUncheckedUpdateWithoutResourcesInput>
  }

  export type TeacherUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutResourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherCreateWithoutVirtualClassesInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutVirtualClassesInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutVirtualClassesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutVirtualClassesInput, TeacherUncheckedCreateWithoutVirtualClassesInput>
  }

  export type SubjectCreateWithoutVirtualClassesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    grades?: GradeCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutVirtualClassesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    grades?: GradeUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutVirtualClassesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutVirtualClassesInput, SubjectUncheckedCreateWithoutVirtualClassesInput>
  }

  export type VirtualClassParticipantCreateWithoutVirtualClassInput = {
    id?: string
    class: ClassCreateNestedOneWithoutVirtualClassesInput
  }

  export type VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput = {
    id?: string
    classId: string
  }

  export type VirtualClassParticipantCreateOrConnectWithoutVirtualClassInput = {
    where: VirtualClassParticipantWhereUniqueInput
    create: XOR<VirtualClassParticipantCreateWithoutVirtualClassInput, VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput>
  }

  export type VirtualClassParticipantCreateManyVirtualClassInputEnvelope = {
    data: VirtualClassParticipantCreateManyVirtualClassInput | VirtualClassParticipantCreateManyVirtualClassInput[]
    skipDuplicates?: boolean
  }

  export type TeacherUpsertWithoutVirtualClassesInput = {
    update: XOR<TeacherUpdateWithoutVirtualClassesInput, TeacherUncheckedUpdateWithoutVirtualClassesInput>
    create: XOR<TeacherCreateWithoutVirtualClassesInput, TeacherUncheckedCreateWithoutVirtualClassesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutVirtualClassesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutVirtualClassesInput, TeacherUncheckedUpdateWithoutVirtualClassesInput>
  }

  export type TeacherUpdateWithoutVirtualClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutVirtualClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SubjectUpsertWithoutVirtualClassesInput = {
    update: XOR<SubjectUpdateWithoutVirtualClassesInput, SubjectUncheckedUpdateWithoutVirtualClassesInput>
    create: XOR<SubjectCreateWithoutVirtualClassesInput, SubjectUncheckedCreateWithoutVirtualClassesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutVirtualClassesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutVirtualClassesInput, SubjectUncheckedUpdateWithoutVirtualClassesInput>
  }

  export type SubjectUpdateWithoutVirtualClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    grades?: GradeUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutVirtualClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type VirtualClassParticipantUpsertWithWhereUniqueWithoutVirtualClassInput = {
    where: VirtualClassParticipantWhereUniqueInput
    update: XOR<VirtualClassParticipantUpdateWithoutVirtualClassInput, VirtualClassParticipantUncheckedUpdateWithoutVirtualClassInput>
    create: XOR<VirtualClassParticipantCreateWithoutVirtualClassInput, VirtualClassParticipantUncheckedCreateWithoutVirtualClassInput>
  }

  export type VirtualClassParticipantUpdateWithWhereUniqueWithoutVirtualClassInput = {
    where: VirtualClassParticipantWhereUniqueInput
    data: XOR<VirtualClassParticipantUpdateWithoutVirtualClassInput, VirtualClassParticipantUncheckedUpdateWithoutVirtualClassInput>
  }

  export type VirtualClassParticipantUpdateManyWithWhereWithoutVirtualClassInput = {
    where: VirtualClassParticipantScalarWhereInput
    data: XOR<VirtualClassParticipantUpdateManyMutationInput, VirtualClassParticipantUncheckedUpdateManyWithoutVirtualClassInput>
  }

  export type VirtualClassCreateWithoutClassesInput = {
    id?: string
    title: string
    description: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutVirtualClassesInput
    subject: SubjectCreateNestedOneWithoutVirtualClassesInput
  }

  export type VirtualClassUncheckedCreateWithoutClassesInput = {
    id?: string
    title: string
    description: string
    teacherId: string
    subjectId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VirtualClassCreateOrConnectWithoutClassesInput = {
    where: VirtualClassWhereUniqueInput
    create: XOR<VirtualClassCreateWithoutClassesInput, VirtualClassUncheckedCreateWithoutClassesInput>
  }

  export type ClassCreateWithoutVirtualClassesInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherClassCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    schedules?: ScheduleCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutVirtualClassesInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherClassUncheckedCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutVirtualClassesInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutVirtualClassesInput, ClassUncheckedCreateWithoutVirtualClassesInput>
  }

  export type VirtualClassUpsertWithoutClassesInput = {
    update: XOR<VirtualClassUpdateWithoutClassesInput, VirtualClassUncheckedUpdateWithoutClassesInput>
    create: XOR<VirtualClassCreateWithoutClassesInput, VirtualClassUncheckedCreateWithoutClassesInput>
    where?: VirtualClassWhereInput
  }

  export type VirtualClassUpdateToOneWithWhereWithoutClassesInput = {
    where?: VirtualClassWhereInput
    data: XOR<VirtualClassUpdateWithoutClassesInput, VirtualClassUncheckedUpdateWithoutClassesInput>
  }

  export type VirtualClassUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutVirtualClassesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutVirtualClassesNestedInput
  }

  export type VirtualClassUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassUpsertWithoutVirtualClassesInput = {
    update: XOR<ClassUpdateWithoutVirtualClassesInput, ClassUncheckedUpdateWithoutVirtualClassesInput>
    create: XOR<ClassCreateWithoutVirtualClassesInput, ClassUncheckedCreateWithoutVirtualClassesInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutVirtualClassesInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutVirtualClassesInput, ClassUncheckedUpdateWithoutVirtualClassesInput>
  }

  export type ClassUpdateWithoutVirtualClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutVirtualClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUncheckedUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
  }

  export type StudentAchievementCreateWithoutAchievementInput = {
    id?: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
    student: StudentCreateNestedOneWithoutAchievementsInput
  }

  export type StudentAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    studentId: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
  }

  export type StudentAchievementCreateOrConnectWithoutAchievementInput = {
    where: StudentAchievementWhereUniqueInput
    create: XOR<StudentAchievementCreateWithoutAchievementInput, StudentAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type StudentAchievementCreateManyAchievementInputEnvelope = {
    data: StudentAchievementCreateManyAchievementInput | StudentAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type StudentAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: StudentAchievementWhereUniqueInput
    update: XOR<StudentAchievementUpdateWithoutAchievementInput, StudentAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<StudentAchievementCreateWithoutAchievementInput, StudentAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type StudentAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: StudentAchievementWhereUniqueInput
    data: XOR<StudentAchievementUpdateWithoutAchievementInput, StudentAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type StudentAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: StudentAchievementScalarWhereInput
    data: XOR<StudentAchievementUpdateManyMutationInput, StudentAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type StudentCreateWithoutAchievementsInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutAchievementsInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutAchievementsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutStudentsInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    points: number
    criteria?: AchievementCreatecriteriaInput | string[]
    rarity?: $Enums.Rarity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    description: string
    icon: string
    category: $Enums.AchievementCategory
    points: number
    criteria?: AchievementCreatecriteriaInput | string[]
    rarity?: $Enums.Rarity
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutStudentsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutStudentsInput, AchievementUncheckedCreateWithoutStudentsInput>
  }

  export type StudentUpsertWithoutAchievementsInput = {
    update: XOR<StudentUpdateWithoutAchievementsInput, StudentUncheckedUpdateWithoutAchievementsInput>
    create: XOR<StudentCreateWithoutAchievementsInput, StudentUncheckedCreateWithoutAchievementsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutAchievementsInput, StudentUncheckedUpdateWithoutAchievementsInput>
  }

  export type StudentUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AchievementUpsertWithoutStudentsInput = {
    update: XOR<AchievementUpdateWithoutStudentsInput, AchievementUncheckedUpdateWithoutStudentsInput>
    create: XOR<AchievementCreateWithoutStudentsInput, AchievementUncheckedCreateWithoutStudentsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutStudentsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutStudentsInput, AchievementUncheckedUpdateWithoutStudentsInput>
  }

  export type AchievementUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    points?: IntFieldUpdateOperationsInput | number
    criteria?: AchievementUpdatecriteriaInput | string[]
    rarity?: EnumRarityFieldUpdateOperationsInput | $Enums.Rarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    category?: EnumAchievementCategoryFieldUpdateOperationsInput | $Enums.AchievementCategory
    points?: IntFieldUpdateOperationsInput | number
    criteria?: AchievementUpdatecriteriaInput | string[]
    rarity?: EnumRarityFieldUpdateOperationsInput | $Enums.Rarity
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutBehaviorRecordsInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutBehaviorRecordsInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
    reportCards?: ReportCardUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutBehaviorRecordsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
  }

  export type TeacherCreateWithoutBehaviorRecordsInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
  }

  export type TeacherUncheckedCreateWithoutBehaviorRecordsInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type TeacherCreateOrConnectWithoutBehaviorRecordsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutBehaviorRecordsInput, TeacherUncheckedCreateWithoutBehaviorRecordsInput>
  }

  export type StudentUpsertWithoutBehaviorRecordsInput = {
    update: XOR<StudentUpdateWithoutBehaviorRecordsInput, StudentUncheckedUpdateWithoutBehaviorRecordsInput>
    create: XOR<StudentCreateWithoutBehaviorRecordsInput, StudentUncheckedCreateWithoutBehaviorRecordsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutBehaviorRecordsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutBehaviorRecordsInput, StudentUncheckedUpdateWithoutBehaviorRecordsInput>
  }

  export type StudentUpdateWithoutBehaviorRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutBehaviorRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherUpsertWithoutBehaviorRecordsInput = {
    update: XOR<TeacherUpdateWithoutBehaviorRecordsInput, TeacherUncheckedUpdateWithoutBehaviorRecordsInput>
    create: XOR<TeacherCreateWithoutBehaviorRecordsInput, TeacherUncheckedCreateWithoutBehaviorRecordsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutBehaviorRecordsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutBehaviorRecordsInput, TeacherUncheckedUpdateWithoutBehaviorRecordsInput>
  }

  export type TeacherUpdateWithoutBehaviorRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
  }

  export type TeacherUncheckedUpdateWithoutBehaviorRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type StudentCreateWithoutReportCardsInput = {
    id?: string
    studentId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    class?: ClassCreateNestedOneWithoutStudentsInput
    parents?: ParentCreateNestedManyWithoutChildrenInput
    grades?: GradeCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutReportCardsInput = {
    id?: string
    studentId: string
    userId: string
    classId?: string | null
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: ParentUncheckedCreateNestedManyWithoutChildrenInput
    grades?: GradeUncheckedCreateNestedManyWithoutStudentInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutStudentInput
    assignments?: AssignmentSubmissionUncheckedCreateNestedManyWithoutStudentInput
    achievements?: StudentAchievementUncheckedCreateNestedManyWithoutStudentInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutStudentInput
    financialRecords?: FinancialRecordUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutReportCardsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
  }

  export type StudentUpsertWithoutReportCardsInput = {
    update: XOR<StudentUpdateWithoutReportCardsInput, StudentUncheckedUpdateWithoutReportCardsInput>
    create: XOR<StudentCreateWithoutReportCardsInput, StudentUncheckedCreateWithoutReportCardsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutReportCardsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutReportCardsInput, StudentUncheckedUpdateWithoutReportCardsInput>
  }

  export type StudentUpdateWithoutReportCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutReportCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AssignmentCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutAssignmentsInput
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    classes?: AssignmentClassCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    teacherId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: AssignmentClassUncheckedCreateNestedManyWithoutAssignmentInput
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutAttachmentsInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutAttachmentsInput, AssignmentUncheckedCreateWithoutAttachmentsInput>
  }

  export type AssignmentSubmissionCreateWithoutAttachmentsInput = {
    id?: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment: AssignmentCreateNestedOneWithoutSubmissionsInput
    student: StudentCreateNestedOneWithoutAssignmentsInput
  }

  export type AssignmentSubmissionUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    assignmentId: string
    studentId: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionCreateOrConnectWithoutAttachmentsInput = {
    where: AssignmentSubmissionWhereUniqueInput
    create: XOR<AssignmentSubmissionCreateWithoutAttachmentsInput, AssignmentSubmissionUncheckedCreateWithoutAttachmentsInput>
  }

  export type MessageCreateWithoutAttachmentsInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    recipients?: UserCreateNestedManyWithoutReceivedMessagesInput
    parentMessage?: MessageCreateNestedOneWithoutRepliesInput
    replies?: MessageCreateNestedManyWithoutParentMessageInput
  }

  export type MessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    senderId: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipients?: UserUncheckedCreateNestedManyWithoutReceivedMessagesInput
    replies?: MessageUncheckedCreateNestedManyWithoutParentMessageInput
  }

  export type MessageCreateOrConnectWithoutAttachmentsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type AdmissionApplicationCreateWithoutDocumentsInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: ParentCreateNestedOneWithoutAdmissionApplicationsInput
    stepProgress?: AdmissionStepProgressCreateNestedManyWithoutApplicationInput
  }

  export type AdmissionApplicationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    parentId?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    stepProgress?: AdmissionStepProgressUncheckedCreateNestedManyWithoutApplicationInput
  }

  export type AdmissionApplicationCreateOrConnectWithoutDocumentsInput = {
    where: AdmissionApplicationWhereUniqueInput
    create: XOR<AdmissionApplicationCreateWithoutDocumentsInput, AdmissionApplicationUncheckedCreateWithoutDocumentsInput>
  }

  export type AssignmentUpsertWithoutAttachmentsInput = {
    update: XOR<AssignmentUpdateWithoutAttachmentsInput, AssignmentUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<AssignmentCreateWithoutAttachmentsInput, AssignmentUncheckedCreateWithoutAttachmentsInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutAttachmentsInput, AssignmentUncheckedUpdateWithoutAttachmentsInput>
  }

  export type AssignmentUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    classes?: AssignmentClassUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: AssignmentClassUncheckedUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentSubmissionUpsertWithoutAttachmentsInput = {
    update: XOR<AssignmentSubmissionUpdateWithoutAttachmentsInput, AssignmentSubmissionUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<AssignmentSubmissionCreateWithoutAttachmentsInput, AssignmentSubmissionUncheckedCreateWithoutAttachmentsInput>
    where?: AssignmentSubmissionWhereInput
  }

  export type AssignmentSubmissionUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: AssignmentSubmissionWhereInput
    data: XOR<AssignmentSubmissionUpdateWithoutAttachmentsInput, AssignmentSubmissionUncheckedUpdateWithoutAttachmentsInput>
  }

  export type AssignmentSubmissionUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
    student?: StudentUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpsertWithoutAttachmentsInput = {
    update: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<MessageCreateWithoutAttachmentsInput, MessageUncheckedCreateWithoutAttachmentsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutAttachmentsInput, MessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type MessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipients?: UserUpdateManyWithoutReceivedMessagesNestedInput
    parentMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUncheckedUpdateManyWithoutReceivedMessagesNestedInput
    replies?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
  }

  export type AdmissionApplicationUpsertWithoutDocumentsInput = {
    update: XOR<AdmissionApplicationUpdateWithoutDocumentsInput, AdmissionApplicationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AdmissionApplicationCreateWithoutDocumentsInput, AdmissionApplicationUncheckedCreateWithoutDocumentsInput>
    where?: AdmissionApplicationWhereInput
  }

  export type AdmissionApplicationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AdmissionApplicationWhereInput
    data: XOR<AdmissionApplicationUpdateWithoutDocumentsInput, AdmissionApplicationUncheckedUpdateWithoutDocumentsInput>
  }

  export type AdmissionApplicationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneWithoutAdmissionApplicationsNestedInput
    stepProgress?: AdmissionStepProgressUpdateManyWithoutApplicationNestedInput
  }

  export type AdmissionApplicationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stepProgress?: AdmissionStepProgressUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentCreateNestedOneWithoutUserInput
    teacher?: TeacherCreateNestedOneWithoutUserInput
    parent?: ParentCreateNestedOneWithoutUserInput
    admin?: AdminCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name: string
    password: string
    avatar?: string | null
    phone?: string | null
    address?: string | null
    dateOfBirth?: Date | string | null
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    emailVerifiedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    teacher?: TeacherUncheckedCreateNestedOneWithoutUserInput
    parent?: ParentUncheckedCreateNestedOneWithoutUserInput
    admin?: AdminUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutRecipientsInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutRecipientsNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
  }

  export type TeacherCreateWithoutSubjectsInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    classes?: TeacherClassCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutSubjectsInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: TeacherClassUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutSubjectsInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutTeachersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectCreateNestedManyWithoutSubjectInput
    grades?: GradeCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classes?: ClassSubjectUncheckedCreateNestedManyWithoutSubjectInput
    grades?: GradeUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutTeachersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherUpsertWithoutSubjectsInput = {
    update: XOR<TeacherUpdateWithoutSubjectsInput, TeacherUncheckedUpdateWithoutSubjectsInput>
    create: XOR<TeacherCreateWithoutSubjectsInput, TeacherUncheckedCreateWithoutSubjectsInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutSubjectsInput, TeacherUncheckedUpdateWithoutSubjectsInput>
  }

  export type TeacherUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    classes?: TeacherClassUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: TeacherClassUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type SubjectUpsertWithoutTeachersInput = {
    update: XOR<SubjectUpdateWithoutTeachersInput, SubjectUncheckedUpdateWithoutTeachersInput>
    create: XOR<SubjectCreateWithoutTeachersInput, SubjectUncheckedCreateWithoutTeachersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutTeachersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutTeachersInput, SubjectUncheckedUpdateWithoutTeachersInput>
  }

  export type SubjectUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUpdateManyWithoutSubjectNestedInput
    grades?: GradeUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: ClassSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type TeacherCreateWithoutClassesInput = {
    id?: string
    employeeId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTeacherInput
    subjects?: TeacherSubjectCreateNestedManyWithoutTeacherInput
    grades?: GradeCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordCreateNestedManyWithoutTeacherInput
  }

  export type TeacherUncheckedCreateWithoutClassesInput = {
    id?: string
    employeeId: string
    userId: string
    department: string
    qualifications?: TeacherCreatequalificationsInput | string[]
    hireDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: TeacherSubjectUncheckedCreateNestedManyWithoutTeacherInput
    grades?: GradeUncheckedCreateNestedManyWithoutTeacherInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutTeacherInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutTeacherInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTeacherInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutTeacherInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutCreatedByInput
    behaviorRecords?: BehaviorRecordUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherCreateOrConnectWithoutClassesInput = {
    where: TeacherWhereUniqueInput
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
  }

  export type ClassCreateWithoutTeachersInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    schedules?: ScheduleCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutTeachersInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutTeachersInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
  }

  export type TeacherUpsertWithoutClassesInput = {
    update: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
    create: XOR<TeacherCreateWithoutClassesInput, TeacherUncheckedCreateWithoutClassesInput>
    where?: TeacherWhereInput
  }

  export type TeacherUpdateToOneWithWhereWithoutClassesInput = {
    where?: TeacherWhereInput
    data: XOR<TeacherUpdateWithoutClassesInput, TeacherUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeacherNestedInput
    subjects?: TeacherSubjectUpdateManyWithoutTeacherNestedInput
    grades?: GradeUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    qualifications?: TeacherUpdatequalificationsInput | string[]
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: TeacherSubjectUncheckedUpdateManyWithoutTeacherNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTeacherNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutTeacherNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutTeacherNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTeacherNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutTeacherNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutCreatedByNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassUpsertWithoutTeachersInput = {
    update: XOR<ClassUpdateWithoutTeachersInput, ClassUncheckedUpdateWithoutTeachersInput>
    create: XOR<ClassCreateWithoutTeachersInput, ClassUncheckedCreateWithoutTeachersInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutTeachersInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutTeachersInput, ClassUncheckedUpdateWithoutTeachersInput>
  }

  export type ClassUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutTeachersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput
  }

  export type ClassCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherClassCreateNestedManyWithoutClassInput
    schedules?: ScheduleCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutSubjectsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherClassUncheckedCreateNestedManyWithoutClassInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClassInput
    assignments?: AssignmentClassUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutSubjectsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
  }

  export type SubjectCreateWithoutClassesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectCreateNestedManyWithoutSubjectInput
    grades?: GradeCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutClassesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    department: string
    credits?: number
    color?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teachers?: TeacherSubjectUncheckedCreateNestedManyWithoutSubjectInput
    grades?: GradeUncheckedCreateNestedManyWithoutSubjectInput
    assignments?: AssignmentUncheckedCreateNestedManyWithoutSubjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutSubjectInput
    resources?: LearningResourceUncheckedCreateNestedManyWithoutSubjectInput
    virtualClasses?: VirtualClassUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutClassesInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
  }

  export type ClassUpsertWithoutSubjectsInput = {
    update: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
    create: XOR<ClassCreateWithoutSubjectsInput, ClassUncheckedCreateWithoutSubjectsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutSubjectsInput, ClassUncheckedUpdateWithoutSubjectsInput>
  }

  export type ClassUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUncheckedUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutClassNestedInput
    assignments?: AssignmentClassUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput
  }

  export type SubjectUpsertWithoutClassesInput = {
    update: XOR<SubjectUpdateWithoutClassesInput, SubjectUncheckedUpdateWithoutClassesInput>
    create: XOR<SubjectCreateWithoutClassesInput, SubjectUncheckedCreateWithoutClassesInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutClassesInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutClassesInput, SubjectUncheckedUpdateWithoutClassesInput>
  }

  export type SubjectUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUpdateManyWithoutSubjectNestedInput
    grades?: GradeUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    department?: StringFieldUpdateOperationsInput | string
    credits?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teachers?: TeacherSubjectUncheckedUpdateManyWithoutSubjectNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSubjectNestedInput
    assignments?: AssignmentUncheckedUpdateManyWithoutSubjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutSubjectNestedInput
    resources?: LearningResourceUncheckedUpdateManyWithoutSubjectNestedInput
    virtualClasses?: VirtualClassUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type AssignmentCreateWithoutClassesInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherCreateNestedOneWithoutAssignmentsInput
    subject: SubjectCreateNestedOneWithoutAssignmentsInput
    submissions?: AssignmentSubmissionCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentUncheckedCreateWithoutClassesInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    teacherId: string
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: AssignmentSubmissionUncheckedCreateNestedManyWithoutAssignmentInput
    attachments?: FileAttachmentUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type AssignmentCreateOrConnectWithoutClassesInput = {
    where: AssignmentWhereUniqueInput
    create: XOR<AssignmentCreateWithoutClassesInput, AssignmentUncheckedCreateWithoutClassesInput>
  }

  export type ClassCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutClassInput
    teachers?: TeacherClassCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectCreateNestedManyWithoutClassInput
    schedules?: ScheduleCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantCreateNestedManyWithoutClassInput
  }

  export type ClassUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    level: string
    academicYear: string
    room?: string | null
    maxStudents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutClassInput
    teachers?: TeacherClassUncheckedCreateNestedManyWithoutClassInput
    subjects?: ClassSubjectUncheckedCreateNestedManyWithoutClassInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClassInput
    attendanceRecords?: AttendanceRecordUncheckedCreateNestedManyWithoutClassInput
    virtualClasses?: VirtualClassParticipantUncheckedCreateNestedManyWithoutClassInput
  }

  export type ClassCreateOrConnectWithoutAssignmentsInput = {
    where: ClassWhereUniqueInput
    create: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
  }

  export type AssignmentUpsertWithoutClassesInput = {
    update: XOR<AssignmentUpdateWithoutClassesInput, AssignmentUncheckedUpdateWithoutClassesInput>
    create: XOR<AssignmentCreateWithoutClassesInput, AssignmentUncheckedCreateWithoutClassesInput>
    where?: AssignmentWhereInput
  }

  export type AssignmentUpdateToOneWithWhereWithoutClassesInput = {
    where?: AssignmentWhereInput
    data: XOR<AssignmentUpdateWithoutClassesInput, AssignmentUncheckedUpdateWithoutClassesInput>
  }

  export type AssignmentUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type ClassUpsertWithoutAssignmentsInput = {
    update: XOR<ClassUpdateWithoutAssignmentsInput, ClassUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ClassCreateWithoutAssignmentsInput, ClassUncheckedCreateWithoutAssignmentsInput>
    where?: ClassWhereInput
  }

  export type ClassUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ClassWhereInput
    data: XOR<ClassUpdateWithoutAssignmentsInput, ClassUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ClassUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUpdateManyWithoutClassNestedInput
  }

  export type ClassUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    maxStudents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutClassNestedInput
    teachers?: TeacherClassUncheckedUpdateManyWithoutClassNestedInput
    subjects?: ClassSubjectUncheckedUpdateManyWithoutClassNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutClassNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutClassNestedInput
    virtualClasses?: VirtualClassParticipantUncheckedUpdateManyWithoutClassNestedInput
  }

  export type MessageCreateManySenderInput = {
    id?: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    parentMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    category: $Enums.NotificationCategory
    read?: boolean
    actionRequired?: boolean
    actionUrl?: string | null
    scheduledFor?: Date | string | null
    channels?: NotificationCreatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    token: string
    deviceInfo?: string | null
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUpdateManyWithoutReceivedMessagesNestedInput
    parentMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUncheckedUpdateManyWithoutReceivedMessagesNestedInput
    replies?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    parentMessage?: MessageUpdateOneWithoutRepliesNestedInput
    replies?: MessageUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    parentMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    read?: BoolFieldUpdateOperationsInput | boolean
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    read?: BoolFieldUpdateOperationsInput | boolean
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    category?: EnumNotificationCategoryFieldUpdateOperationsInput | $Enums.NotificationCategory
    read?: BoolFieldUpdateOperationsInput | boolean
    actionRequired?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channels?: NotificationUpdatechannelsInput | $Enums.NotificationChannel[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyStudentInput = {
    id?: string
    subjectId: string
    teacherId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateManyStudentInput = {
    id?: string
    classId?: string | null
    teacherId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentSubmissionCreateManyStudentInput = {
    id?: string
    assignmentId: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentAchievementCreateManyStudentInput = {
    id?: string
    achievementId: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
  }

  export type BehaviorRecordCreateManyStudentInput = {
    id?: string
    teacherId: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FinancialRecordCreateManyStudentInput = {
    id?: string
    type: $Enums.FinancialType
    amount: number
    currency?: string
    dueDate: Date | string
    paidDate?: Date | string | null
    status?: $Enums.PaymentStatus
    description: string
    paymentMethod?: $Enums.PaymentMethod | null
    invoiceNumber: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCardCreateManyStudentInput = {
    id?: string
    academicYear: string
    semester: string
    overallAverage: number
    rank?: number | null
    totalStudents?: number | null
    behaviorGrade?: $Enums.BehaviorGrade
    totalDays: number
    presentDays: number
    absentDays: number
    lateCount: number
    principalComment?: string | null
    generatedAt: Date | string
    generatedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParentNestedInput
    admissionApplications?: AdmissionApplicationUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionApplications?: AdmissionApplicationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateManyWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    preferredContactMethod?: EnumContactMethodFieldUpdateOperationsInput | $Enums.ContactMethod
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutGradesNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneWithoutAttendanceRecordsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentSubmissionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneRequiredWithoutSubmissionsNestedInput
    attachments?: FileAttachmentUpdateManyWithoutSubmissionNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: FileAttachmentUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentAchievementUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    achievement?: AchievementUpdateOneRequiredWithoutStudentsNestedInput
  }

  export type StudentAchievementUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentAchievementUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehaviorRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutBehaviorRecordsNestedInput
  }

  export type BehaviorRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialRecordUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialTypeFieldUpdateOperationsInput | $Enums.FinancialType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialRecordUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialTypeFieldUpdateOperationsInput | $Enums.FinancialType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FinancialRecordUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFinancialTypeFieldUpdateOperationsInput | $Enums.FinancialType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paidDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    description?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    overallAverage?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    behaviorGrade?: EnumBehaviorGradeFieldUpdateOperationsInput | $Enums.BehaviorGrade
    totalDays?: IntFieldUpdateOperationsInput | number
    presentDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    overallAverage?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    behaviorGrade?: EnumBehaviorGradeFieldUpdateOperationsInput | $Enums.BehaviorGrade
    totalDays?: IntFieldUpdateOperationsInput | number
    presentDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCardUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    overallAverage?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    totalStudents?: NullableIntFieldUpdateOperationsInput | number | null
    behaviorGrade?: EnumBehaviorGradeFieldUpdateOperationsInput | $Enums.BehaviorGrade
    totalDays?: IntFieldUpdateOperationsInput | number
    presentDays?: IntFieldUpdateOperationsInput | number
    absentDays?: IntFieldUpdateOperationsInput | number
    lateCount?: IntFieldUpdateOperationsInput | number
    principalComment?: NullableStringFieldUpdateOperationsInput | string | null
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherSubjectCreateManyTeacherInput = {
    subjectId: string
  }

  export type TeacherClassCreateManyTeacherInput = {
    classId: string
    isMainTeacher?: boolean
  }

  export type GradeCreateManyTeacherInput = {
    id?: string
    studentId: string
    subjectId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManyTeacherInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    subjectId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceRecordCreateManyTeacherInput = {
    id?: string
    studentId: string
    classId?: string | null
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManyTeacherInput = {
    id?: string
    classId: string
    subjectId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VirtualClassCreateManyTeacherInput = {
    id?: string
    title: string
    description: string
    subjectId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningResourceCreateManyCreatedByInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    subjectId: string
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorRecordCreateManyTeacherInput = {
    id?: string
    studentId: string
    date: Date | string
    type: $Enums.BehaviorType
    category: $Enums.BehaviorCategory
    description: string
    severity?: $Enums.Severity | null
    actionTaken?: string | null
    parentNotified?: boolean
    followUpRequired?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherSubjectUpdateWithoutTeacherInput = {
    subject?: SubjectUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutTeacherInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutTeacherInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherClassUpdateWithoutTeacherInput = {
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
    class?: ClassUpdateOneRequiredWithoutTeachersNestedInput
  }

  export type TeacherClassUncheckedUpdateWithoutTeacherInput = {
    classId?: StringFieldUpdateOperationsInput | string
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherClassUncheckedUpdateManyWithoutTeacherInput = {
    classId?: StringFieldUpdateOperationsInput | string
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type GradeUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutAssignmentsNestedInput
    classes?: AssignmentClassUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: AssignmentClassUncheckedUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    class?: ClassUpdateOneWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutSchedulesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutVirtualClassesNestedInput
    classes?: VirtualClassParticipantUpdateManyWithoutVirtualClassNestedInput
  }

  export type VirtualClassUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: VirtualClassParticipantUncheckedUpdateManyWithoutVirtualClassNestedInput
  }

  export type VirtualClassUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningResourceUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type LearningResourceUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    subjectId?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningResourceUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    subjectId?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutBehaviorRecordsNestedInput
  }

  export type BehaviorRecordUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorRecordUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumBehaviorTypeFieldUpdateOperationsInput | $Enums.BehaviorType
    category?: EnumBehaviorCategoryFieldUpdateOperationsInput | $Enums.BehaviorCategory
    description?: StringFieldUpdateOperationsInput | string
    severity?: NullableEnumSeverityFieldUpdateOperationsInput | $Enums.Severity | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    followUpRequired?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionApplicationCreateManyParentInput = {
    id?: string
    applicationNumber: string
    firstName: string
    lastName: string
    dateOfBirth: Date | string
    gender: $Enums.Gender
    nationality: string
    previousSchool?: string | null
    desiredClass: string
    academicYear: string
    specialNeeds?: string | null
    fatherName: string
    fatherEmail: string
    fatherPhone: string
    fatherOccupation?: string | null
    motherName: string
    motherEmail: string
    motherPhone: string
    motherOccupation?: string | null
    guardianName?: string | null
    guardianEmail?: string | null
    guardianPhone?: string | null
    familyAddress: string
    status?: $Enums.AdmissionStatus
    submittedAt?: Date | string
    reviewedAt?: Date | string | null
    reviewedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    class?: ClassUpdateOneWithoutStudentsNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    classId?: NullableStringFieldUpdateOperationsInput | string | null
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionApplicationUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FileAttachmentUpdateManyWithoutAdmissionNestedInput
    stepProgress?: AdmissionStepProgressUpdateManyWithoutApplicationNestedInput
  }

  export type AdmissionApplicationUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FileAttachmentUncheckedUpdateManyWithoutAdmissionNestedInput
    stepProgress?: AdmissionStepProgressUncheckedUpdateManyWithoutApplicationNestedInput
  }

  export type AdmissionApplicationUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    nationality?: StringFieldUpdateOperationsInput | string
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    desiredClass?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    specialNeeds?: NullableStringFieldUpdateOperationsInput | string | null
    fatherName?: StringFieldUpdateOperationsInput | string
    fatherEmail?: StringFieldUpdateOperationsInput | string
    fatherPhone?: StringFieldUpdateOperationsInput | string
    fatherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    motherName?: StringFieldUpdateOperationsInput | string
    motherEmail?: StringFieldUpdateOperationsInput | string
    motherPhone?: StringFieldUpdateOperationsInput | string
    motherOccupation?: NullableStringFieldUpdateOperationsInput | string | null
    guardianName?: NullableStringFieldUpdateOperationsInput | string | null
    guardianEmail?: NullableStringFieldUpdateOperationsInput | string | null
    guardianPhone?: NullableStringFieldUpdateOperationsInput | string | null
    familyAddress?: StringFieldUpdateOperationsInput | string
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyClassInput = {
    id?: string
    studentId: string
    userId: string
    parentIds?: StudentCreateparentIdsInput | string[]
    admissionDate: Date | string
    academicYear: string
    allergies?: StudentCreateallergiesInput | string[]
    medications?: StudentCreatemedicationsInput | string[]
    emergencyMedicalContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherClassCreateManyClassInput = {
    teacherId: string
    isMainTeacher?: boolean
  }

  export type ClassSubjectCreateManyClassInput = {
    subjectId: string
  }

  export type ScheduleCreateManyClassInput = {
    id?: string
    teacherId: string
    subjectId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentClassCreateManyClassInput = {
    assignmentId: string
  }

  export type AttendanceRecordCreateManyClassInput = {
    id?: string
    studentId: string
    teacherId: string
    date: Date | string
    status: $Enums.AttendanceStatus
    period?: string | null
    reason?: string | null
    notifiedParents?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VirtualClassParticipantCreateManyClassInput = {
    id?: string
    virtualClassId: string
  }

  export type StudentUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    parents?: ParentUpdateManyWithoutChildrenNestedInput
    grades?: GradeUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: ParentUncheckedUpdateManyWithoutChildrenNestedInput
    grades?: GradeUncheckedUpdateManyWithoutStudentNestedInput
    attendanceRecords?: AttendanceRecordUncheckedUpdateManyWithoutStudentNestedInput
    assignments?: AssignmentSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    achievements?: StudentAchievementUncheckedUpdateManyWithoutStudentNestedInput
    behaviorRecords?: BehaviorRecordUncheckedUpdateManyWithoutStudentNestedInput
    financialRecords?: FinancialRecordUncheckedUpdateManyWithoutStudentNestedInput
    reportCards?: ReportCardUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    parentIds?: StudentUpdateparentIdsInput | string[]
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: StringFieldUpdateOperationsInput | string
    allergies?: StudentUpdateallergiesInput | string[]
    medications?: StudentUpdatemedicationsInput | string[]
    emergencyMedicalContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherClassUpdateWithoutClassInput = {
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeacherUpdateOneRequiredWithoutClassesNestedInput
  }

  export type TeacherClassUncheckedUpdateWithoutClassInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeacherClassUncheckedUpdateManyWithoutClassInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
    isMainTeacher?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClassSubjectUpdateWithoutClassInput = {
    subject?: SubjectUpdateOneRequiredWithoutClassesNestedInput
  }

  export type ClassSubjectUncheckedUpdateWithoutClassInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectUncheckedUpdateManyWithoutClassInput = {
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutSchedulesNestedInput
    subject?: SubjectUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentClassUpdateWithoutClassInput = {
    assignment?: AssignmentUpdateOneRequiredWithoutClassesNestedInput
  }

  export type AssignmentClassUncheckedUpdateWithoutClassInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentClassUncheckedUpdateManyWithoutClassInput = {
    assignmentId?: StringFieldUpdateOperationsInput | string
  }

  export type AttendanceRecordUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAttendanceRecordsNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutAttendanceRecordsNestedInput
  }

  export type AttendanceRecordUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceRecordUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    period?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notifiedParents?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassParticipantUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualClass?: VirtualClassUpdateOneRequiredWithoutClassesNestedInput
  }

  export type VirtualClassParticipantUncheckedUpdateWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualClassId?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualClassParticipantUncheckedUpdateManyWithoutClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    virtualClassId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectCreateManySubjectInput = {
    teacherId: string
  }

  export type ClassSubjectCreateManySubjectInput = {
    classId: string
  }

  export type GradeCreateManySubjectInput = {
    id?: string
    studentId: string
    teacherId: string
    value: number
    maxValue?: number
    type: $Enums.GradeType
    comment?: string | null
    date: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentCreateManySubjectInput = {
    id?: string
    title: string
    description: string
    instructions: string
    type: $Enums.AssignmentType
    priority?: $Enums.Priority
    maxGrade?: number
    dueDate: Date | string
    submissionFormat?: $Enums.SubmissionFormat
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManySubjectInput = {
    id?: string
    classId: string
    teacherId: string
    room: string
    dayOfWeek: number
    startTime: string
    endTime: string
    duration: number
    academicYear: string
    semester: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LearningResourceCreateManySubjectInput = {
    id?: string
    title: string
    description: string
    type: $Enums.ResourceType
    level: string
    url: string
    thumbnail?: string | null
    duration?: number | null
    tags?: LearningResourceCreatetagsInput | string[]
    createdById: string
    accessLevel?: $Enums.AccessLevel
    downloadable?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VirtualClassCreateManySubjectInput = {
    id?: string
    title: string
    description: string
    teacherId: string
    scheduledStart: Date | string
    scheduledEnd: Date | string
    meetingUrl: string
    recordingUrl?: string | null
    status?: $Enums.VirtualClassStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeacherSubjectUpdateWithoutSubjectInput = {
    teacher?: TeacherUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type TeacherSubjectUncheckedUpdateWithoutSubjectInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type TeacherSubjectUncheckedUpdateManyWithoutSubjectInput = {
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectUpdateWithoutSubjectInput = {
    class?: ClassUpdateOneRequiredWithoutSubjectsNestedInput
  }

  export type ClassSubjectUncheckedUpdateWithoutSubjectInput = {
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type ClassSubjectUncheckedUpdateManyWithoutSubjectInput = {
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type GradeUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutGradesNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    maxValue?: FloatFieldUpdateOperationsInput | number
    type?: EnumGradeTypeFieldUpdateOperationsInput | $Enums.GradeType
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutAssignmentsNestedInput
    classes?: AssignmentClassUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: AssignmentClassUncheckedUpdateManyWithoutAssignmentNestedInput
    submissions?: AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type AssignmentUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    instructions?: StringFieldUpdateOperationsInput | string
    type?: EnumAssignmentTypeFieldUpdateOperationsInput | $Enums.AssignmentType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    maxGrade?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    submissionFormat?: EnumSubmissionFormatFieldUpdateOperationsInput | $Enums.SubmissionFormat
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    class?: ClassUpdateOneRequiredWithoutSchedulesNestedInput
    teacher?: TeacherUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    academicYear?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningResourceUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: TeacherUpdateOneRequiredWithoutResourcesNestedInput
  }

  export type LearningResourceUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    createdById?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningResourceUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumResourceTypeFieldUpdateOperationsInput | $Enums.ResourceType
    level?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: LearningResourceUpdatetagsInput | string[]
    createdById?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    downloadable?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherUpdateOneRequiredWithoutVirtualClassesNestedInput
    classes?: VirtualClassParticipantUpdateManyWithoutVirtualClassNestedInput
  }

  export type VirtualClassUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classes?: VirtualClassParticipantUncheckedUpdateManyWithoutVirtualClassNestedInput
  }

  export type VirtualClassUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    scheduledStart?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    meetingUrl?: StringFieldUpdateOperationsInput | string
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVirtualClassStatusFieldUpdateOperationsInput | $Enums.VirtualClassStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssignmentClassCreateManyAssignmentInput = {
    classId: string
  }

  export type AssignmentSubmissionCreateManyAssignmentInput = {
    id?: string
    studentId: string
    content?: string | null
    submittedAt?: Date | string | null
    grade?: number | null
    feedback?: string | null
    status?: $Enums.SubmissionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentCreateManyAssignmentInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    submissionId?: string | null
    messageId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssignmentClassUpdateWithoutAssignmentInput = {
    class?: ClassUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type AssignmentClassUncheckedUpdateWithoutAssignmentInput = {
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentClassUncheckedUpdateManyWithoutAssignmentInput = {
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type AssignmentSubmissionUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutAssignmentsNestedInput
    attachments?: FileAttachmentUpdateManyWithoutSubmissionNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attachments?: FileAttachmentUncheckedUpdateManyWithoutSubmissionNestedInput
  }

  export type AssignmentSubmissionUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    grade?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSubmissionStatusFieldUpdateOperationsInput | $Enums.SubmissionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submission?: AssignmentSubmissionUpdateOneWithoutAttachmentsNestedInput
    message?: MessageUpdateOneWithoutAttachmentsNestedInput
    admission?: AdmissionApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type FileAttachmentUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentCreateManySubmissionInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    messageId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutAttachmentsNestedInput
    message?: MessageUpdateOneWithoutAttachmentsNestedInput
    admission?: AdmissionApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type FileAttachmentUncheckedUpdateWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentUncheckedUpdateManyWithoutSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyParentMessageInput = {
    id?: string
    senderId: string
    recipientIds?: MessageCreaterecipientIdsInput | string[]
    subject: string
    content: string
    type?: $Enums.MessageType
    priority?: $Enums.Priority
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentCreateManyMessageInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    submissionId?: string | null
    admissionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneWithoutUserNestedInput
    teacher?: TeacherUpdateOneWithoutUserNestedInput
    parent?: ParentUpdateOneWithoutUserNestedInput
    admin?: AdminUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    teacher?: TeacherUncheckedUpdateOneWithoutUserNestedInput
    parent?: ParentUncheckedUpdateOneWithoutUserNestedInput
    admin?: AdminUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    recipients?: UserUpdateManyWithoutReceivedMessagesNestedInput
    replies?: MessageUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: UserUncheckedUpdateManyWithoutReceivedMessagesNestedInput
    replies?: MessageUncheckedUpdateManyWithoutParentMessageNestedInput
    attachments?: FileAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutParentMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    recipientIds?: MessageUpdaterecipientIdsInput | string[]
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutAttachmentsNestedInput
    submission?: AssignmentSubmissionUpdateOneWithoutAttachmentsNestedInput
    admission?: AdmissionApplicationUpdateOneWithoutDocumentsNestedInput
  }

  export type FileAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentCreateManyAdmissionInput = {
    id?: string
    name: string
    originalName: string
    url: string
    type: string
    size: number
    uploadedBy: string
    assignmentId?: string | null
    submissionId?: string | null
    messageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdmissionStepProgressCreateManyApplicationInput = {
    id?: string
    stepName: string
    status?: $Enums.StepStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    assignedTo?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAttachmentUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: AssignmentUpdateOneWithoutAttachmentsNestedInput
    submission?: AssignmentSubmissionUpdateOneWithoutAttachmentsNestedInput
    message?: MessageUpdateOneWithoutAttachmentsNestedInput
  }

  export type FileAttachmentUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAttachmentUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    uploadedBy?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    submissionId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionStepProgressUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepName?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionStepProgressUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepName?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionStepProgressUncheckedUpdateManyWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepName?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VirtualClassParticipantCreateManyVirtualClassInput = {
    id?: string
    classId: string
  }

  export type VirtualClassParticipantUpdateWithoutVirtualClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    class?: ClassUpdateOneRequiredWithoutVirtualClassesNestedInput
  }

  export type VirtualClassParticipantUncheckedUpdateWithoutVirtualClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type VirtualClassParticipantUncheckedUpdateManyWithoutVirtualClassInput = {
    id?: StringFieldUpdateOperationsInput | string
    classId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentAchievementCreateManyAchievementInput = {
    id?: string
    studentId: string
    earnedDate?: Date | string
    awardedBy: string
    evidence?: string | null
  }

  export type StudentAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type StudentAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    earnedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    awardedBy?: StringFieldUpdateOperationsInput | string
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherCountOutputTypeDefaultArgs instead
     */
    export type TeacherCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentCountOutputTypeDefaultArgs instead
     */
    export type ParentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassCountOutputTypeDefaultArgs instead
     */
    export type ClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectCountOutputTypeDefaultArgs instead
     */
    export type SubjectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentCountOutputTypeDefaultArgs instead
     */
    export type AssignmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentSubmissionCountOutputTypeDefaultArgs instead
     */
    export type AssignmentSubmissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentSubmissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageCountOutputTypeDefaultArgs instead
     */
    export type MessageCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionApplicationCountOutputTypeDefaultArgs instead
     */
    export type AdmissionApplicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionApplicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VirtualClassCountOutputTypeDefaultArgs instead
     */
    export type VirtualClassCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VirtualClassCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementCountOutputTypeDefaultArgs instead
     */
    export type AchievementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherDefaultArgs instead
     */
    export type TeacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentDefaultArgs instead
     */
    export type ParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassDefaultArgs instead
     */
    export type ClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubjectDefaultArgs instead
     */
    export type SubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradeDefaultArgs instead
     */
    export type GradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentDefaultArgs instead
     */
    export type AssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentSubmissionDefaultArgs instead
     */
    export type AssignmentSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceRecordDefaultArgs instead
     */
    export type AttendanceRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleDefaultArgs instead
     */
    export type ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialRecordDefaultArgs instead
     */
    export type FinancialRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionApplicationDefaultArgs instead
     */
    export type AdmissionApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionStepProgressDefaultArgs instead
     */
    export type AdmissionStepProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionStepProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningResourceDefaultArgs instead
     */
    export type LearningResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VirtualClassDefaultArgs instead
     */
    export type VirtualClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VirtualClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VirtualClassParticipantDefaultArgs instead
     */
    export type VirtualClassParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VirtualClassParticipantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentAchievementDefaultArgs instead
     */
    export type StudentAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehaviorRecordDefaultArgs instead
     */
    export type BehaviorRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehaviorRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCardDefaultArgs instead
     */
    export type ReportCardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileAttachmentDefaultArgs instead
     */
    export type FileAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileAttachmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSessionDefaultArgs instead
     */
    export type UserSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherSubjectDefaultArgs instead
     */
    export type TeacherSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeacherClassDefaultArgs instead
     */
    export type TeacherClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeacherClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClassSubjectDefaultArgs instead
     */
    export type ClassSubjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClassSubjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AssignmentClassDefaultArgs instead
     */
    export type AssignmentClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AssignmentClassDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}